# -*- mode: org; eval: (add-hook 'after-save-hook #'hcps/byte-compile-org-config nil t) -*-
#+title: My Emacs configuration file
#+author: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br
#+infojs_opt:

These configurations represent my preferred version of Emacs, one that
uses =evil= everywhere it can and one that tries to be as minimalist as
+I want+ possible.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]
- [[https://github.com/hlissner][The doom-emacs guy]]

* Table of contents                                                   :TOC_3:
- [[#introduction][Introduction]]
  - [[#what-packages-you-can-find-here][What packages you can find here]]
  - [[#use-package][=use-package=]]
    - [[#ensure][:ensure]]
    - [[#after][:after]]
    - [[#defer][:defer]]
    - [[#demand][:demand]]
    - [[#init][:init]]
    - [[#config][:config]]
- [[#personal][Personal]]
  - [[#information][Information]]
  - [[#functions-and-macros][Functions and Macros]]
    - [[#fetching-text][Fetching text]]
    - [[#date][Date]]
    - [[#one-time-advice][One-time advice]]
    - [[#automatic-byte-compile][Automatic byte-compile]]
    - [[#auto-removing-hook][Auto-removing hook]]
    - [[#trim-functions][Trim functions]]
    - [[#fontification-of-sub-blocks][Fontification of sub-blocks]]
    - [[#modeline][Modeline]]
  - [[#keybindings][Keybindings]]
  - [[#definitions-and-preferences][Definitions and preferences]]
    - [[#default-org-mode][Default =org-mode=]]
    - [[#paths-and-defconst][Paths and =defconst=]]
    - [[#garbage-collection][Garbage collection]]
    - [[#gui-elements][GUI elements]]
    - [[#font][Font]]
    - [[#text][Text]]
    - [[#mode-line][Mode line]]
    - [[#line-numbering-and-scrolling][Line numbering and scrolling]]
    - [[#randoms][Randoms]]
    - [[#custom-file][Custom file]]
    - [[#better-eval-expression][Better =eval-expression=]]
- [[#package-configuration][Package configuration]]
  - [[#setting-up][Setting-up]]
    - [[#load-path][Load path]]
    - [[#byte-compile-setup][Byte-compile setup]]
  - [[#support][Support]]
    - [[#general][=general=]]
    - [[#delight][=delight=]]
    - [[#no-littering][=no-littering=]]
    - [[#hide-mode-line][=hide-mode-line=]]
  - [[#built-in][Built-in]]
    - [[#package][=package=]]
    - [[#whitespace][=whitespace=]]
    - [[#compile][=compile=]]
    - [[#tramp][=tramp=]]
    - [[#ssh][=ssh=]]
    - [[#ansi-color][=ansi-color=]]
    - [[#windmove][=windmove=]]
    - [[#midnight][=midnight=]]
    - [[#uniquify][=uniquify=]]
    - [[#recentf][=recentf=]]
    - [[#ibuffer][=ibuffer=]]
  - [[#extension][Extension]]
    - [[#evil][=evil=]]
    - [[#smart-mode-line][=smart-mode-line=]]
    - [[#ivy][=ivy=]]
    - [[#counsel][=counsel=]]
    - [[#undo-tree][=undo-tree=]]
    - [[#dashboard][=dashboard=]]
    - [[#treemacs][=treemacs=]]
    - [[#exec-path-from-shell][=exec-path-from-shell=]]
    - [[#anzu][=anzu=]]
    - [[#deadgrep][=deadgrep=]]
    - [[#link-hint][=link-hint=]]
    - [[#avy][=avy=]]
    - [[#which-key][=which-key=]]
    - [[#lsp-mode][=lsp-mode=]]
    - [[#flycheck][=flycheck=]]
    - [[#highlight-numbers][=highlight-numbers=]]
    - [[#highlight-escape-sequences][=highlight-escape-sequences=]]
    - [[#flyspell][=flyspell=]]
    - [[#diff-hl][=diff-hl=]]
    - [[#hydra][=hydra=]]
    - [[#ace-window][=ace-window=]]
    - [[#super-save][=super-save=]]
    - [[#yasnippet][=yasnippet=]]
    - [[#vimish-fold][=vimish-fold=]]
    - [[#projectile][=projectile=]]
    - [[#magit][=magit=]]
    - [[#git-timemachine][=git-timemachine=]]
    - [[#expand-region][=expand-region=]]
    - [[#smartparens][=smartparens=]]
    - [[#rainbow-delimiters][=rainbow-delimiters=]]
    - [[#beacon][=beacon=]]
    - [[#aggressive-indent][=aggressive-indent=]]
    - [[#highligh-indent-guides][=highligh-indent-guides=]]
    - [[#helpful][=helpful=]]
    - [[#engine-mode][=engine-mode=]]
    - [[#openwith][=openwith=]]
    - [[#crux][=crux=]]
    - [[#page-break-lines][=page-break-lines=]]
    - [[#writeroom-mode][=writeroom-mode=]]
  - [[#theme][Theme]]
- [[#file-modes][File modes]]
  - [[#org][Org]]
    - [[#add-ons][Add-ons]]
    - [[#export][Export]]
    - [[#babel][Babel]]
  - [[#c-like-languages][C-like languages]]
    - [[#cc][C/C++]]
    - [[#cuda][CUDA]]
  - [[#r][R]]
  - [[#shell-script][Shell script]]
  - [[#makefile][Makefile]]
  - [[#plantuml][PlantUML]]
  - [[#lisp][Lisp]]
  - [[#elisp][Elisp]]
  - [[#python][Python]]
  - [[#cmake][CMake]]
  - [[#dockerfile][Dockerfile]]
  - [[#gmpl][GMPL]]
  - [[#julia][Julia]]
  - [[#latex][LaTeX]]
  - [[#meson][Meson]]
  - [[#bspwmsxhkdrc][{bspwm,sxhkd}rc]]
  - [[#configuration-files][Configuration files]]
  - [[#rust][Rust]]
  - [[#perl][Perl]]
- [[#post-init][Post-init]]

* Introduction

First of all, welcome to my configuration file for Emacs. I built it
from almost the ground up, picking up configs from several sources, some
of which I've cited in the beginning of this file.

As I'd like that this file be used as a source of inspiration for
others, I wrote it in an =.org= file, using all of =org-mode='s black
magic powers of tangling source blocks to intertwine both source =.el=
and prose.

Also, I've used in almost all sections of this document a package called
=use-package= in order to organize all the additional packages that I
use to get a better Emacs experience. So, I'll teach you to read a
=use-package= statement! That way you can understand what's happening
beneath all sugar syntax.

** What packages you can find here

You can find the following packages in this configuration file:

#+begin_src shell :exports results :results value org list
[ ! -f 'config.el' ] && emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "config.org")'

grep -E '(^\(use-package .*|^ *:ensure .*)' config.el |
    tr -d '()' |
    awk '!/\<nil\>/ {print $2}' |
    sort

rm 'config.el'
#+end_src

#+RESULTS:
#+begin_src org
- ace-window
- aggressive-indent
- ansi-color
- anzu
- auctex
- auctex-latexmk
- avy
- bash-completion
- beacon
- bspwm
- cargo
- cc-mode
- clang-format
- cmake-font-lock
- cmake-mode
- compile
- conf-mode
- counsel
- counsel-projectile
- counsel-tramp
- cperl-mode
- crux
- cuda-mode
- dashboard
- deadgrep
- delight
- diff-hl
- dockerfile-mode
- docker-tramp
- elisp-mode
- elisp-slime-nav
- elpy
- engine-mode
- ess
- ess
- ess-r-mode
- evil
- evil-collection
- evil-matchit
- evil-mc
- evil-numbers
- evil-smartparens
- evil-surround
- exec-path-from-shell
- expand-region
- flx
- flycheck
- flyspell
- general
- git-timemachine
- gmpl-mode
- gruvbox-theme
- helpful
- hide-mode-line
- highlight-doxygen
- highlight-escape-sequences
- highlight-indent-guides
- highlight-numbers
- htmlize
- ibuffer
- ivy
- ivy-rich
- julia-mode
- jupyter
- link-hint
- lisp-mode
- lsp-mode
- lsp-ui
- magit
- make-mode
- meson-mode
- midnight
- modern-cpp-font-lock
- no-littering
- ob
- openwith
- org
- org-agenda
- org-capture
- org-journal
- org-plus-contrib
- org-ref
- org-refile
- ox
- ox-dnd
- ox-extra
- ox-hugo
- ox-latex
- ox-twbs
- package
- page-break-lines
- plantuml-mode
- projectile
- rainbow-delimiters
- recentf
- rust-mode
- sh-script
- smart-mode-line
- smartparens
- smex
- ssh
- super-save
- toc-org
- tramp
- treemacs
- treemacs-evil
- treemacs-projectile
- undo-tree
- uniquify
- vimish-fold
- visual-fill-column
- websocket
- which-key
- whitespace
- windmove
- writeroom-mode
- yasnippet
- zmq
#+end_src

** =use-package=

Briefly, this package wraps your configuration for a given package in a
neat little statement, which can include several useful categorizations
and sub-tools.

Here are all little keywords you can use to organize your configs:

*** :ensure

The =:ensure= keyword tells to =use-package= that this package should be
installed in the system. Without it, =use-package= will tell you that
the given package isn't installed and won't proceed.

I define a flag to tell =use-package= to activate this keyword by
default, because I want all packages that I use installed in the system!
Still, I can turn off this behaviour if I set the keyword to =false=.

#+begin_src emacs-lisp
(use-package foo
  :ensure t)      ; I need this package installed!

(use-package foo
  :ensure f)      ; I don't NEED the package installed
#+end_src

You can also use this keyword to tell that your package need another
installed before it loads!

#+begin_src emacs-lisp
  (use-package foo
    :ensure bar)
#+end_src

*** :after

The =:after= keyword sets a relation of dependency between the loading
of two packages. In other words, you can tell =use-package= that a given
package should only be loaded if that other package is already loaded.

#+begin_src emacs-lisp
(use-package foo)

(use-package bar
  :after foo)

(use-package moo
  :after (foo bar))    ; Supports mmultiple dependencies!
#+end_src

*** :defer

The =:defer= keyword tells =use-package= that it can defer the loading
of your package until its absolutely needed. Its behaviour is the
opposite of the keyword =:demand=.

#+begin_src emacs-lisp
(use-package foo
  :defer t)
#+end_src

*** :demand

The =:demand= keyword says to =use-package= that this package must not
be lazy-loaded, and should be loaded right away as Emacs loads.

#+begin_src emacs-lisp
(use-package foo
  :demand)
#+end_src

*** :init

The =:init= keyword can tell =use-package= to execute said commands
*BEFORE* the package is loaded. In reality, said execution will happen
as soon as the =use-package= statement is processed on the Emacs loading
process.

#+begin_src emacs-lisp
(use-package foo
  :init
  (setq bar t))
#+end_src

*** :config

The =:config= keyword, much like the =:init= keyword, tells
=use-package= to execute commands. The difference is that commands
defined with this keyword will only execute *AFTER* the package is
loaded. There is an important difference here, as =use-package= uses
what's called /lazy loading/, i.e. only load the package when you
actually need it.

#+begin_src emacs-lisp
(use-package foo
  :config
  (foo-init))
#+end_src

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff
you coded yourself.

To-do:

- [X] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Information

Some basic info about me.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Henrique Silva"
      user-mail-address "hcpsilva@inf.ufrgs.br")
#+end_src

** Functions and Macros

Some very useful functions I got from other people or that I coded
myself.

*** Fetching text

To get the current selected text without newlines.

#+begin_src emacs-lisp :tangle yes
(defun hcps/get-selected-text (start end)
  (interactive "r")
  (if (use-region-p)
      (kill-new
       (replace-regexp-in-string
        "\n" " "
        (regionp (buffer-substring start end))))))
#+end_src

*** Date

Insert the current date.

#+begin_src emacs-lisp :tangle yes
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+end_src

*** One-time advice

'Cause that is kinda cool to have. Got it from [[https://emacs.stackexchange.com/questions/26251/one-time-advice][this]] place.

#+begin_src emacs-lisp :tangle yes
(defun advise-once (symbol where function &optional props)
  (advice-add symbol :after `(lambda (&rest _) (advice-remove ',symbol ',function)))
  (advice-add symbol where function props))
#+end_src

*** Automatic byte-compile

To use with this configuration file.

#+begin_src emacs-lisp :tangle yes
(defconst config-file-name (expand-file-name "config.org" user-emacs-directory)
  "The path to the configuration ")

(defun hcps/byte-compile-org-config ()
  "To add as a hook when saving the config file."
  (if (y-or-n-p "Recompile config?")
      (let ((tangled-file (car (org-babel-tangle-file config-file-name))))
        (byte-compile-file tangled-file)
        (delete-file tangled-file))))
#+end_src

*** Auto-removing hook

Sometimes it's cool to have a single-use hook.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (defmacro hcps/hook-require-once (hook package)
    "Add a hook to `pre-command-hook' which requires the given package once."
    (let ((func (intern (concat "hcps/" (symbol-name hook) "-require-" (symbol-name package)))))
      `(progn
         (defun ,func ()
           (remove-hook ',hook #',func)
           (require ',package))
         (add-hook ',hook #',func)))))
#+end_src

*** Trim functions

Directly from Magnar Sveen's =s.el=

#+begin_src emacs-lisp :tangle yes
(defun hcps/s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (declare (pure t) (side-effect-free t))
  (if (string-match "\\`[ \t\n\r]+" s)
      (replace-match "" t t s)
    s))

(defun hcps/s-trim-right (s)
  "Remove whitespace at the end of S."
  (declare (pure t) (side-effect-free t))
  (if (string-match "[ \t\n\r]+\\'" s)
      (replace-match "" t t s)
    s))

(defun hcps/s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (declare (pure t) (side-effect-free t))
  (s-trim-left (s-trim-right s)))
#+end_src

*** Fontification of sub-blocks

Inside other languages or strings, like in shell-scripts and such.

- [ ] =org-src-font-lock-fontify-block=
  - =org-fontify-meta-lines-and-blocks=

*** Modeline

A clear modeline is prettier sometimes.

#+begin_src emacs-lisp :tangle yes
(defun hcps/clean-mode-line ()
  "Clean mode-line format."
  (setq-local mode-line-format ""))
#+end_src

** Keybindings

Here I'll define some of my personal keybindings, which means
"keybindings not related to some package configured in the sections
above"!

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'general
  (general-def '(global-map special-mode-map)
    "C-x C-b" 'ibuffer
    "C-x k" 'kill-this-buffer
    "C-c x" 'hcps/date-iso
    "<f9>" 'hcps/get-selected-text
    "M--" 'text-scale-decrease
    "M-+" 'text-scale-increase
    "C-S-h" 'previous-buffer
    "C-S-l" 'next-buffer
    "<f12>" 'menu-bar-mode)

  (general-def 'hcps/leader-map
    "C-b" 'ibuffer
    "s" 'save-buffer
    "k" 'kill-this-buffer
    "i" 'indent-region
    "e" 'eval-region
    "c" 'comment-dwim
    "w k" 'delete-window
    "w v" 'split-window-vertically
    "w h" 'split-window-horizontally
    "v n p" 'narrow-to-page
    "v n f" 'narrow-to-defun
    "v n r" 'narrow-to-region
    "v n w" 'widen)

  (general-def '(normal visual insert emacs special-mode-map)
    :prefix hcps/leader-key
    :non-normal-prefix (concat "M-" hcps/leader-key)
    "g" '(:ignore t :wk "git")
    "f" '(:ignore t :wk "file")
    "w" '(:ignore t :wk "window")
    "r" '(:ignore t :wk "replace")
    "p" '(:ignore t :wk "package")
    "n" '(:ignore t :wk "navigate")
    "o" '(:ignore t :wk "org")
    "m" '(:ignore t :wk "mode")
    "v" '(:ignore t :wk "view")
    "v n" '(:ignore t :wk "narrow")))
#+end_src

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** Default =org-mode=

To ensure ELPA =org= is prioritized above built-in org.

#+begin_src emacs-lisp :tangle yes
(setq load-path
      (delete (car (file-expand-wildcards "/usr/share/emacs/*/lisp/org")) load-path))
#+end_src

*** Paths and =defconst=

Silly names for easier path usage.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (defconst current-user (getenv "USER") "The current user.")
  (defconst home-dir (expand-file-name current-user "/home/") "The user home dir.")

  (defconst root-dir (expand-file-name user-emacs-directory) "The root dir of Emacs.")
  (defconst var-user-dir (expand-file-name "var" root-dir) "The temporaries directory.")
  (defconst vendor-user-dir (expand-file-name "vendor" root-dir) "The random .el directory.")
  (defconst onedrive-user-dir (expand-file-name "OneDrive" home-dir) "Default OneDrive path."))
#+end_src

*** Garbage collection

A better GC threshold for eval.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))
#+end_src

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen
space. Those are turned off in my =xresources= config.

To be fair, some stuff is really personal preference of mine.

#+begin_src emacs-lisp :tangle yes
(setq inhibit-startup-screen t)
#+end_src

And then there's the title question. I for one like Emacs capitalized,
so...

#+begin_src emacs-lisp :tangle yes
(setq-default frame-title-format
              '((capitalize invocation-name)
                (:eval (if (buffer-file-name)
                           (abbreviate-file-name (buffer-file-name))
                         "%b"))))
#+end_src

*** Font

I use the =Inconsolata= font!

#+begin_src emacs-lisp :tangle yes
(setq-default default-frame-alist '((font . "Source Code Pro-12")))
#+end_src

Before this, I used to use =Inconsolata-G=, which I couldn't find a
GitHub of sorts, here's a link to a mirror [[https://www.fontmirror.com/inconsolata-g][mirror]]. Also, you may end up
having some issues with this font, as Emacs only knows the XLFD (which
splits the important font info by the '-'), so our =Inconsolata-g= will
face some issues here and there. To fix this, duplicate the font in your
font directory (probably /usr/share/fonts/TTF) and alter the copy's name
as [[https://emacs.stackexchange.com/questions/16818/cocoa-emacs-24-5-font-issues-inconsolata-dz][this]] link indicates.

*** Text

Here's every other setting relating to text editing I can't categorize
any further.

#+begin_src emacs-lisp :tangle yes
(setq-default fill-column 72
              ;; posssible values: (left right center full nil)
              default-justification 'left
              indent-tabs-mode nil
              tab-always-indent 'complete
              sentence-end-double-space nil
              tab-width 4
              line-spacing 0
              truncate-lines t
              require-final-newline t
              x-stretch-cursor t
              cursor-in-non-selected-windows nil)
#+end_src

Also, =auto-fill-mode= is very useful to justify paragraphs
automatically while writing.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook #'turn-on-auto-fill)
#+end_src

*** Mode line

Here's everything related to the mode-line.

#+begin_src emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M "
              display-time-default-load-average nil)

(display-time-mode +1)
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+end_src

*** Line numbering and scrolling

+I like the vim style of relative numbering of lines.+ Never mind, I
grew tired of it.

#+begin_src emacs-lisp :tangle yes
(setq-default display-line-numbers-type t
              display-line-numbers-width-start 4)

;; I used to do this globally, but now let's only do selectively
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

And I also like the vim style of scrolling better.

#+begin_src emacs-lisp :tangle yes
(setq-default auto-window-vscroll t
              ;; line-move-visual nil
              scroll-conservatively 101
              scroll-margin 10)
#+end_src

Small fix for =scroll-margin=

#+begin_src emacs-lisp :tangle yes
(defun get-lines-from-top ()
  (save-excursion
    (beginning-of-line)
    (count-screen-lines (point) (window-start))))

(defun scroll-margin-fix (func &rest args)
  (apply func args)
  (if (> scroll-margin 0)
      (let ((diff (- (min scroll-margin (floor (* maximum-scroll-margin (window-screen-lines))))
                     (get-lines-from-top))))
        (when (> diff 0)
          (scroll-down 1)))))

(advice-add 'previous-line :around 'scroll-margin-fix)

(add-hook 'prog-mode-hook #'visual-line-mode)
#+end_src

Highlighting the current line is also very useful.

#+begin_src emacs-lisp :tangle yes
(global-hl-line-mode 1)
#+end_src

*** Randoms

Random configs and definitions that don't have a clear category.

#+begin_src emacs-lisp :tangle yes
(setq ad-redefinition-action 'accept         ; Silence warnings for redefinition
      confirm-kill-emacs 'yes-or-no-p        ; Confirm before exiting Emacs
      select-enable-clipboard t              ; Merge system's and Emacs' clipboard
      blink-matching-paren nil               ; Disable annoying blink-matching-paren
      window-combination-resize t            ; Resize windows proportionally
      ring-bell-function 'ignore)            ; No bell ring

(setq backup-directory-alist `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))

(add-hook 'after-save-hook
          #'executable-make-buffer-file-executable-if-script-p)

;; Replace yes/no prompts with y/n
(fset 'yes-or-no-p 'y-or-n-p)

;; Set Emacs to call the garbage collector on focus-out
;; (add-hook 'focus-out-hook #'garbage-collect)

;; use GPG-agent instead of the default
(setenv "SSH_AUTH_SOCK"
        (concat (getenv "XDG_RUNTIME_DIR") "/gnupg/S.gpg-agent.ssh"))

(global-auto-revert-mode t)

;; (setq hippie-expand-try-functions-list '(try-expand-dabbrev
;;                                          try-expand-dabbrev-all-buffers
;;                                          try-expand-dabbrev-from-kill
;;                                          try-complete-file-name-partially
;;                                          try-complete-file-name
;;                                          try-expand-all-abbrevs
;;                                          try-expand-list
;;                                          try-expand-line
;;                                          try-complete-lisp-symbol-partially
;;                                          try-complete-lisp-symbol))

;; (require 'ediff)
;; (setq ediff-window-setup-function 'ediff-setup-windows-plain)

;; (require 'eshell)
;; (setq eshell-directory-name (expand-file-name "eshell" var-user-dir))

;; (global-diff-hl-mode +1)
;; (add-hook 'dired-mode-hook 'diff-hl-dired-mode)

;; ;; use hippie-expand instead of dabbrev
;; (global-set-key (kbd "M-/") 'hippie-expand)

;; (require 'cl)
#+end_src

*** Custom file

Perhaps is necessary sometimes.

#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" var-user-dir))

(load custom-file)
#+end_src

*** Better =eval-expression=

Some basic configuration to enhance the =eval-expression= command.

#+begin_src emacs-lisp :tangle yes
(defun sane-eval-expr-defaults ()
  "Enable some sane modes for `eval-expression'."
  (smartparens-mode +1))

(add-hook 'eval-expression-minibuffer-setup-hook #'sane-eval-expr-defaults)
#+end_src

* Package configuration

Everything that isn't an specific file-mode =.el=.

** Setting-up

Some setting up before we start configuring the packages themselves.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir (expand-file-name "elpa" user-emacs-directory)
        package--init-file-ensured t
        package-enable-at-startup nil)

  (unless (file-directory-p package-user-dir)
    (make-directory package-user-dir t)))
#+end_src

*** Load path

And then let's initialize the load path:

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+end_src

*** Byte-compile setup

I use =use-package= to load my packages and to organize them neatly in
this org file.

#+begin_src emacs-lisp :tangle yes
(setq use-package-verbose t
      use-package-hook-name-suffix nil)

(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))

(eval-when-compile
  (require 'package)

  (setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")
          ("gnu" . "https://elpa.gnu.org/packages/")))

  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)

  (setq use-package-always-ensure t))

(add-hook 'emacs-startup-hook (lambda () (require 'use-package)))
#+end_src

** Support

All these packages just help on the configuration of the rest of the
other packages.

*** =general=                                                 :keybindings:

To facilitate my keybinding issues, I also use =general.el=. It adds
some very welcome keywords to =use-package=, in which I'll use
extensively throughout this file.

#+begin_src emacs-lisp :tangle yes
(use-package general
  :commands (general-define-key general-def general-unbind)
  :preface
  (defconst hcps/leader-key "SPC"
    "Leader key for some special commands.")
  (defvar hcps/leader-map (make-sparse-keymap)
    "Keymap for all my leader bindings.")
  :general
  (:keymaps 'override
   (concat "M-" hcps/leader-key) '(:wk "leader" :keymap hcps/leader-map :package general))
  (:keymaps 'special-mode-map
   hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  :config
  (general-unbind 'global-map
    hcps/leader-key))
#+end_src

*** =delight=                                                    :modeline:

And we'll use =delight= to hide minor-modes names and such.

#+begin_src emacs-lisp :tangle yes
(use-package delight
  :commands delight
  :delight
  (auto-fill-function " af")
  (eldoc-mode " eldoc")
  (editorconfig-mode)
  (flymake-mode " flymk" flymake)
  (visual-line-mode " vl")
  (abbrev-mode))
#+end_src

*** =no-littering=                                               :cleaning:

=no-littering= will help us by setting sane paths to all cache and
history files the packages might set.

#+begin_src emacs-lisp :tangle yes
(use-package no-littering
  :demand)
#+end_src

*** =hide-mode-line=                                             :modeline:

Made by the doom-emacs guy. Yeah I know I could just write a function
for this, but eh.

#+begin_src emacs-lisp :tangle yes
(use-package hide-mode-line
  :defer t
  :commands hide-mode-line-mode)
#+end_src

** Built-in

The ones that /really/ don't require =use-package :ensure=.

- [ ] bookmark
- [ ] dired
- [ ] hippie-expand
- [ ] eshell
- [ ] save-place
- [X] ibuffer

*** =package=                                                     :package:

Same as above but with keybindings and =package-initialize=.

#+begin_src emacs-lisp :tangle yes
(use-package package
  :defer t
  :ensure nil
  :custom
  (package-archives
   '(("melpa" . "https://melpa.org/packages/")
     ("org" . "https://orgmode.org/elpa/")
     ("gnu" . "https://elpa.gnu.org/packages/")))
  :general
  (:keymaps 'hcps/leader-map
   "p l" 'package-list-packages
   "p d" 'package-delete
   "p i" 'package-install
   "p r" 'package-reinstall)
  :config
  (package-initialize)
  (require 'counsel))
#+end_src

*** =whitespace=                                               :faces:fill:

Let's monitor ourselves with =whitespace=.

#+begin_src emacs-lisp :tangle yes
(use-package whitespace
  :defer t
  :ensure nil
  :commands (whitespace-mode whitespace-cleanup delete-trailing-whitespace)
  :hook
  ((before-save-hook . whitespace-cleanup)
   (before-save-hook . delete-trailing-whitespace)
   (text-mode-hook . whitespace-mode)
   (prog-mode-hook . whitespace-mode))
  :custom
  (whitespace-line-column 85)
  (whitespace-style '(face tabs empty trailing lines-tail)))
#+end_src

*** =compile=                                           :error:naviagation:

This compilation helper mode facilitates the navigation of error outputs
on compilations.

#+begin_src emacs-lisp :tangle yes
(use-package compile
  :defer t
  :ensure nil
  :commands compile-mode
  :custom
  (compilation-ask-about-save nil)
  (compilation-always-kill t)
  (compilation-scroll-output 'first-error)
  (compilation-finish-functions (lambda (buffer &rest _) (delete-windows-on buffer 0))))
#+end_src

*** =tramp=                                                        :remote:

=tramp= is very useful when it comes to editing remote files and to
editing as super-user.

#+begin_src emacs-lisp :tangle yes
(use-package tramp
  :defer t
  :ensure nil
  :custom
  (tramp-default-method "ssh")
  (tramp-terminal-type "xterm-mono"))
#+end_src

*** =ssh=                                                          :remote:

Here's a small package that allows remotely opening sessions.

#+begin_src emacs-lisp :tangle yes
(use-package ssh
  :defer t
  :after shell
  :ensure nil
  :preface
  (defcustom ssh-remote-user-server nil
    "Dummy variable that holds a server name."
    :type 'string
    :safe #'stringp
    :group 'ssh)
  (defun hcps/get-user-server ()
    "Call to set and print the user server."
    (interactive)
    (if (equal ssh-remote-user-server nil)
        (setq ssh-remote-user-server
              (read-from-minibuffer "What server to store: ")))
    (concat "/ssh:" ssh-remote-user-server ":"))
  (defun hcps/store-user-remote ()
    "Store a server name to the desired target."
    (interactive)
    (let* ((read-server (read-from-minibuffer
                         (format "What server to store (current: %s): " ssh-remote-user-server)))
           (server-to-connect (if (equal read-server "") ssh-remote-user-server read-server)))
      (setq ssh-remote-user-server server-to-connect)))
  :custom
  (shell-command-dont-erase-buffer t)
  (ssh-directory-tracking-mode t)
  :config
  (shell-dirtrack-mode t))
#+end_src

*** =ansi-color=                                                :highlight:

To have pretty colors on ansi output.

#+begin_src emacs-lisp :tangle yes
(use-package ansi-color
  :defer t
  :ensure nil
  :commands
  (ansi-color-for-comint-mode-on ansi-color-filter-apply ansi-color-process-output)
  :hook
  ((shell-mode-hook . ansi-color-for-comint-mode-on)
   (eshell-preoutput-filter-functions . ansi-color-filter-apply)
   (comint-output-filter-functions . ansi-color-process-output)))
#+end_src

*** =windmove=                                                    :windows:

A package that creates commands to move around windows.

#+begin_src emacs-lisp :tangle yes
(use-package windmove
  :defer t
  :ensure nil
  :general
  ("C-M-h" 'windmove-left
   "C-M-l" 'windmove-right
   "C-M-k" 'windmove-up
   "C-M-j" 'windmove-down))
#+end_src

*** =midnight=                                           :buffers:cleaning:

Originally, =midnight= is used to /run something at midnight/. I use its
feature that kills old buffers.

#+begin_src emacs-lisp :tangle yes
(use-package midnight
  :defer 60
  :ensure nil
  :custom
  (clean-buffer-list-delay-general (/ 1 12))
  (clean-buffer-list-delay-special (* 1 3600))
  (clean-buffer-list-kill-buffer-names
   '("*Help*" "*Apropos*" "*Buffer List*" "*Compile-Log*" "*info*" "*vc*"
     "*vc-diff*" "*diff*" "*IBuffer*" "*Finder*")))
#+end_src

*** =uniquify=                                                    :buffers:

=uniquify= creates automatic meaningful names for buffers with the same
name:

#+begin_src emacs-lisp :tangle yes
(use-package uniquify
  :ensure nil
  :custom
  (uniquify-buffer-name-style 'post-forward)
  (uniquify-separator ":")
  (uniquify-after-kill-buffer-p t)
  (uniquify-ignore-buffers-re "^[*[:space:]]"))
#+end_src

*** =recentf=                                                       :files:

Keep a list of recent files with =recentf=

#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :ensure nil
  :commands recentf-open-files
  :hook
  (kill-emacs-hook . recentf-cleanup)
  :custom
  (recentf-save-file (expand-file-name "recentf-save.el" var-user-dir))
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 300)
  (recentf-exclude
   `(file-remote-p
     "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
     "^/tmp/"
     "^/ssh:"
     "\\.?ido\\.last$"
     "\\.revive$"
     "/TAGS$"
     ,var-user-dir
     ,package-user-dir
     ,(expand-file-name "savefile" root-dir)))
  (recentf-auto-cleanup 'never)
  :config
  (recentf-mode +1))
#+end_src

*** =ibuffer=                                                     :buffers:

Way better than the default one (and is built-in!)

#+begin_src emacs-lisp :tangle yes
(use-package ibuffer
  :ensure nil
  :hook
  (ibuffer-mode-hook . hcps/clean-mode-line)
  :general
  (:keymaps 'ibuffer-mode-map
   "q" 'kill-this-buffer
   "j" 'ibuffer-forward-line
   "k" 'ibuffer-backward-line
   "K" 'ibuffer-do-kill-lines
   "J" 'ibuffer-jump-to-buffer
   hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  (:keymaps 'hcps/leader-map
   "C-b" 'ibuffer)
  (:keymaps 'override
   "C-x C-b" 'ibuffer)
  :config
  (evil-set-initial-state 'ibuffer-mode 'emacs))
#+end_src

** Extension

The ones from MELPA and ELPA and whatever.

- [ ] vterm

*** =evil=                                                    :keybindings:

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs
text editing keybindings to match the modal edit modes of vi and vim.
Yes, you can have the best of both worlds!

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :commands evil-set-initial-state
  :preface
  (defun hcps/shift-left-region ()
    "Shift left and restore visual selection."
    (interactive)
    (evil-shift-left (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  (defun hcps/shift-right-region ()
    "Shift right and restore visual selection."
    (interactive)
    (evil-shift-right (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  (defun dzop/evil-org-insert-state-in-edit-buffer (fun &rest args)
    "Bind `evil-default-state' to `insert' before calling FUN with ARGS."
    (let ((evil-default-state 'insert)
          ;; Force insert state
          evil-emacs-state-modes
          evil-normal-state-modes
          evil-motion-state-modes
          evil-visual-state-modes
          evil-operator-state-modes
          evil-replace-state-modes)
      (apply fun args)
      (evil-refresh-cursor)))
  (defun hcps/hide-evil-tag ()
    "Some buffers don't need it."
    (setq-local evil-normal-state-tag nil)
    (setq-local evil-emacs-state-tag nil)
    (setq-local evil-insert-state-tag nil)
    (setq-local evil-replace-state-tag nil)
    (setq-local evil-motion-state-tag nil)
    (setq-local evil-visual-state-tag nil)
    (setq-local evil-operator-state-tag nil))
  :init
  (setq evil-want-keybinding nil)
  (advice-add 'org-babel-do-key-sequence-in-edit-buffer
              :around #'dzop/evil-org-insert-state-in-edit-buffer)
  (hcps/hook-require-once pre-command-hook evil)
  :general
  (:states '(normal visual)
   hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  (:states 'insert
   "<up>" 'previous-line
   "<down>" 'next-line
   "<left>" 'left-char
   "<right>" 'right-char
   "<tab>" 'indent-for-tab-command
   "<return>" 'evil-ret-and-indent)
  (:states 'visual
   ">" 'hcps/shift-right-region
   "<" 'hcps/shift-left-region)
  :custom
  (evil-esc-delay 0)
  (evil-shift-width 2)
  (evil-auto-indent t)
  (evil-want-fine-undo t)
  (evil-search-wrap t)
  (evil-regexp-search t)
  (evil-search-module 'isearch)
  (evil-echo-state nil)
  (evil-want-C-u-scroll t)
  (evil-want-C-d-scroll t)
  (evil-want-Y-yank-to-eol t)
  (evil-respect-visual-line-mode t)
  (evil-emacs-state-cursor  '("red" box))
  (evil-normal-state-cursor '("gray" box))
  (evil-visual-state-cursor '("gray" hollow))
  (evil-insert-state-cursor '("gray" bar))
  (evil-motion-state-cursor '("gray" hbar))
  (evil-operator-state-cursor '("gray" evil-half-cursor))
  (evil-mode-line-format '(before . mode-line-front-space))
  (evil-normal-state-tag   (propertize "   NORMAL   " 'face '((:background "DarkGoldenrod2" :foreground "black"))))
  (evil-emacs-state-tag    (propertize "   EMACS    " 'face '((:background "SkyBlue2"       :foreground "black"))))
  (evil-insert-state-tag   (propertize "   INSERT   " 'face '((:background "chartreuse3"    :foreground "black"))))
  (evil-replace-state-tag  (propertize "  REPLACE   " 'face '((:background "chocolate"      :foreground "black"))))
  (evil-motion-state-tag   (propertize "   MOTION   " 'face '((:background "plum3"          :foreground "black"))))
  (evil-visual-state-tag   (propertize "   VISUAL   " 'face '((:background "gray"           :foreground "black"))))
  (evil-operator-state-tag (propertize "  OPERATOR  " 'face '((:background "sandy brown"    :foreground "black"))))
  :config
  (evil-mode +1))
#+end_src

**** Cursors

Here we have both =evil-matchit=, which allows you to jump between tags
automatically,

#+begin_src emacs-lisp :tangle yes
(use-package evil-matchit
  :after evil
  :custom
  (evilmi-may-jump-by-percentage nil)
  :config
  (global-evil-matchit-mode +1))
#+end_src

and =evil-mc= implements the =multiple-cursors= functionality to
=evil-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package evil-mc
  :after evil
  :delight
  :general
  (:states 'visual
   "A" 'evil-mc-make-cursor-in-visual-selection-end
   "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  (:keymaps 'hcps/leader-map
   "ESC" 'evil-mc-undo-all-cursors)
  :config
  (global-evil-mc-mode +1))
#+end_src

**** Pairs

On pairs (and regions really) we have =evil-smartparens=, to use better
bindings to =smartparens=,

#+begin_src emacs-lisp :tangle yes
(use-package evil-smartparens
  :after evil
  :delight
  :hook
  (smartparens-enabled-hook . evil-smartparens-mode))
#+end_src

and =evil-surround=, which is a port of =surround= from vim and allow
you to quickly delete or change surrounding ="= and ='= from words or
paragraphs or whatever, as it integrates with vim's verb way of
expressing actions.

#+begin_src emacs-lisp :tangle yes
(use-package evil-surround
  :after evil
  :commands
  (evil-surround-edit
   evil-Surround-edit
   evil-surround-region
   evil-Surround-region)
  :preface
  (defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))
  :general
  (:states 'operator
   "s" 'evil-surround-edit
   "S" 'evil-Surround-edit)
  (:states 'visual
   "S" 'evil-surround-region
   "gS" 'evil-Surround-region)
  :config
  (define-and-bind-quoted-text-object "slash" "/" "/" "/")
  (define-and-bind-quoted-text-object "asterisk" "*" "*" "*")
  (global-evil-surround-mode +1))
#+end_src

**** Utilities

As it gets impossible to not use vim keybindings everywhere,
=evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages,

#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :config
  (setq evil-collection-mode-list (remq 'ibuffer evil-collection-mode-list))
  (evil-collection-init))
#+end_src

and also =evil-numbers=, to have nice keybindings to increase or
decrease numbers.

#+begin_src emacs-lisp :tangle yes
(use-package evil-numbers
  :after evil
  :general
  (:states 'normal
   "C-a" 'evil-numbers/inc-at-pt
   "C-S-a" 'evil-numbers/dec-at-pt))
#+end_src

*** =smart-mode-line=                                            :modeline:

I use =smart-mode-line= as it is very minimalist and informative (and it
looks very pretty on =gruvbox=).

#+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :preface
  :custom
  (sml/size-indication-format " %I ")
  (sml/line-number-format "%4l")
  (sml/use-projectile-p nil)
  (sml/shorten-directory nil)
  (sml/shorten-modes t)
  (sml/mode-width 'right)
  (sml/name-width 40)
  (sml/theme 'respectful)
  (sml/no-confirm-load-theme t)
  (sml/replacer-regexp-list
   '(("^~/\\.emacs\\.d/elpa/" ":ELPA:")
     ("^~/\\.emacs\\.d/" ":ED:")
     ("^/sudo:.*:" ":SU:")
     ("^~/Documents/" ":DOC:")
     ("^~/Repositories/" ":GIT:")
     ("^~/OneDrive/CIC/" ":UNI:")
     ("^~/OneDrive/" ":OD:")))
  :config
  (sml/setup))
#+end_src

*** =ivy=                                                      :completion:

=ivy= is like =ido= but better, I guess. It does fuzzy matching of
searches to open files and such. =flx= is required here in order to have
fuzzy matching and whatnot.

#+begin_src emacs-lisp :tangle yes
(use-package ivy
  :ensure flx
  :delight
  :preface
  (defun hcps/ivy-open-current-typed-path ()
    (interactive)
    (when ivy--directory
      (let* ((dir ivy--directory)
             (text-typed ivy-text)
             (path (concat dir text-typed)))
        (delete-minibuffer-contents)
        (ivy--done path))))
  :custom
  (ivy-count-format "(%d/%d) ")
  (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
  (ivy-height 9)
  (ivy-extra-directories nil)
  (ivy-wrap t)
  (ivy-do-completion-in-region t)
  (ivy-action-wrap t)
  (ivy-initial-inputs-alist nil)
  (ivy-display-functions-alist nil)
  (ivy-format-functions-alist '((t . ivy-format-function-line)))
  :custom-face
  (ivy-current-match ((t :inherit hl-line :bold t :underline nil)))
  :general
  (:keymaps 'ivy-minibuffer-map
   "RET" 'ivy-alt-done
   "C-f" 'hcps/ivy-open-current-typed-path
   "C-l" 'ivy-next-line
   "C-h" 'ivy-previous-line)
  :config
  (require 'flx)
  (ivy-mode +1))
#+end_src

and =ivy-rich= to have a better looking =ivy=

#+begin_src emacs-lisp :tangle yes
(use-package ivy-rich
  :after ivy
  :config
  (ivy-rich-mode +1))
#+end_src

*** =counsel=                                        :enhancement:commands:

=counsel= uses =ivy= to find files and commands. =smex= is required here
to make sure that =counsel-M-x= has decent candidate sorting.

#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :ensure smex
  :preface
  (defun hcps/override-yank-pop (&rest _)
    "Delete the region before inserting popped string."
    (when (and evil-mode (eq 'visual evil-state))
      (kill-region (region-beginning) (region-end))))
  :init
  (advice-add 'counsel-yank-pop :before #'hcps/override-yank-pop)
  :general
  (:keymaps 'hcps/leader-map
   ;; file stuff
   "f f" 'counsel-find-file
   "f r" 'counsel-recentf
   "f b" 'counsel-bookmark
   ;; package stuff
   "p p" 'counsel-package
   ;; other stuff
   "b" 'counsel-switch-buffer
   "y" 'counsel-yank-pop)
  (:keymaps '(global-map special-mode-map)
   [remap execute-extended-command] 'counsel-M-x
   [remap find-file] 'counsel-find-file
   [remap switch-buffer] 'counsel-switch-buffer)
  :custom
  (ivy-initial-inputs-alist nil)        ; here again as counsel resets it
  :config
  (require 'smex))
#+end_src

As you may know, in Emacs we use =tramp= to edit files remotely using
=ssh= and to edit local files as =root=. With the package
=counsel-tramp= we have an =counsel=-powered interface to use that
mechanism!

This package looks up your hosts defined in =~/.ssh/config= to generate
a list with possible =ssh= connections AND docker containers (thanks to
=docker-tramp=), along with =sudo= possibilities (including
=localhost=!).

#+begin_src emacs-lisp :tangle yes
(use-package counsel-tramp
  :defer t
  :ensure docker-tramp
  :general
  (:keymaps 'hcps/leader-map
   "f t" 'counsel-tramp))
#+end_src

*** =undo-tree=                                                   :history:

Undo and redo and kools with =undo-tree=!

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :defer t
  :delight
  :preface
  (defconst hcps/undo-tree-visualizer-diff t
    "My value for the `undo-tree-visualizer-diff' variable.")
  (defun reset-visualizer-diff (&rest args)
    "Because undo-tree-visualize sets the value of this variable to nil on quit."
    (setq undo-tree-visualizer-diff hcps/undo-tree-visualizer-diff))
  (defun wolfgang/clean-undo-tree ()
    "Clear current buffer's undo-tree."
    (interactive)
    (let ((buff (current-buffer)))
      (if (local-variable-p 'buffer-undo-tree)
          (if (y-or-n-p "Clear buffer-undo-tree? ")
              (progn
                (setq buffer-undo-tree nil)
                (message "Cleared undo-tree of buffer: %s" (buffer-name buff)))
            (message "Cancelled clearing undo-tree of buffer: %s" (buffer-name buff)))
        (error "Buffer %s has no local binding of `buffer-undo-tree'" (buffer-name buff)))))
  :hook
  ((after-init-hook . global-undo-tree-mode)
   (undo-tree-visualizer-mode-hook . hcps/clean-mode-line)
   (diff-mode-hook . hcps/hide-evil-tag))
  :init
  (advice-add 'undo-tree-visualize :before #'reset-visualizer-diff)
  :custom
  (undo-tree-visualizer-timestamps t)
  (undo-tree-enable-undo-in-region nil)
  (undo-tree-auto-save-history t)
  (undo-tree-history-directory-alist `((".*" . ,temporary-file-directory)))
  (undo-tree-visualizer-diff hcps/undo-tree-visualizer-diff)
  :general
  (:keymaps 'hcps/leader-map
   "u" 'undo-tree-visualize
   "U" 'wolfgang/clean-undo-tree))
#+end_src

*** =dashboard=                                           :buffers:initial:

There's some utility in having a cool initial screen actually. And
there's a cool extension that provides such functionality.

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
  :commands (dashboard-mode dashboard-insert-startupify-lists)
  :preface
  (defun hcps/open-dashboard ()
    (let ((buffer (switch-to-buffer "*dashboard*")))
      (dashboard-mode)
      buffer))
  (setq-default initial-buffer-choice #'hcps/open-dashboard)
  :general
  (:states '(normal visual)
   :keymaps 'dashboard-mode-map
   hcps/leader-key nil)
  :custom
  (dashboard-banner-logo-title (format "Welcome to Emacs, %s!" current-user))
  (dashboard-set-heading-icons nil)
  (dashboard-set-file-icons nil)
  (dashboard-center-content t)
  (dashboard-page-separator "\n\n\n")
  (dashboard-startup-banner 'logo)
  (dashboard-items '((recents  . 10)
                     (bookmarks . 5)))
  :config
  (dashboard-setup-startup-hook))
#+end_src

*** =treemacs=                                           :files:navigation:

While I've somewhat used =neotree.el=, I believe that =treemacs= is
turning out to be a better option, as it offers a bunch of extra
integrating packages and is overall more popular than the former.

#+begin_src emacs-lisp :tangle yes
(use-package treemacs
  :defer t
  :ensure treemacs-evil
  :ensure treemacs-projectile
  :preface
  (defun turn-off-cursor ()
    "It is kinda unnecessary while inside treemacs."
    (internal-show-cursor nil nil))
  :hook
  ((treemacs-mode-hook . hide-mode-line-mode)
   (treemacs-select-hook . turn-off-cursor))
  :custom
  (treemacs-persist-file (expand-file-name "treemacs/persist.org" var-user-dir))
  (treemacs-display-in-side-window t)
  (treemacs-follow-after-init t)
  (treemacs-no-png-images t)
  (treemacs-sorting 'alphabetic-desc)
  (treemacs-width 25)
  :general
  ("M-0" 'treemacs-select-window
   "M-t" 'treemacs)
  (:keymaps 'hcps/leader-map
   "t" 'treemacs)
  (:states '(normal visual)
   :keymaps 'treemacs-mode-map
   "l" 'treemacs-RET-action
   "h" nil)
  :config
  (treemacs-follow-mode +1)
  (treemacs-filewatch-mode +1)
  (treemacs-fringe-indicator-mode -1))
#+end_src

*** =exec-path-from-shell=                                  :execute:paths:

To ensure that Emacs uses the same path and environment as =shell= uses,
I use =exec-path-from-shell=. That way commands that work on the =shell=
will certainly work on Emacs!

#+begin_src emacs-lisp :tangle yes
(setenv "SHELL" "/bin/bash")

(use-package exec-path-from-shell
  :disabled
  :custom
  (exec-path-from-shell-arguments '("-l"))
  (exec-path-from-shell-variables '("PATH" "MANPATH"))
  :init
  (setenv "SHELL" "/bin/bash")
  :config
  (exec-path-from-shell-initialize))
#+end_src

*** =anzu=                                                :jump:navigation:

Besides the =ISearch= from Emacs itself or the search function from
=evil=, I also like to use =anzu=.

#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :defer t
  :delight
  (isearch-mode)
  (anzu-mode)
  :preface
  (defun hcps/anzu-update-func (here total)
    (when anzu--state
      (let ((status (cl-case anzu--state
                      (search (format "(%d/%d) " here total))
                      (replace-query (format "(%d replaces) " total))
                      (replace (format "(%d/%d) " here total)))))
        (propertize status 'face 'anzu-mode-line))))
  :custom
  (anzu-cons-mode-line-p t)
  (anzu-mode-line-update-function #'hcps/anzu-update-func)
  :general
  (:keymaps 'hcps/leader-map
   "r SPC" 'anzu-replace-at-cursor-thing
   "r q" 'anzu-query-replace-regexp)
  :config
  (global-anzu-mode 1))
#+end_src

I use only the =anzu-replace-at-cursor-thing=, which is a very useful to
replace multiple occurrences of a word fast.

*** =deadgrep=                                               :files:search:

I enjoy using =ripgrep= to search for stuff using =grep= syntax without
the slowness of it. So, I use =deadgrep=!

#+begin_src emacs-lisp :tangle yes
(use-package deadgrep
  :defer t
  :after evil-collection
  :general
  (:keymaps 'hcps/leader-map
   "f g" 'deadgrep)
  :config
  (evil-collection-deadgrep-setup))
#+end_src

*** =link-hint=                                           :jump:navigation:

=link-hint= replicates the hinting mechanic from trydactil and such.

#+begin_src emacs-lisp :tangle yes
(use-package link-hint
  :defer t
  :custom
  (browse-url-browser-function 'browse-url-firefox)
  :general
  (:keymaps 'hcps/leader-map
   "h" 'link-hint-open-link))
#+end_src

*** =avy=                                                 :jump:navigation:

As I love some overkill, here's =avy=.

#+begin_src emacs-lisp :tangle yes
(use-package avy
  :defer t
  :after evil
  :custom
  (avy-styles-alist
   '((avy-goto-char-2 . post) (avy-goto-line . at-full)))
  (avy-background t)
  :general
  (:states '(normal visual)
   "s" 'avy-goto-char-2
   "S" 'avy-goto-line))
#+end_src

*** =which-key=                                        :helper:keybindings:

The package called =which-key= shows you possible completions to the
command you're typing in the mode-line.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :defer t
  :delight
  :init
  (hcps/hook-require-once pre-command-hook which-key)
  :custom
  (which-key-allow-evil-operators t)
  :config
  (which-key-mode +1))
#+end_src

*** =lsp-mode=                                                        :ide:

I imagine anyone knows what is LSP, but oh well. Basically, it is one of
the best features of other famous editors, such as Visual Studio Code.
By using =lsp-mode=, we'll be able to have it too!

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :defer t
  :commands (lsp lsp-mode)
  :delight
  (lsp-mode " lsp")
  :hook
  ((lsp-mode-hook . lsp-enable-which-key-integration)
   (lsp-managed-mode-hook . lsp-modeline-diagnostics-mode)
   (lsp-mode-hook . lsp-headerline-breadcrumb-mode))
  :custom
  (lsp-log-io t)
  (lsp-auto-guess-root t)
  (lsp-auto-configure t)
  (lsp-enable-completion-at-point t)
  (lsp-enable-snippet nil)
  (lsp-semantic-highlighting t)
  (lsp-diagnostics-modeline-scope :project)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "l" '(:wk "lsp-mode" :keymap lsp-command-map :package lsp-mode))
  :config
  (require 'projectile)
  (add-to-list 'lsp-language-id-configuration '(cuda-mode . "cuda"))
  (add-to-list 'lsp-language-id-configuration '(".*\\.cu$" . "cuda")))
#+end_src

This package does have an extra sister package: =lsp-ui=.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
  :after lsp-mode
  :custom
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-delay 2.0)
  (lsp-ui-sideline-enable t)
  (lsp-ui-sideline-delay 1)
  (lsp-ui-sideline-show-diagnostics t)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-sideline-show-code-actions nil)
  (lsp-ui-peek-enable nil))
#+end_src

*** =flycheck=                                                     :syntax:

=flycheck= provides a reliable source to syntax checking in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :disabled
  :demand
  :delight
  (flycheck-mode)
  :init
  (global-flycheck-mode)
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay 1.0)
  :config
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message) line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))
  (add-to-list 'flycheck-checkers 'proselint))
#+end_src

*** =highlight-numbers=                                  :syntax:highlight:

This highlights numbers in =prog-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-numbers
  :defer t
  :commands highlight-numbers-mode
  :hook
  (prog-mode-hook . highlight-numbers-mode))
#+end_src

*** =highlight-escape-sequences=                                :highlight:

And this is to highlight escape sequences in some common modes:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-escape-sequences
  :defer t
  :commands turn-on-hes-mode
  :preface
  (defconst hes-shell-escape-sequence-re "\\(\\\\[\"'\\bfnrtv]\\)"
    "Simple regex to match any common escaped character in sh-mode")
  :hook
  (prog-mode-hook . turn-on-hes-mode)
  :config
  (add-to-list 'hes-mode-alist `(sh-mode . ,hes-shell-escape-sequence-re)))
#+end_src

*** =flyspell=                                         :spelling:highlight:

Of course, =flyspell= corrects your writing!

#+begin_src emacs-lisp :tangle yes
(use-package flyspell
  :defer t
  :commands (flyspell-prog-mode flyspell-mode)
  :delight
  (flyspell-mode " flysp")
  (flyspell-prog-mode " flysp")
  :hook
  ((prog-mode-hook . flyspell-prog-mode)
   (text-mode-hook . flyspell-mode))
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra"))
  :general
  (:keymaps 'hcps/leader-map
   "m d" 'ispell-change-dictionary))
#+end_src

*** =diff-hl=                                                        :diff:

=diff-hl= to highlight any diffs!

#+begin_src emacs-lisp :tangle yes
(use-package diff-hl
  :defer t
  :commands (diff-hl-mode turn-on-diff-hl-mode diff-hl-magit-post-refresh))
#+end_src

*** =hydra=                                                   :keybindings:

=hydra= is a package that allows keybindings to be activated under the
pressing of a specific combination of keys. These will then be active as
long as only them are being pressed, as on the moment a key which isn't
part of the hydra is pressed the hydra is killed and the keybindings
deactivated.

#+begin_src emacs-lisp :tangle no
(use-package hydra
  :disabled
  :defer t
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :general
  ("C-c e" 'hydra-eyebrowse/body
   "C-c f" 'hydra-flycheck/body)
  :custom
  (hydra-default-hint nil))
#+end_src

**** Eyebrowse

#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'hydra
  (defhydra hydra-eyebrowse (:color blue)
    "
^
^Eyebrowse^         ^Do^                ^Switch^
^^^^^^
_q_ quit            _c_ create          _<_ previous
^^                  _k_ kill            _>_ next
^^                  _r_ rename          _e_ last
^^                  ^^                  _s_ switch
^^                  ^^                  ^^
"
    ("q" nil)
    ("<" eyebrowse-prev-window-config :color red)
    (">" eyebrowse-next-window-config :color red)
    ("c" eyebrowse-create-window-config)
    ("e" eyebrowse-last-window-config)
    ("k" eyebrowse-close-window-config :color red)
    ("r" eyebrowse-rename-window-config)
    ("s" eyebrowse-switch-to-window-config))

  (with-eval-after-load 'general
    (general-def '(global-map special-mode-map)
      "C-c e" 'hydra-eyebrowse/body)))
#+end_src

**** Flycheck

#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'hydra
  (defhydra hydra-flycheck (:color pink)
    "
^
^Flycheck^          ^Errors^            ^Checker^
^^^^^^
_q_ quit            _<_ previous        _?_ describe
_m_ manual          _>_ next            _d_ disable
_v_ verify setup    _f_ check           _s_ select
^^                  _l_ list            ^^
^^                  ^^                  ^^
"
    ("q" nil)
    ("<" flycheck-previous-error)
    (">" flycheck-next-error)
    ("?" flycheck-describe-checker :color blue)
    ("d" flycheck-disable-checker :color blue)
    ("f" flycheck-buffer)
    ("l" flycheck-list-errors :color blue)
    ("m" flycheck-manual :color blue)
    ("s" flycheck-select-checker :color blue)
    ("v" flycheck-verify-setup :color blue))

  (with-eval-after-load 'general
    (general-def '(global-map special-mode-map)
      "C-c f" 'hydra-flycheck/body)))
#+end_src

*** =ace-window=                                                  :windows:

=ace-window= creates labels so we can jump windows with precision:

#+begin_src emacs-lisp :tangle yes
(use-package ace-window
  :defer t
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :general
  (:keymaps 'hcps/leader-map
   "w o" 'ace-window))
#+end_src

*** =super-save=                                          :buffers:history:

=super-save= auto-saves buffers when you switch or close buffers or when
Emacs loses focus, etc.

#+begin_src emacs-lisp :tangle yes
(use-package super-save
  :defer t
  :delight
  :init
  (hcps/hook-require-once before-save-hook super-save)
  (hcps/hook-require-once focus-out-hook super-save)
  :custom
  (super-save-auto-save-when-idle t)
  (super-save-remote-files nil)
  (super-save-idle-duration 60)
  :config
  (add-to-list 'super-save-triggers 'ace-window)
  (super-save-mode +1))
#+end_src

*** =yasnippet=                                                  :snippets:

I use =yasnippet= to handle my snippet needs.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :defer t
  :delight
  (yas-minor-mode " yas")
  :commands yas-minor-mode
  :hook
  (html-mode-hook . yas-minor-mode)
  :init
  (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  :custom
  (yas-snippet-dirs `(,(expand-file-name "snippets" root-dir)))
  :config
  (general-def 'insert 'yas-minor-mode-map
    "<tab>" yas-maybe-expand)
  (yas-reload-all))
#+end_src

*** =vimish-fold=                                                 :folding:

Enables vim-like folding of regions.

#+begin_src emacs-lisp :tangle yes
(use-package vimish-fold
  :defer t
  :general
  (:keymaps 'vimish-fold-folded-keymap
   "C-<tab>" 'vimish-fold-unfold)
  (:keymaps 'vimish-fold-unfolded-keymap
   "C-<tab>" 'vimish-fold-refold)
  :custom
  (vimish-fold-header-width 79)
  :config
  (vimish-fold-global-mode 1))
#+end_src

*** =projectile=                                                  :project:

For project management in Emacs, there's no better choice than
=projectile=, which is widely loved by the community.

It supports project-wide commands and actions, like killing all project
buffers or searching the whole project and replacing something.

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :defer t
  :preface
  (defun hcps/projectile-custom-mode-line ()
    "Report project name and type in the modeline."
    (let ((project (projectile-project-name)))
      (unless (or (string-equal project "-") (string-empty-p project))
        projectile-mode-line-prefix)))
  :custom
  (projectile-completion-system 'ivy)
  (projectile-mode-line-prefix " proj")
  (projectile-mode-line-function #'hcps/projectile-custom-mode-line)
  (projectile-switch-project-action 'projectile-find-file)
  (projectile-find-dir-includes-top-level t)
  (projectile-enable-caching t)
  (projectile-indexing-method 'native)
  (projectile-project-root-files-top-down-recurring
   '(".projectile" "compile_commands.json" ".ccls" ".svn" "CVS" "Makefile"))
  (projectile-globally-ignored-file-suffixes
   '(".elc" ".pyc" ".o" "~"))
  (projectile-globally-ignored-files
   '(".DS_Store" "Icon" "TAGS" "__PYCACHE__"))
  (projectile-globally-ignored-directories
   '(".DS_Store" "__PYCACHE__" ".idea" ".ensime_cache"
     ".eunit" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs"
     ".tox" ".svn" ".stack-work"))
  :general
  ([remap compile] 'projectile-compile-project)
  (:keymaps '(global-map special-mode-map)
   "M-p" '(:keymap projectile-command-map :wk "projectile"))
  :config
  (require 'counsel)
  ;; clean dead projects when Emacs is idle
  (run-with-idle-timer 180 nil #'projectile-cleanup-known-projects))
#+end_src

And, as a further integration of =ivy= and =projectile=, there is a
package that makes actions such as =switch-project= to use =counsel='s
completion and ordering of results.

#+begin_src emacs-lisp :tangle yes
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+end_src

*** =magit=                                                    :versioning:

Obviously, any configuration file that says it deserves *any* respect
should feature =magit=, as it is, hands down, the best =git= front-end
in the visible universe, nay, in the whole multiverse.

#+begin_src emacs-lisp :tangle yes
(use-package magit
  :defer t
  :hook
  ((after-save-hook . magit-after-save-refresh-status)
   (magit-mode-hook . hcps/hide-evil-tag)
   (magit-file-mode-hook . diff-hl-mode)
   (magit-post-refresh-hook . diff-hl-magit-post-refresh))
  :preface
  ;; easy on-off for the following function
  (defcustom magit-push-protected-branch nil
    "When set, ask for confirmation before pushing to this branch (e.g. master)."
    :type 'string
    :safe #'stringp
    :group 'magit)
  ;; are you sure you wanna push to master?
  (defun magit-push--protected-branch (magit-push-fun &rest args)
    "Ask for confirmation before pushing a protected branch."
    (if (equal magit-push-protected-branch (magit-get-current-branch))
        ;; Arglist is (BRANCH TARGET ARGS)
        (if (yes-or-no-p (format "Push branch %s? " (magit-get-current-branch)))
            (apply magit-push-fun args)
          (error "Push aborted by user"))
      (apply magit-push-fun args)))
  :init
  (advice-add 'magit-push-current-to-pushremote :around #'magit-push--protected-branch)
  (advice-add 'magit-push-current-to-upstream :around #'magit-push--protected-branch)
  :custom
  (git-commit-major-mode 'text-mode)
  (magit-push-protected-branch "master")
  (magit-save-repository-buffers 'dontask)
  (magit-refs-show-commit-count 'all)
  (magit-log-buffer-file-locked t)
  (magit-revision-show-gravatars nil)
  (magit-bury-buffer-function 'magit-mode-quit-window)
  :general
  (:keymaps 'hcps/leader-map
   "g p" 'magit-list-repositories
   "g g" 'magit-status
   "g d" 'magit-dispatch
   "g f" 'magit-file-dispatch
   "g l" 'magit-log
   "g b" 'magit-blame)
  :config
  (evil-add-hjkl-bindings magit-log-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-diff-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-commit-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-branch-manager-mode-map 'emacs
    "K" 'magit-discard
    "L" 'magit-log)
  (evil-add-hjkl-bindings magit-status-mode-map 'emacs
    "K" 'magit-discard
    "l" 'magit-log
    "h" 'magit-diff-toggle-refine-hunk)
  (evil-set-initial-state 'git-commit-mode 'emacs))
#+end_src

*** =git-timemachine=                                          :versioning:

Also, =git-timemachine= is a beautiful way to walk through git history:

#+begin_src emacs-lisp :tangle yes
(use-package git-timemachine
  :after magit
  :hook
  (git-timemachine-mode-hook . evil-normalize-keymaps)
  :general
  (:states '(normal visual)
   :keymaps 'git-timemachine-mode-map
   "C-j" 'git-timemachine-show-next-revision
   "C-k" 'git-timemachine-show-previous-revision
   "q" 'git-timemachine-quit
   "w" 'git-timemachine-kill-abbreviated-revision
   "g" 'git-timemachine-show-nth-revision
   "c" 'git-timemachine-show-commit)
  (:keymaps 'hcps/leader-map
   "g t" 'git-timemachine)
  :config
  (evil-make-overriding-map git-timemachine-mode-map 'normal))
#+end_src

*** =expand-region=                                             :selection:

Increase region by semantic units. It tries to be smart about it and
adapt to the structure of the current major mode.

#+begin_src emacs-lisp :tangle yes
(use-package expand-region
  :defer t
  :general
  ("C-+" 'er/contract-region
   "C-=" 'er/expand-region))
#+end_src

*** =smartparens=                                             :parentheses:

When in need of smart pairing, look no further than =smartparens=!

#+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :defer t
  :delight (smartparens-mode " sp")
  :commands (smartparens-mode smartparens-strict-mode)
  :custom
  (sp-base-key-bindings 'paredit)
  (sp-autoskip-closing-pair 'always)
  (sp-hybrid-kill-entire-symbol nil)
  :config
  (require 'smartparens-config)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1))
#+end_src

*** =rainbow-delimiters=                                      :parentheses:

With that, =rainbow-delimiters= is a great match:

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :defer t
  :commands rainbow-delimiters-mode)
#+end_src

*** =beacon=                                                       :cursor:

This little add-on will highlight big cursor movements.

#+begin_src emacs-lisp :tangle yes
(use-package beacon
  :defer t
  :init
  (hcps/hook-require-once pre-command-hook beacon)
  :delight
  :config
  (beacon-mode +1))
#+end_src

*** =aggressive-indent=                                :syntax:indentation:

I use =aggressive-indent= to keep my code indented as I type.

#+begin_src emacs-lisp :tangle yes
(use-package aggressive-indent
  :defer t
  :commands aggressive-indent-mode
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+end_src

*** =highligh-indent-guides=                        :highlight:indentation:

Also =highligh-indent-guides= is very useful, as Emacs doesn't come with
it out of the box.

#+begin_src emacs-lisp :tangle yes
(use-package highlight-indent-guides
  :defer t
  :delight
  (highlight-indent-guides-mode)
  :commands
  (highlight-indent-guides-auto-set-faces highlight-indent-guides-mode)
  :preface
  (defun highlight-indent-guides-auto-set-faces-with-frame (frame)
    (with-selected-frame frame
      (highlight-indent-guides-auto-set-faces)))
  :custom
  (highlight-indent-guides-method 'bitmap)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-character ?|)
  (highlight-indent-guides-delay 0.05)
  (highlight-indent-guides-auto-odd-face-perc 5)
  (highlight-indent-guides-auto-even-face-perc 5)
  (highlight-indent-guides-auto-character-face-perc 10)
  :hook
  ((prog-mode-hook . highlight-indent-guides-mode)
   (after-make-frame-functions . highlight-indent-guides-auto-set-faces-with-frame)))
#+end_src

*** =helpful=                                                      :helper:

=helpful= is a package that is overall an improvement over the default
=help= windows.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :general
  (:keymaps '(global-map special-mode-map)
   [remap describe-function] 'helpful-callable
   [remap describe-variable] 'helpful-variable
   [remap describe-key] 'helpful-key
   "C-h F" 'helpful-function
   "C-h C" 'helpful-command
   "C-h M" 'helpful-macro)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :config
  (require 'counsel))
#+end_src

*** =engine-mode=                                                  :search:

=engine-mode= is a minor mode that allow you to easily make queries to
the web without leaving Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package engine-mode
  :defer t
  :config
  (engine-mode +1)
  ;; (defengine google
  ;;   "https://www.google.com/search?q="
  ;;   :keybinding "g")
  )
#+end_src

*** =openwith=                                               :files:helper:

=openwith= is a small and useful tool to set how you want to open your
files with Emacs. I use it to set the opener of pdfs in my Emacs, as
well to other diverse media files.

#+begin_src emacs-lisp :tangle yes
(use-package openwith
  :defer t
  :init
  (hcps/hook-require-once pre-command-hook openwith)
  :custom
  (openwith-associations
   '(("\\.pdf$" "zathura" (file))
     ("\\.jpe?g$" "sxiv" (file))
     ("\\.png$" "sxiv" (file))
     ("\\.svg$" "sxiv" (file))
     ("\\.jpeg$" "sxiv" (file))
     ("\\.bmp$" "sxiv" (file))
     ("\\.flac$" "mpv" (file))
     ("\\.mkv$" "mpv" (file))
     ("\\.mp3$" "mpv" (file))
     ("\\.mp4$" "mpv" (file))))
  (openwith-confirm-invocation nil)
  :config
  (openwith-mode +1))
#+end_src

*** =crux=                                              :enhancement:elisp:

Which stands for...

#+begin_quote
A Collection of Ridiculously Useful eXtensions for Emacs.
#+end_quote

... yeah.

#+begin_src emacs-lisp :tangle yes
(use-package crux
  :defer t
  :commands crux-with-region-or-buffer
  :init
  ;; supposedly get expanded at compile time
  ;; also don't need to be here, but where else should i put them?
  (crux-with-region-or-buffer indent-region)
  (crux-with-region-or-buffer eval-region)
  (crux-with-region-or-buffer untabify)
  :general
  (:keymaps 'hcps/leader-map
   ;; file stuff
   "f s" 'crux-sudo-edit
   "f m" 'crux-rename-buffer-and-file ;; for `move'
   "f d" 'crux-delete-buffer-and-file
   "f c" 'crux-find-user-custom-file
   "f n" 'crux-create-scratch-buffer
   "f i" 'crux-find-user-init-file))
#+end_src

*** =page-break-lines=                                          :highlight:

To make pretty page breaks in your Emacs buffers:

#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines
  :defer t
  :commands page-break-lines-mode
  :delight
  :hook
  ((prog-mode-hook . page-break-lines-mode)
   (text-mode-hook . page-break-lines-mode))
  :custom
  (page-break-lines-max-width (+ fill-column 10))
  (page-break-lines-char ?-)
  :custom-face
  (page-break-lines ((t :inherit font-lock-comment-face :bold nil :italic nil))))
#+end_src

*** =writeroom-mode=                                          :environment:

A nice writing environment for Emacs in a minor-mode.

#+begin_src emacs-lisp :tangle yes
(use-package writeroom-mode
  :defer t
  :ensure visual-fill-column
  :custom
  (writeroom-fullscreen-effect 'maximized)
  (writeroom-width (+ 3 fill-column))
  :general
  (:keymaps 'hcps/leader-map
   "v w" 'writeroom-mode))
#+end_src

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides
nice support for a lot of packages and is very pleasant for the eyes.

- [ ] Use [[https://gitlab.com/jjzmajic/ewal][this]].

#+begin_src emacs-lisp :tangle yes
(use-package gruvbox-theme
  :config
  (load-theme 'gruvbox-dark-medium t))
#+end_src

* File modes

Here I'll store any package load and configurations related to languages
and file types.

I still need to add packages relating to these languages:

- [ ] Scala
- [ ] Dot (using Graphviz)
- [ ] English (as in literal english)
- [ ] Coq (yes, I'm slowly turning into what I most hate (check the hrs config!))
- [ ] PKGBUILD
- [ ] Markdown
- [ ] prog-mode
- [ ] text-mode

** Org

=org-mode= is probably *the* killer mode and one of the main reasons as to
why anyone should try Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package org
  :defer t
  :ensure nil
  :ensure org-plus-contrib
  :mode ("\\.org$" . org-mode)
  :delight
  (org-indent-mode nil org-indent)
  :hook
  ((org-mode-hook . auto-fill-mode)
   (org-mode-hook . hes-mode)
   (org-mode-hook . yas-minor-mode)
   (org-mode-hook . eldoc-mode)
   (org-mode-hook . visual-line-mode)
   (org-mode-hook . (lambda () (whitespace-toggle-options 'lines-tail))))
  :custom
  (org-return-follows-link t)
  ;; the following used to be '(latex script entities)
  (org-highlight-latex-and-related nil)
  (org-hide-leading-stars t)
  (org-hide-emphasis-markers t)
  (org-support-shift-select nil)
  (org-link-descriptive t)
  (org-log-done 'note)
  (org-directory (expand-file-name "Org/" onedrive-user-dir))
  (org-cycle-emulate-tab 'exc-hl-bol)
  (org-use-property-inheritance nil)
  (org-attach-use-inheritance t)
  (org-attach-dir-relative t)
  (org-startup-indented t)
  ;; 10 pixels because default-font-width doesn't work with daemon mode
  (org-image-actual-width (round (* 10 fill-column 0.85)))
  (org-modules '(ol-w3m ol-bbdb ol-bibtex ol-docview ol-gnus
                        ol-info ol-irc ol-mhe ol-rmail ol-eww org-tempo
                        org-inlinetask))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   "t" 'org-todo ; mark a TODO item as DONE
   "$" 'org-end-of-line ; smarter behaviour on headlines etc.
   "0" 'org-beginning-of-line ; ditto
   "-" 'org-ctrl-c-minus ; change bullet style
   "<" 'org-metaleft ; outdent
   ">" 'org-metaright ; indent
   "C-i" 'org-toggle-inline-images
   "C-l" 'org-toggle-link-display
   "C-j" 'outline-next-visible-heading
   "C-k" 'outline-previous-visible-heading
   "C-S-k" 'outline-up-heading
   "<tab>" 'outline-toggle-children
   "<backtab>" 'org-global-cycle
   "<return>" 'org-open-at-point
   "<S-left>" nil
   "<S-right>" nil
   "<S-up>" nil
   "<S-down>" nil)
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "v n s" 'org-narrow-to-subtree
   "v n b" 'org-narrow-to-block
   "m o" 'counsel-org-goto
   "m t" 'org-set-tags-command
   "m s" 'org-match-sparse-tree
   "m a" 'org-attach)
  (:keymaps 'hcps/leader-map
   "o b" 'org-switchb)
  (:states 'insert
   :keymaps 'org-mode-map
   "<tab>" 'org-cycle)
  :config
  (add-to-list 'sml/replacer-regexp-list `(,(concat "^" org-directory) ":ORG:")))
#+end_src

*** Add-ons

Stuff that increases the capabilities of =org-mode=

**** =toc-org=

With it I also use =toc-org=, which is an useful way to automatically
maintain an updated table of contents of your =.org= file. [[https://github.com/snosov1/toc-org][Check it out!]]

#+begin_src emacs-lisp :tangle yes
(use-package toc-org
  :defer t
  :hook
  (org-mode-hook . toc-org-mode))
#+end_src

**** =org-ref=

[[https://github.com/jkitchin/org-ref][org-ref]] is the de-facto way to cite inside Emacs, as it supports
multiple export backends and such

#+begin_src emacs-lisp :tangle yes
(use-package org-ref
  :defer t
  :preface
  (defconst hcps/user-org-ref-path
    (expand-file-name "Documentos/Papers" onedrive-user-dir))
  :custom
  (org-ref-bibliography-notes (expand-file-name "notes.org" hcps/user-org-ref-path))
  (org-ref-default-bibliography `(,(expand-file-name "references.bib" hcps/user-org-ref-path)))
  (reftex-default-bibliography `(,(expand-file-name "references.bib" hcps/user-org-ref-path)))
  (org-ref-pdf-directory hcps/user-org-ref-path)
  (org-ref-completion-library 'org-ref-ivy-cite)
  (org-ref-insert-cite-function 'org-ref-ivy-insert-cite-link)
  (org-ref-insert-label-function 'org-ref-ivy-insert-label-link)
  (org-ref-insert-ref-function 'org-ref-ivy-insert-ref-link)
  (org-ref-show-broken-links nil)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "m r" 'org-ref-cite-hydra/body
   "m c" 'org-ref-insert-link)
  :config
  (require 'doi-utils))
#+end_src

**** =org-agenda=

The ultimate journaling tool of the ultimate note-taking tool.

#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :ensure nil
  :defer t
  :custom
  (org-agenda-files
   (directory-files-recursively (expand-file-name "Org/" onedrive-user-dir) "\\.org$"))
  (org-agenda-use-tag-inheritance t)
  (org-agenda-show-log t)
  :general
  (:keymaps 'hcps/leader-map
   "o a" 'org-agenda))
#+end_src

**** =org-journal=

=org-journal= is a powerful tool to journal your day.

#+begin_src emacs-lisp :tangle yes
(use-package org-journal
  :defer t
  :custom
  (org-journal-dir (format-time-string (expand-file-name "Org/Journal/%Y/" onedrive-user-dir)))
  (org-journal-file-type 'monthly)
  (org-journal-file-format "%Y%m")
  (org-journal-date-format "%e %b %Y (%A)")
  (org-journal-time-format "")
  :general
  (:keymaps 'hcps/leader-map
   "o j" 'org-journal-new-entry))
#+end_src

**** =org-capture=

It is built-in and it is beautiful.

#+begin_src emacs-lisp :tangle yes
(use-package org-capture
  :ensure nil
  :defer t
  :commands (org-capture org-capture-upgrade-templates)
  :preface
  (defconst org-main-notes-file (expand-file-name "Org/organizer.org" onedrive-user-dir)
    "File that I use to store notes before reviewing them.")
  :custom
  (org-default-notes-file org-main-notes-file)
  (org-capture-templates
   `(("t" "todo" entry (file ,org-main-notes-file)
      "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
     ("n" "note" entry (file ,org-main-notes-file)
      "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)))
  :general
  (:keymaps 'hcps/leader-map
   "o c" 'org-capture))
#+end_src

**** =org-refile=

Also built-in. Moves headings around FAST.

#+begin_src emacs-lisp :tangle yes
(use-package org-refile
  :ensure nil
  :defer t
  :custom
  (org-refile-use-outline-path t)
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-targets '((nil :maxlevel . 9)
                        (org-agenda-files :maxlevel . 9)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "m r" 'org-refile))
#+end_src

*** Export

Configurations relating all the numerous org exporters.

#+begin_src emacs-lisp :tangle yes
(use-package ox
  :after org
  :ensure nil
  :ensure htmlize
  :preface
  (defun org-export-output-file-name-modified (orig-fun extension &optional subtreep pub-dir)
    "Collect all generated files from an export in a neat folder."
    (unless pub-dir
      (setq pub-dir "org-exports")
      (unless (file-directory-p pub-dir)
        (make-directory pub-dir)))
    (apply orig-fun extension subtreep pub-dir nil))
  (defun org-export-disable-scroll-margin (fun &rest args)
    "Disable margin from active line so part of the export popup doesn't get hidden."
    (let ((scroll-margin 0))
      (apply fun args)))
  :init
  (advice-add 'org-export-output-file-name :around #'org-export-output-file-name-modified)
  (advice-add 'org-export-dispatch :around #'org-export-disable-scroll-margin)
  :custom
  (org-export-backends '(latex html ascii))
  (org-export-allow-bind-keywords t)
  (org-export-with-latex t)
  (org-export-babel-evaluate t)
  (org-export-in-background nil)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "m e" 'org-export-dispatch))
#+end_src

**** =ox-extra=

=ox-extra= defines a couple of cool extras, like =ignore-headlines=!

#+begin_src emacs-lisp :tangle yes
(use-package ox-extra
  :after ox
  :ensure nil
  :hook
  (org-export-filter-parse-tree-functions . org-export-ignore-headlines))
#+end_src

**** =ox-latex=

Configurations to the LaTeX org exporter.

#+begin_src emacs-lisp :tangle yes
(use-package ox-latex
  :after ox
  :ensure nil
  :custom
  (org-latex-image-default-width "1\\linewidth")
  (org-latex-packages-alist
   '(("cache=false,outputdir=org-exports" "minted")
     ("T1" "fontenc")
     ("utf8" "inputenx")
     ("" "placeins")))
  (org-latex-listings 'minted)
  (org-latex-minted-options
   '(("breaklines")
     ("breakafter" "d")
     ("linenos" "true")
     ("xleftmargin" "\\parindent")))
  (org-latex-pdf-process
   '("latexmk -pdflatex='pdflatex -shell-escape -interaction=nonstopmode' -f -pdf -outdir=%o %f"))
  :config
  (add-to-list 'org-latex-classes
               '("iiufrgs"
                 "\\documentclass{iiufrgs}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("newlfm"
                 "\\documentclass{newlfm}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
  (add-to-list 'org-latex-classes
               '("IEEEtran"
                 "\\documentclass{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

**** =ox-hugo=

To the oh-so-pretty Hugo markdown format!

#+begin_src emacs-lisp :tangle yes
(use-package ox-hugo
  :after ox)
#+end_src

**** =ox-twbs=

Twitter bootstrap htmls!

#+begin_src emacs-lisp :tangle yes
(use-package ox-twbs
  :after ox)
#+end_src

**** =ox-dnd=

Yeah. That's right.

I mean, it's basically a tool to interface with the D&D LaTeX class. Not
that nerdy, is it?

#+begin_src emacs-lisp :tangle yes
(use-package ox-dnd
  :after ox
  :ensure nil
  :load-path (lambda () (expand-file-name "emacs-org-dnd" vendor-user-dir)))
#+end_src

*** Babel

Now, some configurations relating org-babel and its magic source blocks.

#+begin_src emacs-lisp :tangle yes
(use-package ob
  :after org
  :ensure nil
  :delight
  (org-src-mode)
  :preface
  (defun org-babel-tangle-block ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-babel-tangle)))
  (defun org-babel-strip-ansi-codes (func &rest args)
    (let ((result (apply func args)))
      (unless (null result)
        (replace-regexp-in-string ansi-color-control-seq-regexp "" result))))
  (defun org-babel-region-strip-ansi-codes (func beg &rest args)
    "Remove all ansi-color codes from point (the end of the region) to `beg'."
    (while (re-search-forward ansi-color-control-seq-regexp beg t -1)
      (replace-match "" nil nil))
    (apply func beg args))
  :hook
  (org-babel-after-execute-hook . org-redisplay-inline-images)
  :init
  (advice-add 'org-trim :around #'org-babel-strip-ansi-codes)
  (advice-add 'org-no-properties :around #'org-babel-strip-ansi-codes)
  (advice-add 'org-element-normalize-string  :around #'org-babel-strip-ansi-codes)
  (advice-add 'org-babel-examplify-region :around #'org-babel-region-strip-ansi-codes)
  (advice-add 'org-string-nw-p :around #'org-babel-strip-ansi-codes)
  (advice-add 'org-element-interpret-data :around #'org-babel-strip-ansi-codes)
  :custom
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-src-preserve-indentation t)
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'split-window-below)
  (org-babel-default-header-args
   '((:session . "none")
     (:results . "value replace")
     (:exports . "code")
     (:cache . "none")
     (:noweb . "no")
     (:eval . "never-export")
     (:hlines . "no")
     (:tangle . "no")))
  (org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (python . t)
     (julia . t)
     (makefile . t)
     (R . t)
     (C . t)
     (ruby . t)
     (ditaa . t)
     (dot . t)
     (octave . t)
     (sqlite . t)
     (perl . t)
     (screen . t)
     (plantuml . t)
     (lilypond . t)
     (latex . t)
     (jupyter . t)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "m x" 'org-babel-execute-buffer
   "m z" 'org-babel-tangle-block
   "m Z" 'org-babel-tangle)
  (:keymaps 'org-mode-map
   "C-c SPC" 'org-edit-special)
  (:keymaps 'org-src-mode-map
   "C-c SPC" 'org-edit-src-exit))
#+end_src

**** =jupyter=

As a great way to run Python and Julia source blocks inside =org-mode=

#+begin_src emacs-lisp :tangle yes
(use-package jupyter
  :after ob
  :ensure zmq
  :ensure websocket
  :commands jupyter-org-interaction-mode
  :custom
  (org-babel-default-header-args:jupyter-julia
   '((:eval . "no-export")
     (:async . "yes")
     (:session . "*Julia*")
     (:results . "value")
     (:exports . "both")
     (:kernel . "julia-1.4")))
  (org-babel-default-header-args:jupyter-python
   '((:eval . "no-export")
     (:async . "yes")
     (:session . "*Python*")
     (:results . "value")
     (:exports . "both")
     (:kernel . "python3"))))
#+end_src

** C-like languages

Here I set some defaults I appreciate for =cc-mode= (the mode for all
c-like languages):

#+begin_src emacs-lisp :tangle yes
(use-package cc-mode
  :defer t
  :ensure nil
  :commands (c-mode awk-mode java-mode c++-mode)
  :mode
  (("\\.c$" . c-mode)
   ("\\.h$" . c-mode)
   ("\\.awk$" . awk-mode)
   ("\\.java$" . java-mode))
  :hook
  ((c-mode-common-hook . lsp)
   (c-mode-common-hook . rainbow-delimiters-mode)
   (c-mode-common-hook . smartparens-strict-mode))
  :custom
  (c-default-style
   '((java-mode . "java")
     (awk-mode . "awk")
     (other . "linux")))
  (c-basic-offset 4)
  (c-offsets-alist '((substatement-open . 0))))
#+end_src

As languages that are part of =cc-mode= are known to using a lot of
doxygen, here's a package that highlights it!

#+begin_src emacs-lisp :tangle yes
(use-package highlight-doxygen
  :defer t
  :hook
  (c-mode-common-hook . highlight-doxygen-mode))
#+end_src

*** C/C++

Better C++ font lock:

#+begin_src emacs-lisp :tangle yes
(use-package modern-cpp-font-lock
  :defer t
  :delight
  (modern-c++-font-lock-mode)
  :hook
  (c++-mode-hook . modern-c++-font-lock-mode))
#+end_src

In the department of code formatting, =clang-format= is a lovely tool
that can really be of great use while editing C and C++ code.

#+begin_src emacs-lisp :tangle yes
(use-package clang-format
  :defer t
  :preface
  (defun cc-format-on-save-hook ()
    (when c-buffer-is-cc-mode
      (clang-format-buffer)))
  :general
  (:states '(normal visual)
   :keymaps 'c-mode-base-map
   :prefix hcps/leader-key
   "i" 'clang-format-region)
  :custom
  (clang-format-style "webkit")
  :config
  (crux-with-region-or-buffer clang-format-region))
#+end_src

*** CUDA

Suporting CUDA syntax per-se is kinda easy, as it's a subset of C after
all. The thing is I want proper syntax highlighting for all those
special keywords and types that CUDA introduces. So, let's install
=cuda-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package cuda-mode
  :defer t
  :mode "\\.cu$"
  :commands cuda
  :hook
  (cuda-mode-hook . (lambda () (dolist (func c++-mode-hook nil) (funcall func))))
  :custom
  (cuda-font-lock-keywords 'cuda-font-lock-keywords-3))
#+end_src

It falls back on =c++-mode= by default, so we are safe here.

** R

For R you pretty much /need/ the =ess= package, i.e. /Emacs Speaks
Statistics/. It provides you with everything you need from R.

#+begin_src emacs-lisp :tangle yes
(use-package ess-r-mode
  :defer t
  :ensure nil
  :ensure ess
  :commands (R R-mode r-mode ess-r-mode ess-r-transcript-mode)
  :preface
  (defun hcps/insert-r-pipe ()
    "Lets us insert the magrittr piping operator %>% in R"
    (interactive)
    (just-one-space 1)
    (insert "%>%")
    (reindent-then-newline-and-indent))
  :hook
  ((ess-r-mode-hook . yas-minor-mode)
   (ess-r-mode-hook . aggressive-indent-mode)
   (ess-r-mode-hook . smartparens-strict-mode)
   (ess-r-mode-hook . eldoc-mode)
   (ess-r-mode-hook . lsp)
   (ess-r-mode-hook . rainbow-delimiters-mode))
  :general
  (:states 'insert
   :keymaps 'ess-r-mode-map
   "M-RET" 'hcps/insert-r-pipe
   "<tab>" 'ess-indent-or-complete)
  (:states '(normal visual)
   :keymaps 'ess-r-mode-map
   :prefix hcps/leader-key
   "m c"  'ess-eval-region-or-function-or-paragraph-and-step
   "m r"  'ess-eval-region)
  (:states 'normal
   :keymaps 'ess-r-mode-map
   :prefix hcps/leader-key
   "m e"  'Rd-mode-insert-skeleton
   "m f"  'Rd-font
   "m j"  'Rd-mode-insert-item
   "m n"  'ess-eval-line-visibly-and-step
   "m p"  'Rd-preview-help
   "m s"  'Rd-mode-insert-section
   "m v"  'ess-display-help-on-object
   "m w"  'ess-switch-process
   "m y"  'ess-switch-to-ESS
   "m z"  'ess-switch-to-end-of-ESS)
  :custom
  (ido-enable-flex-matching t)
  (ess-auto-width 'frame)
  (ess-style 'RStudio))
#+end_src

** Shell script

As for shell-scripting:

#+begin_src emacs-lisp :tangle yes
(use-package sh-script
  :defer t
  :ensure nil
  :commands shell-script-mode
  :mode ("\\.zsh$" . shell-script-mode)
  :preface
  (defconst more-sh-utilities
    '("addbib" "apropos" "ar" "at" "awk" "banner" "basename" "batch" "biff"
      "cal" "calendar" "cancel" "cat" "cb" "cc" "checkeq" "checknr" "chgrp"
      "chmod" "chown" "chroot" "clear" "cmp" "colcrt" "comm" "compress" "cp"
      "cpio" "cpp" "csh" "ctags" "cut" "date" "dbx" "dd" "deroff" "df" "diff"
      "dirname" "du" "e" "ed" "edit" "env" "eqn" "ex" "expand" "expr" "file"
      "find" "finger" "fmt" "fold" "ftp" "git" "gprof" "grep" "groups" "head"
      "hostname" "indent" "install" "join" "last" "ld" "leave" "less" "lex"
      "lint" "ln" "login" "look" "lookbib" "lorder" "lp" "lpq" "lpr" "lprm"
      "ls" "mail" "make" "man" "mesg" "mkdir" "mkfifo" "mkstr" "more" "mv"
      "neqn" "nice" "nm" "nroff" "od" "page" "passwd" "paste" "pgrep" "pkill"
      "pr" "prof" "ps" "ranlib" "rcp" "rev" "rlogin" "rm" "rmdir" "roffbib"
      "rsh" "rup" "ruptime" "rusers" "rwall" "rwho" "sccs" "script" "sed" "seq"
      "sh" "size" "sleep" "sort" "sortbib" "spell" "split" "strings" "strip"
      "stty" "su" "sudo" "tabs" "tac" "tail" "talk" "tar" "tbl" "tee" "telnet"
      "tftp" "time" "timeout" "touch" "tr" "troff" "tsort" "tty" "ul" "uname"
      "uncompress" "unexpand" "uniq" "units" "unlink" "uptime" "users" "uucp"
      "vacation" "vedit" "vi" "view" "w" "wall" "wc" "whatis" "whereis" "which"
      "who" "whoami" "write" "xargs" "xstr" "yacc" "yes" "zcat" "gawk" "curl"
      "ip")
    "A list of common shell commands to be fontified especially in `sh-mode'.")
  (defconst more-sh-builtins
    '("alias" "bg" "bind" "break" "builtin" "caller" "cd"
      "command" "compgen" "complete" "compopt" "continue" "declare" "dirs"
      "disown" "echo" "enable" "eval" "exec" "exit" "export" "false" "fc" "fg"
      "getopts" "hash" "help" "history" "jobs" "kill" "let" "local" "logout"
      "mapfile" "popd" "printf" "pushd" "pwd" "read" "readarray" "readonly"
      "return" "set" "shift" "shopt" "source" "suspend" "test" "times" "trap"
      "true" "type" "typeset" "ulimit" "umask" "unalias" "unset" "wait")
    "Actual list of common keywords and builtins in `sh-mode'.")
  (defconst prezto-files
    '(".zlogin" ".zlogin" ".zlogout" ".zpreztorc" ".zprofile" ".zshenv" ".zshrc")
    "Files that are too zsh-style files.")
  (defun zsh-prezto-files ()
    "Function to ease switching to zsh when dealing with a zsh file."
    (if (and buffer-file-name
             (member (file-name-nondirectory buffer-file-name) prezto-files))
        (sh-set-shell "zsh")))
  (defun sh--match-variables-in-quotes (limit)
    "Search for variables in double-quoted strings bounded by LIMIT."
    (with-syntax-table sh-mode-syntax-table
      (let (res)
        (while (and
                (setq res (re-search-forward
                           "[^\\]\\(\\$\\)\\({.+?}\\|\\<[a-zA-Z0-9_]+\\|[@*#!]\\)"
                           limit t))
                (not (eq (nth 3 (syntax-ppss)) ?\"))))
        res)))
  (defun sh--match-command-subst-in-quotes (limit)
    "Search for a command in double-quoted strings bounded by LIMIT."
    (with-syntax-table sh-mode-syntax-table
      (let (res)
        (while (and
                (setq res (re-search-forward
                           "[^\\]\\(\\$(.+?)\\|`.+?`\\)"
                           limit t))
                (not (eq (nth 3 (syntax-ppss)) ?\"))))
        res)))
  :hook
  ((sh-mode-hook . zsh-prezto-files)
   (sh-mode-hook . aggressive-indent-mode)
   (sh-mode-hook . smartparens-mode)
   (sh-mode-hook . rainbow-delimiters-mode))
  :config
  (font-lock-add-keywords
   'sh-mode `((sh--match-variables-in-quotes
               (1 'default prepend)
               (2 'font-lock-variable-name-face prepend))
              (sh--match-command-subst-in-quotes
               (1 'sh-quoted-exec prepend))
              ("[^\\]\\([|&]\\{1,2\\}\\|[0-9]?[<>]\\{1,3\\}&?[0-9-]?\\|;\\{1,2\\}\\)"
               (1 'font-lock-keyword-face append))
              ;; ("\\(?:^\\|;\\)[^(]*[^\\]\\()\\)"
              ;;  (1 'font-lock-keyword-face append))
              (,(concat
                 "\\(?:^\\|[$<>](\\|||\\|&&\\|[;|]\\)"
                 "[[:blank:]]*"
                 "\\(?:while\\|for\\|if\\)?"
                 "[[:blank:]]*"
                 "\\(?:[[:alpha:]_]+=\\(?:[\"'][[:ascii:]]*?[\"']\\|[^[:blank:];&|\\$()]*?\\)?[[:blank:]]*\\)*"
                 (regexp-opt (append more-sh-builtins more-sh-utilities) 'words))
               (1 'font-lock-builtin-face append)))))
#+end_src

For =shell= completion I use =bash-complete=, which auto completes several
=bash= functions.

#+begin_src emacs-lisp :tangle yes
(use-package bash-completion
  :defer t
  :hook
  (shell-dynamic-complete-functions . bash-completion-dynamic-complete)
  :custom
  (bash-completion-use-separate-processes t))
#+end_src

** Makefile

In Makefile files we have a special case: it /needs/ tabulators to work.
So, we'll set that up.

#+begin_src emacs-lisp :tangle yes
(use-package make-mode
  :defer t
  :ensure nil
  :commands makefile-mode
  :mode ("^[Mm]akefile$" . makefile-mode)
  :preface
  (defun makefile-mode-defaults ()
    "Turn on tabs only for make-mode."
    (whitespace-toggle-options '(tabs))
    (setq-local indent-tabs-mode t))
  :hook
  ((makefile-mode-hook . makefile-mode-defaults)
   (makefile-mode-hook . smartparens-strict-mode)
   (makefile-mode-hook . rainbow-delimiters-mode)))
#+end_src

** PlantUML

/PlantUML/ is a graph language that describes loads of different diagram
types, mainly focusing on /UML/, of course.

#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
  :defer t
  :mode "\\.plantuml$"
  :interpreter "plantuml")
#+end_src

** Lisp

Fix for the annoying keyword default indentation:

#+begin_src emacs-lisp :tangle yes
(use-package lisp-mode
  :defer t
  :ensure nil
  :mode
  (("\\.lsp$" . lisp-mode)
   ("\\.lisp$" . lisp-mode)
   ("\\.cl$" . lisp-mode))
  :preface
  (defun fuco1/lisp-indent-function (indent-point state)
    "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
,* `defun', meaning indent `defun'-style
  (this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
    (let ((normal-indent (current-column))
          (orig-point (point)))
      (goto-char (1+ (elt state 1)))
      (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
      (cond
       ;; car of form doesn't seem to be a symbol, or is a keyword
       ((and (elt state 2)
             (or (not (looking-at "\\sw\\|\\s_"))
                 (looking-at ":")))
        (if (not (> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp))
            (progn (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point)
                                       calculate-lisp-indent-last-sexp 0 t)))
        ;; Indent under the list or under the first sexp on the same
        ;; line as calculate-lisp-indent-last-sexp.  Note that first
        ;; thing on that line has to be complete sexp since we are
        ;; inside the innermost containing sexp.
        (backward-prefix-chars)
        (current-column))
       ((and (save-excursion
               (goto-char indent-point)
               (skip-syntax-forward " ")
               (not (looking-at ":")))
             (save-excursion
               (goto-char orig-point)
               (looking-at ":")))
        (save-excursion
          (goto-char (+ 2 (elt state 1)))
          (current-column)))
       (t
        (let ((function (buffer-substring (point)
                                          (progn (forward-sexp 1) (point))))
              method)
          (setq method (or (function-get (intern-soft function)
                                         'lisp-indent-function)
                           (get (intern-soft function) 'lisp-indent-hook)))
          (cond ((or (eq method 'defun)
                     (and (null method)
                          (> (length function) 3)
                          (string-match "\\`def" function)))
                 (lisp-indent-defform state indent-point))
                ((integerp method)
                 (lisp-indent-specform method state
                                       indent-point normal-indent))
                (method
                 (funcall method indent-point state))))))))
  :hook
  ((lisp-mode-hook . smartparens-strict-mode)
   (lisp-mode-hook . aggressive-indent-mode)
   (lisp-mode-hook . rainbow-delimiters-mode))
  :custom
  (lisp-indent-function #'fuco1/lisp-indent-function))
#+end_src

** Elisp

Emacs version!

#+begin_src emacs-lisp :tangle yes
(use-package elisp-mode
  :defer t
  :ensure nil
  :ensure elisp-slime-nav
  :commands emacs-lisp-mode
  :mode ("\\.el" . emacs-lisp-mode)
  :preface
  (defun recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (when (and (string-prefix-p user-emacs-directory (file-truename buffer-file-name))
               (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (emacs-lisp-byte-compile)))
  :hook
  ((after-save-hook . recompile-elc-on-save)
   (emacs-lisp-mode-hook . smartparens-strict-mode)
   (emacs-lisp-mode-hook . aggressive-indent-mode)
   (emacs-lisp-mode-hook . rainbow-delimiters-mode)
   (emacs-lisp-mode-hook . yas-minor-mode))
  :config
  ;; to have the macro definitions
  (require 'use-package))
#+end_src

** Python

#+begin_quote
Elpy is an Emacs package to bring powerful Python editing to Emacs. It
combines and configures a number of other packages, both written in
Emacs Lisp as well as Python.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package elpy
  :defer t
  :commands elpy-enable
  :hook
  (python-mode-hook . elpy-enable))
#+end_src

** CMake

As CMake is very simple, each word carries a load of meaning and
importance. This little mode colors them accordingly.

#+begin_src emacs-lisp :tangle yes
(use-package cmake-mode
  :defer t
  :ensure nil
  :ensure cmake-font-lock
  :load-path (lambda () (car (file-expand-wildcards "/usr/share/cmake-3.*/editors/emacs")))
  :mode
  (("^CMakeLists\\.txt$" . cmake-mode)
   ("\\.cmake" . cmake-mode))
  :init
  (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
  :hook
  ((cmake-mode-hook . smartparens-strict-mode)
   (cmake-mode-hook . rainbow-delimiters-mode)
   (cmake-mode-hook . cmake-font-lock-activate)))
#+end_src

** Dockerfile

=dockerfile-mode= adds support to syntax highlighting and to build the
image directly from the buffer using =C-c C-b=.

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :defer t
  :mode "Dockerfile$")
#+end_src

** GMPL

So I have syntax highlighting while editing GLPK files.

#+begin_src emacs-lisp :tangle yes
(use-package gmpl-mode
  :defer t
  :mode "\\.mod$")
#+end_src

** Julia

Packages to write Julia source code in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package julia-mode
  :defer t
  :ensure ess
  :mode
  ("\\.jl$" . julia-mode)
  :preface
  (defun hcps/insert-julia-pipe ()
    "Lets us insert the piping operator |> in Julia"
    (interactive)
    (just-one-space 1)
    (insert "|>")
    (reindent-then-newline-and-indent))
  :init
  (setq inferior-julia-program (hcps/s-trim-right (shell-command-to-string "which julia")))
  (defvaralias 'inferior-julia-program-name 'inferior-julia-program
    "Because jupyter still uses this symbol.")
  (advice-add 'julia :around (lambda (func &rest args) (set-buffer (apply func args))))
  :hook
  ((julia-mode-hook . lsp)
   (julia-mode-hook . smartparens-strict-mode)
   (julia-mode-hook . rainbow-delimiters-mode)
   (julia-mode-hook . aggressive-indent-mode))
  :general
  (:states 'insert
   :keymaps 'julia-mode-map
   "M-RET" 'hcps/insert-julia-pipe))
#+end_src

** LaTeX

Let's start with some basic =auctex= editing so it starts the way I want
(as theoretically it should come bundled with Emacs).

#+begin_src emacs-lisp :tangle yes
(use-package auctex
  :defer t
  :mode ("\\.tex$" . latex-mode)
  :hook
  ((latex-mode-hook . turn-on-reftex)
   (latex-mode-hook . auto-fill-mode)
   (latex-mode-hook . rainbow-delimiters-mode)
   (latex-mode-hook . smartparens-mode))
  :custom
  (TeX-auto-save t)
  (TeX-parse-self t)
  (TeX-save-query nil)
  (TeX-source-correlate-method 'synctex)
  (TeX-master nil)
  (reftex-plug-into-AUCTeX t)
  (reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")))
#+end_src

So, for my LaTeX config I'll mainly use =latexmk= as it's way simpler to
use.

#+begin_src emacs-lisp :tangle yes
(use-package auctex-latexmk
  :after auctex
  :custom
  (auctex-latexmk-inherit-TeX-PDF-mode t)
  :config
  (auctex-latexmk-setup))
#+end_src

The hook stuff is because all =TeX= get defined when the mode starts, so
we need to redefine them then.

** Meson

Syntax support for the Meson build system DSL (which is based from
Python).

#+begin_src emacs-lisp :tangle yes
(use-package meson-mode
  :defer t
  :commands meson
  :mode "^meson\\.build$"
  :hook
  (meson-mode-hook . (lambda () (run-hooks 'prog-mode-hook))))
#+end_src

** {bspwm,sxhkd}rc

Derives from =conf-mode[space]=. Got it from [[https://notabug.org/arkhan/emacs-bspwm][here]].

#+begin_src emacs-lisp :tangle yes
(use-package bspwm
  :defer t
  :ensure nil
  :commands bspwm-config-mode
  :load-path (lambda () (expand-file-name "bspwm-mode" vendor-user-dir))
  :mode
  ("^\\(?:sxhkd\\|bspwm\\)rc$" . bspwm-config-mode)
  :hook
  (bspwm-config-mode-hook . page-break-lines-mode))
#+end_src

** Configuration files

Just a little hook to start the desired =conf-mode= when we open these
files.

#+begin_src emacs-lisp :tangle yes
(use-package conf-mode
  :defer t
  :ensure nil
  :mode "\\.service$"
  :hook
  ((conf-mode-hook . (lambda () (run-hooks 'prog-mode-hook)))
   (conf-mode-hook . smartparens-strict-mode)))
#+end_src

** Rust

The newest greatest compiled language!

#+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :defer t
  :ensure cargo
  ;; :ensure flycheck-rust
  :hook
  ((rust-mode-hook . lsp)
   (rust-mode-hook . cargo-minor-mode)
   (rust-mode-hook . smartparens-strict-mode)
   (rust-mode-hook . rainbow-delimiters-mode))
  :custom
  (rust-format-on-save t)
  (rust-indent-method-chain t))
#+end_src

** Perl

Old language, still great for doing admin stuff in few lines.

#+begin_src emacs-lisp :tangle yes
(use-package cperl-mode
  :defer t
  :ensure nil
  :mode "\\.p[lm]$"
  :interpreter "perl"
  :preface
  :hook
  ((cperl-mode-hook . rainbow-delimiters-mode)
   (cperl-mode-hook . aggressive-indent-mode)
   (cperl-mode-hook . smartparens-mode)
   (cperl-mode-hook . lsp))
  :custom
  (cperl-auto-newline nil)
  (cperl-electric-parens-mark nil)
  (cperl-electric-parens nil)
  (cperl-electric-parens-string "")
  (cperl-electric-keywords nil)
  (cperl-electric-linefeed nil)
  (cperl-electric-lbrace-space nil)
  (cperl-message-electric-keyword nil)
  (cperl-indent-region-fix-constructs 1)
  (cperl-extra-newline-before-brace nil)
  (cperl-indent-level 4)
  (cperl-brace-offset 0)
  (cperl-continued-brace-offset -4)
  (cperl-label-offset -4)
  (cperl-continued-statement-offset 4)
  :general
  (:states '(normal visual)
   :keymaps 'cperl-mode-map
   :prefix hcps/leader-key
   "i" 'cperl-indent-region)
  (:keymaps 'cperl-mode-map
   "{" nil)
  :config
  (crux-with-region-or-buffer cperl-indent-region)
  (font-lock-add-keywords
   'cperl-mode `(("^#!\\/\\(?:\\w+\\/\\)*\\(\\w+\\)"
                  (1 'font-lock-keyword-face prepend)))))
#+end_src

* Post-init

Lets lower a bit our GC threshold:

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq gc-cons-threshold 16777216
        gc-cons-percentage 0.1))
#+end_src

And that's it!
