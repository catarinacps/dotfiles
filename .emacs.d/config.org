# -*- mode: org -*-
#+TITLE: My Emacs configuration file
#+AUTHOR: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br
#+INFOJS_OPT:

These configurations represent my preferred version of Emacs, one that uses
=evil-mode= everywhere it can and one that tries to be as minimalist as +I want+
possible.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]

* The editor

Everything related to Emacs as the editor and platform.

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen space.

#+BEGIN_SRC emacs-lisp :tangle yes
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(setq-default
 inhibit-startup-screen t
 initial-scratch-message ""
 initial-major-mode 'org-mode)
#+END_SRC

*** Font

I use the =Source Code Pro= font in every editor I can set that on. Here's their
[[https://github.com/adobe-fonts/source-code-pro][GitHub]].

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Source Code Pro-11")))
#+END_SRC

*** Text

Here's every other setting relating to text editing I can't categorize any
further.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 fill-column 80
 indent-tabs-mode nil
 tab-width 4
 line-spacing 0
 require-final-newline t
 x-stretch-cursor t
 cursor-in-non-selected-windows t)

(blinking-cursor-mode -1)
#+END_SRC

*** Mode-line

Here's everything related to the mode-line.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M")

(display-time-mode 1)
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

*** Line numbering and scrolling

I like the vim style of relative numbering of lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-line-numbers-type 'relative)

(global-display-line-numbers-mode)
#+END_SRC

And I also like the vim style of scrolling better.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 auto-window-vscroll nil
 scroll-step 1
 scroll-conservatively 10000
 scroll-margin 7)
#+END_SRC

*** =ssh= environment variables

This is necessary in order to Emacs grab the =ssh-agent= variables and, that
way, to =magit= work with =ssh= repos.

#+BEGIN_SRC emacs-lisp :tangle yes
(exec-path-from-shell-copy-env "SSH_AGENT_PID")
(exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
#+END_SRC

*** Randoms

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 ad-redefinition-action 'accept                  ; Silence warnings for redefinition
 confirm-kill-emacs 'yes-or-no-p                 ; Confirm before exiting Emacs
 help-window-select t                            ; Focus new help windows when opened
 select-enable-clipboard t                       ; Merge system's and Emacs' clipboard
 uniquify-buffer-name-style 'forward             ; Uniquify buffer names
 window-combination-resize t                     ; Resize windows proportionally
 ring-bell-function 'ignore)                     ; No bell ring

(fset 'yes-or-no-p 'y-or-n-p)                    ; Replace yes/no prompts with y/n
#+END_SRC

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides nice
support for a lot of packages and is very pleasant for the eyes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme
  :init
  (load-theme gruvbox-dark-soft t))
#+END_SRC

** Extensions

These are Emacs-behaviour related! In other words, these extend the capabilities
of Emacs as an editor, and do NOT add support to other languages or etc.

I still need to add:

- [X] ranger
- [X] neotree
- [X] smart-mode-line
- [ ] helpful
- [X] gruvbox
- [ ] sensible-defaults
- [X] minions
- [ ] dumb-jump
- [X] smex
- [X] ido and ido-vertical-mode
- [X] tramp
- [ ] avy
- [ ] autofill
- [ ] engine-mode
- [ ] no-littering
- [X] perspective
- [ ] evil-mc
- [X] evil-collection
- [ ] evil-escape
- [ ] evil-nerd-commenter
- [ ] evil-matchit
- [ ] minimap
- [ ] pdf-tools
- [ ] flycheck-pos-tip

Also, =Prelude= packages that I like and still need to add:

- [ ] smartparens
- [ ] which-key
- [ ] projectile
- [ ] magit
- [ ] flyspell
- [ ] undo-tree
- [ ] compile
- [ ] whitespace
- [ ] beacon
- [ ] switch-window
- [ ] rainbow-delimiters
- [ ] browse-kill-ring

*** Package loading

I use =use-package= to load my packages and to organize them neatly in this org
file. I plan to gradually rip everything I want from =prelude= and put it here
eventually, using =use-package=.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

Having that said, I too use =auto-compile= to always compile packages and to
have their newest version always.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC

*** File management

I use =ranger.el= to use a file explorer like =ranger= inside Emacs instead of
the default =dired=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ranger
  :config
  (setq ranger-cleanup-on-disable t))
#+END_SRC

Also, I like to use =neotree.el= to navigate my project files, which is a clone
from =neotree= from vim.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package neotree
  :bind
  ([f8] . 'neotree-toggle))
#+END_SRC

*** Mode line

I use =smart-mode-line= as it is very minimalist and informative.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smart-mode-line
  :init
  (sml/setup))
#+END_SRC

Also, =minions= is useful to not show those pesky minor-modes all the time.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minions
  :config
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  (minions-mode 1))
#+END_SRC

*** Keybindings

These packages change keybindings and the default editing modes of Emacs.

**** Evil

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs text
editing keybindings to match the modal edit modes of vi and vim.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-mode
  :config
  (evil-mode 1))
#+END_SRC

Also I use =evil-surround=, which is a port of =surround= from vim.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
  :after evil-mode
  :config
  (global-evil-surround-mode 1))
#+END_SRC

=evil-org= adds a lot of useful keybindings to =org-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :after org evil-mode
  :hook
  ((org-mode . evil-org-mode)
   (evil-org-mode . (lambda () (evil-org-set-key-theme))))
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+END_SRC

=evil-visualstar= enables searching visual selections with the =*= key.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-visualstar
  :after evil-mode)
#+END_SRC

The package =evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-collection
  :after evil-mode
  :config
  (setq evil-want-keybinding nil)
  (evil-collection-init))
#+END_SRC

**** Hydra

=hydra= is a package that allows keybindings to be activated under the pressing
of a specific combination of keys. These will then be active as long as only
them are being pressed, as on the moment a key which isn't part of the hydra is
pressed the hydra is killed and the keybindings deactivated.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :bind
  ("C-c e" . hydra-eyebrowse/body)
  ("C-c f" . hydra-flycheck/body)
  :config (setq-default hydra-default-hint nil))
#+END_SRC

***** Eyebrowse

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-eyebrowse (:color blue)
   "
 ^
 ^Eyebrowse^         ^Do^                ^Switch^
 ^─────────^─────────^──^────────────────^──────^────────────
 _q_ quit            _c_ create          _<_ previous
 ^^                  _k_ kill            _>_ next
 ^^                  _r_ rename          _e_ last
 ^^                  ^^                  _s_ switch
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" eyebrowse-prev-window-config :color red)
   (">" eyebrowse-next-window-config :color red)
   ("c" eyebrowse-create-window-config)
   ("e" eyebrowse-last-window-config)
   ("k" eyebrowse-close-window-config :color red)
   ("r" eyebrowse-rename-window-config)
   ("s" eyebrowse-switch-to-window-config))
 #+END_SRC

***** Flycheck

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-flycheck (:color pink)
   "
 ^
 ^Flycheck^          ^Errors^            ^Checker^
 ^────────^──────────^──────^────────────^───────^───────────
 _q_ quit            _<_ previous        _?_ describe
 _m_ manual          _>_ next            _d_ disable
 _v_ verify setup    _f_ check           _s_ select
 ^^                  _l_ list            ^^
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" flycheck-previous-error)
   (">" flycheck-next-error)
   ("?" flycheck-describe-checker :color blue)
   ("d" flycheck-disable-checker :color blue)
   ("f" flycheck-buffer)
   ("l" flycheck-list-errors :color blue)
   ("m" flycheck-manual :color blue)
   ("s" flycheck-select-checker :color blue)
   ("v" flycheck-verify-setup :color blue))
 #+END_SRC


*** Completion

This section comprises of both text completion and fuzzy command and path
completion.

**** Path and command

I use both =ido= and =smex= to complete my search and commands needs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ido
  :config
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1))
#+END_SRC

=ido-vertical-mode= helps to improve the readability of =ido='s suggestions.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ido-vertical-mode
  :config
  (ido-vertical-mode 1))
#+END_SRC

=smex= is the equivalent of =ido= but for [M-x].

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smex
  :bind
  ("M-x" . 'smex))
#+END_SRC

**** Text

I use =company= as my completion framework. In the words of Dmitry Gutov:

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :defer 1
  :bind
  (:map company-active-map
        ("RET" . nil)
        ([return] . nil)
        ("TAB" . company-complete-selection)
        ([tab] . company-complete-selection)
        ("<right>" . company-complete-common))
  :config
  (global-company-mode 1)
  (setq-default
   company-idle-delay .2
   company-minimum-prefix-length 1
   company-require-match nil
   company-tooltip-align-annotations t))
#+END_SRC

*** Remote editing

=tramp=, which is included by default in Emacs, is very useful when it comes to
editing remote files and to editing as super-user.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tramp
  :config
  (setq tramp-default-method "ssh"))
#+END_SRC

*** Buffers and windows

- *TODO*: make a hydra to change buffers like tabs (=h= goes to previous buffer,
  =l= to the next)

=windmove= is a package that creates commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  ((C-M-<left>. windmove-left)
   ("C-M-<right>". windmove-right)
   ("C-M-<up>". windmove-up)
   ("C-M-<down>". windmove-down)))
#+END_SRC

Originally, =midnight= is used to /run something at midnight/. I use its feature that
kills old buffers.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :ensure nil
  :config
  (setq-default clean-buffer-list-delay-general 1))
#+END_SRC

Also, I use perspective to maintain multiple workspaces open with different
buffers in each.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package perspective
  :init
  (persp-mode))
#+END_SRC

*** Templates and snippets

I use =YaSnippet= to handle my snippet needs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
        ("TAB" . nil)
        ("<tab>" . nil))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (python-mode . yas-minor-mode))
  :config
  (yas-reload-all))
#+END_SRC

*** Folding

Enables vim-like folding of regions.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :defer 1
  :bind
  (:map vimish-fold-folded-keymap ("<tab>" . vimish-fold-unfold)
   :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
  :init
  (setq-default vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory))
  (vimish-fold-global-mode 1)
  :config
  (setq-default vimish-fold-header-width 79))
#+END_SRC

*** Syntax Checking

=Flycheck= provides a reliable source to syntax checking in emacs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook
  ((css-mode . flycheck-mode)
   (emacs-lisp-mode . flycheck-mode)
   (js-mode . flycheck-mode)
   (python-mode . flycheck-mode))
  :config
  (setq-default
   flycheck-check-syntax-automatically '(save mode-enabled)
   flycheck-disabled-checkers '(emacs-lisp-checkdoc)
   flycheck-display-errors-delay .3))
#+END_SRC

*** Regions and pointers

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-+" . er/contract-region)
  ("C-=" . er/expand-region))
#+END_SRC

*** Indentation

I use =aggressive-indent= to keep my code indented as I type.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((emacs-lisp-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (org-mode . aggressive-indent-mode))
  :config
  (setq-default aggressive-indent-comments-too t)
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

*** Utilities

Random utilities that don't fit anywhere else.

* Languages

Here I'll store any package load and configurations related to languages.

I still need to add packages relating to these languages:

- [ ] C/C++
- [ ] Python
- [ ] Scala
- [ ] LaTeX

** org

=org-mode= is probably *the* killer mode and one of the main reasons as to why
anyone should try Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :config
  (setq-default
   org-return-follows-link t
   org-highlight-latex-and-related '(latex script entities)
   org-hide-leading-stars t
   org-directory "~/org/")
  :hook
  (org-mode . org-indent-mode))
#+END_SRC

I make extensive use of blocks of source code inside my org notes, something
Knuth goes to length about in "Literate Programming".

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-src
  :ensure nil
  :after org
  :config
  (setq-default
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-fontify-natively t
   org-src-tab-acts-natively t))
#+END_SRC

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff you
coded yourself.

To-do:

- [ ] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Functions

Some very useful functions I got from other people or that I coded myself.

*** Date

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC


** Keybindings

Here I'll define some of my personal keybindings.
