# -*- mode: org -*-
#+TITLE: My Emacs configuration file
#+AUTHOR: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br
#+INFOJS_OPT:

These configurations represent my preferred version of Emacs, one that uses
=evil= everywhere it can and one that tries to be as minimalist as +I want+
possible.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]

* Table of contents                                                   :TOC_3:
- [[#the-editor][The editor]]
  - [[#definitions-and-preferences][Definitions and preferences]]
    - [[#gui-elements][GUI elements]]
    - [[#font][Font]]
    - [[#text][Text]]
    - [[#mode-line][Mode-line]]
    - [[#line-numbering-and-scrolling][Line numbering and scrolling]]
    - [[#randoms][Randoms]]
  - [[#extensions][Extensions]]
    - [[#package-loading][Package loading]]
    - [[#file-management][File management]]
    - [[#environment][Environment]]
    - [[#find-and-replace][Find and replace]]
    - [[#mode-line-1][Mode line]]
    - [[#remote-editing][Remote editing]]
    - [[#completion][Completion]]
    - [[#keybindings][Keybindings]]
    - [[#buffers-and-windows][Buffers and windows]]
    - [[#scrolling][Scrolling]]
    - [[#templates-and-snippets][Templates and snippets]]
    - [[#folding][Folding]]
    - [[#syntax-checking][Syntax Checking]]
    - [[#project-management][Project management]]
    - [[#regions-and-pointers][Regions and pointers]]
    - [[#indentation][Indentation]]
    - [[#utilities][Utilities]]
  - [[#theme][Theme]]
- [[#languages][Languages]]
  - [[#org][org]]
- [[#personal][Personal]]
  - [[#functions][Functions]]
    - [[#date][Date]]
  - [[#keybindings-1][Keybindings]]

* The editor

Everything related to Emacs as the editor and platform.

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen space.

#+BEGIN_SRC emacs-lisp :tangle yes
(tool-bar-mode 0)
(menu-bar-mode 0)
(scroll-bar-mode 0)

(setq-default
 inhibit-startup-screen t
 initial-scratch-message ""
 initial-major-mode 'org-mode)
#+END_SRC

*** Font

I use the =Source Code Pro= font in every editor I can set that on. Here's their
[[https://github.com/adobe-fonts/source-code-pro][GitHub]].

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Source Code Pro-11")))
#+END_SRC

*** Text

Here's every other setting relating to text editing I can't categorize any
further.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 fill-column 80
 indent-tabs-mode nil
 tab-width 4
 line-spacing 0
 require-final-newline t
 x-stretch-cursor t
 cursor-in-non-selected-windows t)

(blink-cursor-mode 0)
#+END_SRC

Also, =auto-fill-mode= is very useful to justify paragraphs automatically while
writing.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

*** Mode-line

Here's everything related to the mode-line.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M"
              display-time-default-load-average nil)

(display-time-mode 1)
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

*** Line numbering and scrolling

I like the vim style of relative numbering of lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-line-numbers-type 'relative)

(global-display-line-numbers-mode)
#+END_SRC

And I also like the vim style of scrolling better.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 auto-window-vscroll nil
 scroll-step 1
 scroll-conservatively most-positive-fixnum
 scroll-margin 10)
#+END_SRC

*** Randoms

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
 ad-redefinition-action 'accept          ; Silence warnings for redefinition
 confirm-kill-emacs 'yes-or-no-p         ; Confirm before exiting Emacs
 help-window-select t                    ; Focus new help windows when opened
 select-enable-clipboard t               ; Merge system's and Emacs' clipboard
 uniquify-buffer-name-style 'forward     ; Uniquify buffer names
 window-combination-resize t             ; Resize windows proportionally
 ring-bell-function 'ignore)             ; No bell ring

; Replace yes/no prompts with y/n
(fset 'yes-or-no-p 'y-or-n-p)

; Set Emacs to call the garbage collector on focus-out
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Extensions

These are Emacs-behaviour related! In other words, these extend the capabilities
of Emacs as an editor, and do NOT add support to other languages or etc.

I still need to add:

- [X] ranger
- [X] neotree
- [X] smart-mode-line
- [X] helpful
- [X] gruvbox
- [X] minions
- [X] dumb-jump
- [X] smex
- [X] ivy and counsel
- [X] tramp
- [X] avy
- [X] autofill
- [X] engine-mode
- [X] no-littering
- [X] perspective
- [X] evil-mc
- [X] evil-collection
- [X] evil-nerd-commenter
- [X] evil-matchit
- [X] evil-leader
- [X] minimap
- [X] pdf-tools
- [X] flycheck-pos-tip
- [X] exec-path-from-shell
- [X] anzu

Also, =Prelude= packages that I like and still need to add:

- [ ] smartparens
- [ ] which-key
- [ ] projectile
- [ ] magit and additionals
- [ ] flyspell
- [ ] undo-tree
- [ ] compile
- [ ] whitespace
- [ ] beacon
- [ ] switch-window
- [ ] rainbow-delimiters
- [ ] browse-kill-ring

*** Package loading

I use =use-package= to load my packages and to organize them neatly in this org
file. I plan to gradually rip everything I want from =prelude= and put it here
eventually, using =use-package=.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

Having that said, I too use =auto-compile= to always compile packages and to
have their newest version always.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-compile
  :demand
  :init
  (setq load-prefer-newer t)
  :config
  (auto-compile-on-load-mode))
#+END_SRC

*** File management

I use =ranger.el= to use a file explorer like =ranger= inside Emacs instead of
the default =dired=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ranger
  :init
  (setq ranger-cleanup-on-disable t
        ranger-preview-file t
        ranger-dont-show-binary t
        ranger-max-preview-size 10)
  :config
  (ranger-override-dired-mode t))
#+END_SRC

Also, I like to use =neotree.el= to navigate my project files, which is a clone
from =neotree= from vim.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package neotree
  :bind
  ([f8] . neotree-toggle))
#+END_SRC

*** Environment

To ensure that Emacs uses the same path and environment as =shell= uses, I use
=exec-path-from-shell=. That way commands that work on the =shell= will
certainly work on Emacs!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if
  (memq window-system '(mac ns))
  :init
  (setq exec-path-from-shell-arguments '("-l"))
  :config
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-env "SSH_AGENT_PID")
  (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+END_SRC

*** Find and replace

Besides the =isearch= from Emacs itself or the search function from =evil=, I
also like to use =anzu=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package anzu
  :init
  (setq anzu-cons-mode-line nil)
  :config
  (global-anzu-mode 1))
#+END_SRC

I use only the =anzu-replace-at-cursor-thing=, which is a very useful to replace
multiple occurrences of a word fast.

*** Mode line

I use =smart-mode-line= as it is very minimalist and informative (and it looks
very pretty on =gruvbox=)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smart-mode-line
  :demand
  :config
  (sml/setup))
#+END_SRC

Also, =minions= is useful to not show those pesky minor-modes all the time. No
one wanna see what minor modes are active ALL of the time, right?

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minions
  :after smart-mode-line
  :init
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  :config
  (minions-mode 1))
#+END_SRC

*** Remote editing

=tramp=, which is included by default in Emacs, is very useful when it comes to
editing remote files and to editing as super-user.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tramp
  :demand
  :init
  (setq tramp-default-method "ssh"))
#+END_SRC

*** Completion

This section comprises of both text completion and fuzzy command and path
completion.

**** Path and command

=flx= helps =ivy= to sort its results better.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flx)
#+END_SRC

=ivy= is like =ido= but better, I guess. It does fuzzy matching of searches to
open files and such.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :after flx
  :demand
  :preface
  (defun hcps/ivy-open-current-typed-path ()
    (interactive)
    (when ivy--directory
      (let* ((dir ivy--directory)
             (text-typed ivy-text)
             (path (concat dir text-typed)))
        (delete-minibuffer-contents)
        (ivy--done path))))
  :init
  (setq ivy-use-virtual-buffers t
        ivy-count-format "(%d/%d) "
        ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
  :bind
  (("C-x b" . ivy-switch-buffer)
   :map ivy-minibuffer-map
   ("<return>" . ivy-alt-done)
   ("C-f" . hcps/ivy-open-current-typed-path))
  :config
  (ivy-mode 1))
#+END_SRC

=smex= helps =ivy= and =counsel= to get better candidate matching.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package smex)
#+END_SRC

=counsel= uses =ivy= to find files and commands.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel
  :after (ivy smex)
  :demand
  :bind
  (("M-x" . counsel-M-x)
   ("C-x C-f" . counsel-find-file)))
#+END_SRC

As you may know, in Emacs we use =tramp= to edit files remotely using =ssh= and
to edit local files as =root=. With the package =counsel-tramp= we have an
=counsel=-powered interface to use that mechanism!

This package looks up your servers defined in =~/.ssh/config= to generate a list
with possible =ssh= connections, along with =sudo= possibilities (including
=localhost=!).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-tramp
  :after counsel
  :bind
  ("C-c C-f" . counsel-tramp))
#+END_SRC

**** Text

I use =company= as my completion framework. In the words of Dmitry Gutov:

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :bind
  (:map company-active-map
        ("RET" . nil)
        ([return] . nil)
        ("TAB" . company-complete-selection)
        ([tab] . company-complete-selection)
        ("<right>" . company-complete-common))
  :init
  (setq company-idle-delay .2
        company-minimum-prefix-length 1
        company-require-match nil
        company-tooltip-align-annotations t)
  :config
  (global-company-mode 1))
#+END_SRC

*** Keybindings

These packages change keybindings and the default editing modes of Emacs.

**** Evil

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs text
editing keybindings to match the modal edit modes of vi and vim. Yes, you can
have the best of both worlds!

But! Before activating =evil=, I'll load up =evil-leader=, which is an package
that simplifies the setting of a leader key scheme alike to vim's leader key.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-leader
  :config
  (evil-leader/set-leader "<SPC>")
  (evil-leader/set-key
   "f" 'counsel-find-file
   "b" 'ivy-switch-buffer
   "k" 'kill-this-buffer
   "r" 'anzu-replace-at-cursor-thing
   "t" 'counsel-tramp)
  (global-evil-leader-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :after evil-leader
  :demand
  :init
  (setq evil-want-keybinding nil)
  :config
  (evil-mode 1))
#+END_SRC

Also I use =evil-surround=, which is a port of =surround= from vim and allow you
to quickly delete or change surrounding ="= and ='= from words or paragraphs or
whatever, as it integrates with vim's verb way of expressing actions.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+END_SRC

=evil-org= adds a lot of useful keybindings to =org-mode=. I'm still not aware
of how much this adds or how similar they are to =prelude='s keys to org on
=evil=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :after (org evil)
  :hook
  ((org-mode . evil-org-mode)
   (evil-org-mode . (lambda () (evil-org-set-key-theme)))))
#+END_SRC

Following the previous package, =evil-org-agenda= sets up cool =evil= keys to
=org-agenda=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org-agenda
  :after evil-org
  :config
  (evil-org-agenda-set-keys))
#+END_SRC

=evil-visualstar= enables searching visual selections with the =*= key.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-visualstar
  :after evil)
#+END_SRC

The package =evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

=evil-mc= implements the =multiple-cursors= functionality to =evil-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-mc
  :after evil
  :init
  (evil-define-key 'visual evil-mc-key-map
    "A" #'evil-mc-make-cursor-in-visual-selection-end
    "I" #'evil-mc-make-cursor-in-visual-selection-beg)
  :config
  (global-evil-mc-mode 1))
#+END_SRC

=evil-matchit= allows you to jump between tags automatically!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-matchit
  :after evil
  :init
  (setq evilmi-may-jump-by-percentage nil)
  :config
  (global-evil-matchit-mode 1))
#+END_SRC

=evil-nerd-commenter= is a port of =nerd-commenter= from =vim= and it helps you
to be extremely efficient while commenting lines and text selections.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-nerd-commenter
  :after evil
  :config
  (evilnc-default-hotkeys nil t))
#+END_SRC

**** Hydra

=hydra= is a package that allows keybindings to be activated under the pressing
of a specific combination of keys. These will then be active as long as only
them are being pressed, as on the moment a key which isn't part of the hydra is
pressed the hydra is killed and the keybindings deactivated.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :bind
  ("C-c e" . hydra-eyebrowse/body)
  ("C-c f" . hydra-flycheck/body)
  :config (setq-default hydra-default-hint nil))
#+END_SRC

***** Eyebrowse

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-eyebrowse (:color blue)
   "
 ^
 ^Eyebrowse^         ^Do^                ^Switch^
 ^─────────^─────────^──^────────────────^──────^────────────
 _q_ quit            _c_ create          _<_ previous
 ^^                  _k_ kill            _>_ next
 ^^                  _r_ rename          _e_ last
 ^^                  ^^                  _s_ switch
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" eyebrowse-prev-window-config :color red)
   (">" eyebrowse-next-window-config :color red)
   ("c" eyebrowse-create-window-config)
   ("e" eyebrowse-last-window-config)
   ("k" eyebrowse-close-window-config :color red)
   ("r" eyebrowse-rename-window-config)
   ("s" eyebrowse-switch-to-window-config))
 #+END_SRC

***** Flycheck

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-flycheck (:color pink)
   "
 ^
 ^Flycheck^          ^Errors^            ^Checker^
 ^────────^──────────^──────^────────────^───────^───────────
 _q_ quit            _<_ previous        _?_ describe
 _m_ manual          _>_ next            _d_ disable
 _v_ verify setup    _f_ check           _s_ select
 ^^                  _l_ list            ^^
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" flycheck-previous-error)
   (">" flycheck-next-error)
   ("?" flycheck-describe-checker :color blue)
   ("d" flycheck-disable-checker :color blue)
   ("f" flycheck-buffer)
   ("l" flycheck-list-errors :color blue)
   ("m" flycheck-manual :color blue)
   ("s" flycheck-select-checker :color blue)
   ("v" flycheck-verify-setup :color blue))
 #+END_SRC


*** Buffers and windows

- *TODO*: make a hydra to change buffers like tabs (=h= goes to previous buffer,
  =l= to the next)

=windmove= is a package that creates commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("C-M-<left>" . windmove-left)
   ("C-M-<right>" . windmove-right)
   ("C-M-<up>" . windmove-up)
   ("C-M-<down>" . windmove-down)))
#+END_SRC

Originally, =midnight= is used to /run something at midnight/. I use its feature
that kills old buffers.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :init
  (setq-default clean-buffer-list-delay-general 0.5
                clean-buffer-list-delay-special (* 1 3600)
                clean-buffer-list-kill-buffer-names (nconc clean-buffer-list-kill-buffer-names
                                                           "*IBuffer*"
                                                           "*Finder*")))
#+END_SRC

Also, I use perspective to maintain multiple workspaces open with different
buffers in each.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package perspective
  :config
  (persp-mode))
#+END_SRC

*** Scrolling

To help me locate myself in a file, I use =minimap=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minimap
  :config
  (minimap-mode))
#+END_SRC

*** Templates and snippets

I use =yasnippet= to handle my snippet needs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
        ("TAB" . nil)
        ("<tab>" . nil))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (python-mode . yas-minor-mode))
  :config
  (yas-reload-all))
#+END_SRC

*** Folding

Enables vim-like folding of regions.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :bind
  (:map vimish-fold-folded-keymap ("<tab>" . vimish-fold-unfold)
   :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
  :init
  (setq vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory)
        vimish-fold-header-width 79)
  :config
  (vimish-fold-global-mode 1))
#+END_SRC

*** Syntax Checking

=Flycheck= provides a reliable source to syntax checking in emacs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :demand
  :init
  (setq-default
   flycheck-check-syntax-automatically '(save mode-enabled)
   flycheck-disabled-checkers '(emacs-lisp-checkdoc)
   flycheck-display-errors-delay .3)
  :config
  (global-flycheck-mode))
#+END_SRC

=flycheck-pos-tip= shows the =flycheck= tip in a popup under the cursor.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-pos-tip
  :after flycheck
  :config
  (flycheck-pos-tip-mode))
#+END_SRC

*** Project management

For project management in Emacs, there's no better choice than =projectile=,
which is widely loved by the community.

It supports project-wide commands and actions, like killing all project buffers
or searching the whole project and replacing something.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :init
  (setq projectile-completion-system 'ivy
        projectile-switch-project-action 'neotree-projectile-action)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  :config
  (projectile-global-mode))
#+END_SRC

And, as a further integration of =ivy= and =projectile=, there is a package that
makes actions such as =switch-project= to use =counsel='s completion and
ordering of results.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+END_SRC

*** Regions and pointers

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-+" . er/contract-region)
  ("C-=" . er/expand-region))
#+END_SRC

=avy= offers a very efficient method of moving through your file with its
=avy-goto-word-1=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package avy
  :bind
  (:map evil-normal-state-map
        ("SPC" . avy-goto-word-1)))
#+END_SRC

*** Indentation

I use =aggressive-indent= to keep my code indented as I type.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((emacs-lisp-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (org-mode . aggressive-indent-mode))
  :init
  (setq aggressive-indent-comments-too t)
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

*** Utilities

Random utilities that don't fit anywhere else.

**** =helpful=

=helpful= is a package that is overall an improvement over the default =help=
windows.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful
  :demand
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)))
#+END_SRC

**** =dumb-jump=

=dumb-jump= is a package that allows you to jump to definition with minimal
setup (i.e. no TAG or RTAGS or etc.).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :bind
  (("M-g o" . dumb-jump-go-other-window)
   ("M-g j" . dumb-jump-go)))
#+END_SRC

**** =engine-mode=

=engine-mode= is a minor mode that allow you to easily make queries to the web
without leaving Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package engine-mode
  :demand
  :config
  (defengine google
    "https://www.google.com/search?q="
    :keybinding "g")
  (engine-mode t))
#+END_SRC

**** =no-littering=

=no-littering= is a package that helps to maintain your =.emacs.d/= clean.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package no-littering
  :demand)
#+END_SRC
**** =pdf-tools=

=pdf-tools= is what should be the default =pdf-mode= for Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pdf-tools
  :config
  (pdf-loader-install))
#+END_SRC

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides nice
support for a lot of packages and is very pleasant for the eyes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme
  :demand
  :init
  (load-theme gruvbox-dark-soft t))
#+END_SRC

* Languages

Here I'll store any package load and configurations related to languages.

I still need to add packages relating to these languages:

- [ ] C/C++
- [ ] Python
- [ ] Scala
- [ ] LaTeX

** org

=org-mode= is probably *the* killer mode and one of the main reasons as to why
anyone should try Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :hook
  (org-mode . org-indent-mode)
  :config
  (setq-default
   org-return-follows-link t
   org-highlight-latex-and-related '(latex script entities)
   org-hide-leading-stars t
   org-support-shift-select nil
   org-directory "~/org/"))
#+END_SRC

I make extensive use of blocks of source code inside my org notes, something
Knuth goes to length about in "Literate Programming".

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-src
  :after org
  :config
  (setq-default
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-window-setup 'current-window
   org-src-fontify-natively t
   org-src-tab-acts-natively t))
#+END_SRC

=org-toc= is an useful way to automatically maintain an updated table of
contents of your =.org= file.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package toc-org
  :after org
  :hook
  (org-mode . toc-org-mode))
#+END_SRC

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff you
coded yourself.

To-do:

- [ ] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Functions

Some very useful functions I got from other people or that I coded myself.

*** Date

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC


** Keybindings

Here I'll define some of my personal keybindings.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC
