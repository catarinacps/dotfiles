# -*- mode: org -*-
#+title: My Emacs configuration file
#+author: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br
#+infojs_opt:

These configurations represent my preferred version of Emacs, one that uses
=evil= everywhere it can and one that tries to be as minimalist as +I want+
possible.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]

* Table of contents                                                   :TOC_3:
- [[#introduction][Introduction]]
  - [[#what-packages-you-can-find-here][What packages you can find here]]
  - [[#use-package][=use-package=]]
    - [[#ensure][:ensure]]
    - [[#after][:after]]
    - [[#defer][:defer]]
    - [[#demand][:demand]]
    - [[#init][:init]]
    - [[#config][:config]]
- [[#the-editor][The editor]]
  - [[#definitions-and-preferences][Definitions and preferences]]
    - [[#package-servers][Package servers]]
    - [[#paths][Paths]]
    - [[#gui-elements][GUI elements]]
    - [[#font][Font]]
    - [[#text][Text]]
    - [[#mode-line][Mode line]]
    - [[#line-numbering-and-scrolling][Line numbering and scrolling]]
    - [[#randoms][Randoms]]
  - [[#extensions][Extensions]]
    - [[#package-loading-setup][Package loading setup]]
    - [[#keybindings][Keybindings]]
    - [[#completion-framework][Completion framework]]
    - [[#splash-screen][Splash screen]]
    - [[#file-management][File management]]
    - [[#environment-variables][Environment variables]]
    - [[#find-and-replace][Find and replace]]
    - [[#history][History]]
    - [[#lines-and-characters][Lines and characters]]
    - [[#compilation][Compilation]]
    - [[#mode-line-1][Mode line]]
    - [[#remote-editing][Remote editing]]
    - [[#helpful-completion][Helpful completion]]
    - [[#language-server-protocol][Language Server Protocol]]
    - [[#syntax-and-highlighting][Syntax and Highlighting]]
    - [[#hydra][Hydra]]
    - [[#buffers-and-windows][Buffers and windows]]
    - [[#templates-and-snippets][Templates and snippets]]
    - [[#folding][Folding]]
    - [[#project-management][Project management]]
    - [[#versioning][Versioning]]
    - [[#regions-pointers-and-pairs][Regions, pointers and pairs]]
    - [[#indentation][Indentation]]
    - [[#command-evaluation][Command evaluation]]
    - [[#utilities][Utilities]]
  - [[#theme][Theme]]
- [[#file-modes][File modes]]
  - [[#org][Org]]
    - [[#export][Export]]
    - [[#babel][Babel]]
    - [[#journal][Journal]]
  - [[#cc-mode][CC-Mode]]
    - [[#cc][C/C++]]
    - [[#cuda][CUDA]]
  - [[#r][R]]
  - [[#shell][Shell]]
  - [[#makefile][Makefile]]
  - [[#plantuml][PlantUML]]
  - [[#lisp][Lisp]]
  - [[#elisp][Elisp]]
  - [[#english][English]]
  - [[#python][Python]]
  - [[#cmake][CMake]]
  - [[#dockerfile][Dockerfile]]
  - [[#gmpl][GMPL]]
  - [[#julia][Julia]]
  - [[#jupyter][Jupyter]]
  - [[#latex][LaTeX]]
  - [[#coq][Coq]]
  - [[#meson][Meson]]
  - [[#bspwmsxhkd][bspwm/sxhkd]]
    - [[#file][File]]
  - [[#systemd-services][systemd services]]
  - [[#rust][Rust]]
- [[#personal][Personal]]
  - [[#functions][Functions]]
    - [[#fetching-text][Fetching text]]
    - [[#date][Date]]
    - [[#opening-things][Opening things]]
  - [[#keybindings-1][Keybindings]]

* Introduction

First of all, welcome to my configuration file for Emacs. I built it from almost
the ground up, picking up configs from several sources, some of which I've cited
in the beginning of this file.

As I'd like that this file be used as a source of inspiration for others, I
wrote it in an =.org= file, using all of =org-mode='s black magic powers of
tangling source blocks to intertwine both source =.el= and prose.

Also, I've used in almost all sections of this document a package called
=use-package= in order to organize all the additional packages that I use to get
a better Emacs experience. So, I'll teach you to read a =use-package= statement!
That way you can understand what's happening beneath all sugar syntax.

** What packages you can find here

You can find the following packages in this configuration file:

#+begin_src emacs-lisp :exports results :results value org list
(shell-command-to-string
 "grep '^(use-package .*' < config.el |
  tr -d '()' |
  cut -d' ' -f2 |
  sort")
#+end_src

#+RESULTS:
#+begin_src org
- ace-window
- aggressive-indent
- anzu
- auctex
- auctex-latexmk
- auto-compile
- bash-completion
- beacon
- ccls
- clang-format
- cmake-font-lock
- company
- company-lsp
- compile
- counsel
- counsel-projectile
- counsel-tramp
- crux
- cuda-mode
- dashboard
- deadgrep
- delight
- dockerfile-mode
- dumb-jump
- elisp-mode
- elpy
- engine-mode
- ess-r-mode
- eval-expr
- evil
- evil-matchit
- evil-mc
- evil-smartparens
- exec-path-from-shell
- expand-region
- flycheck
- flyspell
- general
- git-timemachine
- gmpl-mode
- gruvbox-theme
- helpful
- highlight-doxygen
- highlight-escape-sequences
- highlight-indent-guides
- highlight-numbers
- hydra
- ivy
- ivy-rich
- julia-mode
- jupyter
- lsp-julia
- lsp-mode
- lsp-ui
- magit
- make-mode
- meson-mode
- midnight
- modern-cpp-font-lock
- mw-thesaurus
- no-littering
- ob
- openwith
- org
- org-journal
- ox
- ox-hugo
- ox-latex
- ox-twbs
- page-break-lines
- plantuml-mode
- projectile
- rainbow-delimiters
- ranger
- rust-mode
- sh-script
- smart-mode-line
- smartparens
- ssh
- super-save
- tramp
- treemacs
- undo-tree
- uniquify
- use-package-ensure-system-package
- vimish-fold
- visual-regexp
- which-key
- whitespace
- windmove
- yasnippet
#+end_src

** =use-package=

Briefly, this package wraps your configuration for a given package in a neat
little statement, which can include several useful categorizations and
sub-tools.

Here are all little keywords you can use to organize your configs:

*** :ensure

The =:ensure= keyword tells to =use-package= that this package should be
installed in the system. Without it, =use-package= will tell you that the given
package isn't installed and won't proceed.

I define a flag to tell =use-package= to activate this keyword by default,
because I want all packages that I use installed in the system! Still, I can
turn off this behaviour if I set the keyword to =false=.

#+begin_src emacs-lisp
(use-package foo
  :ensure t)      ; I need this package installed!

(use-package foo
  :ensure f)      ; I don't NEED the package installed
#+end_src

You can also use this keyword to tell that your package need another installed
before it loads!

#+begin_src emacs-lisp
  (use-package foo
    :ensure bar)
#+end_src

*** :after

The =:after= keyword sets a relation of dependency between the loading of two
packages. In other words, you can tell =use-package= that a given package should
only be loaded if that other package is already loaded.

#+begin_src emacs-lisp
(use-package foo)

(use-package bar
  :after foo)

(use-package moo
  :after (foo bar))    ; Supports mmultiple dependencies!
#+end_src

*** :defer

The =:defer= keyword tells =use-package= that it can defer the loading of your
package until its absolutely needed. Its behaviour is the opposite of the
keyword =:demand=.

#+begin_src emacs-lisp
(use-package foo
  :defer t)
#+end_src

*** :demand

The =:demand= keyword says to =use-package= that this package must not be
lazy-loaded, and should be loaded right away as Emacs loads.

#+begin_src emacs-lisp
(use-package foo
  :demand)
#+end_src

*** :init

The =:init= keyword can tell =use-package= to execute said commands *BEFORE* the
package is loaded. In reality, said execution will happen as soon as the
=use-package= statement is processed on the Emacs loading process.

#+begin_src emacs-lisp
(use-package foo
  :init
  (setq bar t))
#+end_src

*** :config

The =:config= keyword, much like the =:init= keyword, tells =use-package= to
execute commands. The difference is that commands defined with this keyword will
only execute *AFTER* the package is loaded. There is an important difference
here, as =use-package= uses what's called /lazy loading/, i.e. only load the
package when you actually need it.

#+begin_src emacs-lisp
(use-package foo
  :config
  (foo-init))
#+end_src

* The editor

Everything related to Emacs as the editor and platform.

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** Package servers

By default we only get the GNU one...

#+begin_src emacs-lisp :tangle yes
(require 'package)

(setq-default package-archives
              '(("melpa" . "https://melpa.org/packages/")
                ("org" . "https://orgmode.org/elpa/")
                ("gnu" . "https://elpa.gnu.org/packages/")))

(package-initialize)
#+end_src

*** Paths

As in "where we are", as there isn't a direct way of getting such info.

#+begin_src emacs-lisp :tangle yes
(defvar root-dir (file-name-directory load-file-name) "The root dir of Emacs.")

(setq package-user-dir (expand-file-name "elpa" root-dir))
#+end_src

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen space.

#+begin_src emacs-lisp :tangle yes
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
(customize-set-variable 'menu-bar-mode nil)
(customize-set-variable 'tool-bar-mode nil)
#+end_src

To be fair, some stuff is really personal preference of mine.

#+begin_src emacs-lisp :tangle yes
(setq-default inhibit-startup-screen t
              initial-scratch-message nil
              initial-major-mode 'text-mode)
#+end_src

And then there's the title question. I for one like Emacs capitalized, so...

#+begin_src emacs-lisp :tangle yes
(setq-default frame-title-format
              '((capitalize invocation-name)
                (:eval (if (buffer-file-name)
                           (abbreviate-file-name (buffer-file-name))
                         "%b"))))
#+end_src

*** Font

I use the =Inconsolata= font!

#+begin_src emacs-lisp :tangle yes
(setq-default default-frame-alist '((font . "Inconsolata-14")))
#+end_src

Before this, I used to use =Inconsolata-G=, which I couldn't find a GitHub of
sorts, here's a link to a mirror [[https://www.fontmirror.com/inconsolata-g]].
Also, you may end up having some issues with this font, as Emacs only knows the
XLFD (which splits the important font info by the '-'), so our =Inconsolata-g=
will face some issues here and there. To fix this, duplicate the font in your
font directory (probably /usr/share/fonts/TTF) and alter the copy's name as
[[this][https://emacs.stackexchange.com/questions/16818/cocoa-emacs-24-5-font-issues-inconsolata-dz]]
link indicates.

*** Text

Here's every other setting relating to text editing I can't categorize any
further.

#+begin_src emacs-lisp :tangle yes
(setq-default fill-column 80
              ;; posssible values: (left right center full nil)
              default-justification 'left
              indent-tabs-mode nil
              sentence-end-double-space nil
              tab-width 4
              line-spacing 0
              require-final-newline t
              x-stretch-cursor t
              cursor-in-non-selected-windows t)

(blink-cursor-mode 0)
#+end_src

Also, =auto-fill-mode= is very useful to justify paragraphs automatically while
writing.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

*** Mode line

Here's everything related to the mode-line.

#+begin_src emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M "
              display-time-default-load-average nil)

(display-time-mode 1)
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+end_src

*** Line numbering and scrolling

I like the vim style of relative numbering of lines.

#+begin_src emacs-lisp :tangle yes
(setq-default display-line-numbers-type 'relative
              display-line-numbers-width-start 4)

;; I used to do this globally, but now let's only do selectively
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(add-hook 'conf-mode-hook 'display-line-numbers-mode)
#+end_src

And I also like the vim style of scrolling better.

#+begin_src emacs-lisp :tangle yes
(setq-default auto-window-vscroll nil
              scroll-step 1
              scroll-conservatively most-positive-fixnum
              scroll-margin 10)
#+end_src

Highlighting the current line is also very useful.

#+begin_src emacs-lisp :tangle yes
(global-hl-line-mode 1)
#+end_src

*** Randoms

Random configs and definitions that don't have a clear category.

#+begin_src emacs-lisp :tangle yes
(setq-default ad-redefinition-action 'accept       ; Silence warnings for redefinition
              confirm-kill-emacs 'yes-or-no-p      ; Confirm before exiting Emacs
              select-enable-clipboard t            ; Merge system's and Emacs' clipboard
              window-combination-resize t          ; Resize windows proportionally
              ring-bell-function 'ignore)          ; No bell ring

; Replace yes/no prompts with y/n
(fset 'yes-or-no-p 'y-or-n-p)

; Set Emacs to call the garbage collector on focus-out
(add-hook 'focus-out-hook #'garbage-collect)

; use GPG-agent instead of the default
(setenv "SSH_AUTH_SOCK"
          (concat (getenv "XDG_RUNTIME_DIR") "/gnupg/S.gpg-agent.ssh"))
#+end_src

** Extensions

These are Emacs-behaviour related! In other words, these extend the capabilities
of Emacs as an editor, and do NOT add support to other languages or etc.

*TO-DO list*:

- [ ] recentf

*** Package loading setup

I use =use-package= to load my packages and to organize them neatly in this org
file. I plan to gradually rip everything I want from =prelude= and put it here
eventually, using =use-package=.

#+begin_src emacs-lisp :tangle yes
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package-ensure)
(setq use-package-always-ensure t
      use-package-verbose t
      use-package-hook-name-suffix nil)
#+end_src

In order to demand that certain system packages are installed, I use the helper
package called =use-package-ensure-system-package=. Installing it I can use the
=:ensure-system-package= keywords and demand that certain packages are installed
in the system before proceeding (useful to LaTeX, for example)!

#+begin_src emacs-lisp :tangle yes
(use-package use-package-ensure-system-package)
#+end_src

Having that said, I too use =auto-compile= to always compile packages and to
have their newest version.

#+begin_src emacs-lisp :tangle yes
(use-package auto-compile
  :demand
  :custom
  (load-prefer-newer t)
  :config
  (auto-compile-on-load-mode))
#+end_src

To add facilitate my keybinding issues, I also use =general.el=. It adds some
very welcome keywords to =use-package=, in which I'll use extensively throughout
this file.

#+begin_src emacs-lisp :tangle yes
(use-package general
  :demand
  :preface
  (defconst hcps/leader-key "SPC"
    "Leader key for some special commands.")
  :config
  (general-def
   :states '(normal visual)
   :prefix hcps/leader-key
   "" nil))
#+end_src

And we'll use =delight= to hide minor-modes names and such.

#+begin_src emacs-lisp :tangle yes
(use-package delight
  :demand
  :delight
  (auto-fill-function " af")
  (eldoc-mode " eldoc")
  (editorconfig-mode)
  (flymake-mode " flymk")
  (prelude-mode)
  (abbrev-mode))
#+end_src

*** Keybindings

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs text
editing keybindings to match the modal edit modes of vi and vim. Yes, you can
have the best of both worlds!

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :demand
  :ensure evil-numbers
  :ensure evil-surround
  :ensure evil-visualstar
  :ensure evil-collection
  :preface
  (defun hcps/yank-to-eol ()
    "Yank to the EOL."
    (interactive)
    (evil-yank (point) (point-at-eol)))
  (defun hcps/shift-left-region ()
    "Shift left and restore visual selection."
    (interactive)
    (evil-shift-left (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  (defun hcps/shift-right-region ()
    "Shift right and restore visual selection."
    (interactive)
    (evil-shift-right (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  :general
  (:states '(normal visual)
   "C-u" 'evil-scroll-up
   "C-d" 'evil-scroll-down
   "C-a" 'evil-numbers/inc-at-pt
   "C-S-a" 'evil-numbers/dec-at-pt)
  (:states 'insert
   "<up>" 'previous-line
   "<down>" 'next-line
   "<left>" 'left-char
   "<right>" 'right-char
   "<tab>" 'indent-for-tab-command)
  (:states 'normal
   "Y" 'hcps/yank-to-eol)
  (:states 'visual
   ">" 'hcps/shift-right-region
   "<" 'hcps/shift-left-region)
  :custom
  (evil-esc-delay 0)
  (evil-shift-width 2)
  (evil-want-keybinding nil)
  (evil-auto-indent t)
  (evil-want-fine-undo t)
  (evil-search-wrap t)
  (evil-regexp-search t)
  (evil-search-module 'isearch)
  (evil-emacs-state-cursor  '("red" box))
  (evil-normal-state-cursor '("gray" box))
  (evil-visual-state-cursor '("gray" hollow))
  (evil-insert-state-cursor '("gray" bar))
  (evil-motion-state-cursor '("gray" hbar))
  (evil-operator-state-cursor '("gray" evil-half-cursor))
  (evil-mode-line-format '(before . mode-line-front-space))
  (evil-normal-state-tag   (propertize "   NORMAL   " 'face '((:background "DarkGoldenrod2" :foreground "black"))))
  (evil-emacs-state-tag    (propertize "   EMACS    " 'face '((:background "SkyBlue2"       :foreground "black"))))
  (evil-insert-state-tag   (propertize "   INSERT   " 'face '((:background "chartreuse3"    :foreground "black"))))
  (evil-replace-state-tag  (propertize "  REPLACE   " 'face '((:background "chocolate"      :foreground "black"))))
  (evil-motion-state-tag   (propertize "   MOTION   " 'face '((:background "plum3"          :foreground "black"))))
  (evil-visual-state-tag   (propertize "   VISUAL   " 'face '((:background "gray"           :foreground "black"))))
  (evil-operator-state-tag (propertize "  OPERATOR  " 'face '((:background "sandy brown"    :foreground "black"))))
  :config
  (evil-mode 1)
  (global-evil-surround-mode 1)
  (evil-collection-init))
#+end_src

Also I use =evil-surround=, which is a port of =surround= from vim and allow you
to quickly delete or change surrounding ="= and ='= from words or paragraphs or
whatever, as it integrates with vim's verb way of expressing actions.

=evil-visualstar= enables searching visual selections with the =*= key.

The package =evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages.

=evil-mc= implements the =multiple-cursors= functionality to =evil-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package evil-mc
  :after evil
  :general
  (:states 'visual
   "A" 'evil-mc-make-cursor-in-visual-selection-end
   "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  (:states '(normal visual)
   :prefix hcps/leader-key
   "ESC" 'evil-mc-undo-all-cursors)
  :config
  (global-evil-mc-mode 1))
#+end_src

=evil-matchit= allows you to jump between tags automatically!

#+begin_src emacs-lisp :tangle yes
(use-package evil-matchit
  :after evil
  :custom
  (evilmi-may-jump-by-percentage nil)
  :config
  (global-evil-matchit-mode 1))
#+end_src

And to use better bindings to =smartparens=, =evil-smartparens=!

#+begin_src emacs-lisp :tangle yes
(use-package evil-smartparens
  :after smartparens
  :delight
  :hook
  (smartparens-enabled-hook . evil-smartparens-mode))
#+end_src

*** Completion framework

=ivy= is like =ido= but better, I guess. It does fuzzy matching of searches to
open files and such. =flx= is required here in order to have fuzzy matching and
whatnot.

#+begin_src emacs-lisp :tangle yes
(use-package ivy
  :ensure flx
  :demand
  :delight
  :preface
  (defun hcps/ivy-open-current-typed-path ()
    (interactive)
    (when ivy--directory
      (let* ((dir ivy--directory)
             (text-typed ivy-text)
             (path (concat dir text-typed)))
        (delete-minibuffer-contents)
        (ivy--done path))))
  :custom
  (ivy-count-format "(%d/%d) ")
  (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
  (ivy-height 8)
  (ivy-extra-directories nil)
  (ivy-wrap t)
  (ivy-action-wrap t)
  (ivy-initial-inputs-alist nil)
  (ivy-format-functions-alist '((t . ivy-format-function-line)))
  :custom-face
  (ivy-current-match ((t :inherit hl-line :bold t :underline nil)))
  :general
  (:keymaps 'ivy-minibuffer-map
   "RET" 'ivy-alt-done
   "C-f" 'hcps/ivy-open-current-typed-path
   "C-l" 'ivy-next-line
   "C-h" 'ivy-previous-line)
  :config
  (ivy-mode 1))
#+end_src

=counsel= uses =ivy= to find files and commands. =smex= is required here to
make sure that =counsel-M-x= has decent candidate sorting.

#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :ensure smex
  :after ivy
  :demand
  :preface
  (defun hcps/override-yank-pop (&optional arg)
    "Delete the region before inserting popped string."
    (when (and evil-mode (eq 'visual evil-state))
      (kill-region (region-beginning) (region-end))))
  :init
  (advice-add 'counsel-yank-pop :before #'hcps/override-yank-pop)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "f f" 'counsel-find-file
   "b" 'counsel-switch-buffer
   "r" 'counsel-recentf
   "y" 'counsel-yank-pop
   "m p" 'counsel-package
   "m b" 'counsel-bookmark)
  ("M-x" 'counsel-M-x))
#+end_src

As you may know, in Emacs we use =tramp= to edit files remotely using =ssh= and
to edit local files as =root=. With the package =counsel-tramp= we have an
=counsel=-powered interface to use that mechanism!

This package looks up your hosts defined in =~/.ssh/config= to generate a list
with possible =ssh= connections AND docker containers (thanks to
=docker-tramp=), along with =sudo= possibilities (including =localhost=!).

#+begin_src emacs-lisp :tangle yes
(use-package counsel-tramp
  :ensure docker-tramp
  :after counsel
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m t" 'counsel-tramp))
#+end_src

And, as a bonus, I've added the package =ivy-rich= to make the =ivy= minibuffer
the prettiest on all the land.

#+begin_src emacs-lisp :tangle yes
(use-package ivy-rich
  :after ivy
  :config
  (ivy-rich-mode 1))
#+end_src

*** Splash screen

There's some utility in having a cool initial screen actually. And there's a
cool extension that provides such functionality.

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
  :ensure all-the-icons
  :custom
  (initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (dashboard-banner-logo-title (format "Welcome to Emacs, %s!" current-user))
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons nil)
  (dashboard-startup-banner 'logo)
  (dashboard-items '((recents  . 10)
                     (projects . 5)
                     (bookmarks . 5)
                     (agenda . 5)))
  :general
  (:states '(normal visual)
   :keymaps 'dashboard-mode-map
   "SPC" nil)
  :config
  (dashboard-setup-startup-hook))
#+end_src

*** File management

I use =ranger.el= to use a file explorer like =ranger= inside Emacs instead of
the default =dired=.

#+begin_src emacs-lisp :tangle yes
(use-package ranger
  :custom
  (ranger-cleanup-on-disable t)
  (ranger-preview-file t)
  (ranger-dont-show-binary t)
  (ranger-max-preview-size 10)
  :config
  (ranger-override-dired-mode t)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "d" 'ranger))
#+end_src

While I've somewhat used =neotree.el=, I believe that =treemacs= is turning out
to be a better option, as it offers a bunch of extra integrating packages and is
overall more popular than the former.

#+begin_src emacs-lisp :tangle yes
(use-package treemacs
  :defer t
  :ensure treemacs-evil
  :ensure treemacs-projectile
  :general
  ("M-0" 'treemacs-select-window
   "M-t" 'treemacs)
  :custom
  (treemacs-deferred-git-apply-delay 0.5)
  (treemacs-display-in-side-window t)
  (treemacs-eldoc-display t)
  (treemacs-file-event-delay 5000)
  (treemacs-file-follow-delay 0.2)
  (treemacs-follow-after-init t)
  (treemacs-git-command-pipe "")
  ;; (treemacs-goto-tag-strategy 'refetch-index)
  (treemacs-indentation 2)
  (treemacs-indentation-string " ")
  (treemacs-is-never-other-window nil)
  (treemacs-max-git-entries 5000)
  (treemacs-missing-project-action 'ask)
  (treemacs-no-png-images nil)
  (treemacs-no-delete-other-windows t)
  (treemacs-project-follow-cleanup nil)
  (treemacs-persist-file (expand-file-name ".cache/treemacs-persist" user-emacs-directory))
  (treemacs-position 'left)
  (treemacs-recenter-distance 0.1)
  (treemacs-recenter-after-file-follow nil)
  (treemacs-recenter-after-tag-follow nil)
  (treemacs-recenter-after-project-jump 'always)
  (treemacs-recenter-after-project-expand 'on-distance)
  (treemacs-show-cursor nil)
  (treemacs-show-hidden-files t)
  (treemacs-silent-filewatch nil)
  (treemacs-silent-refresh nil)
  (treemacs-sorting 'alphabetic-desc)
  (treemacs-space-between-root-nodes t)
  (treemacs-tag-follow-cleanup t)
  (treemacs-tag-follow-delay 1.5)
  (treemacs-width 25)
  :config
  (treemacs-follow-mode t)
  (treemacs-filewatch-mode t)
  (treemacs-fringe-indicator-mode t))
#+end_src

*** Environment variables

To ensure that Emacs uses the same path and environment as =shell= uses, I use
=exec-path-from-shell=. That way commands that work on the =shell= will
certainly work on Emacs!

#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if
  (memq window-system '(mac ns))
  :demand
  :init
  (setenv "SHELL" "/usr/bin/bash")
  :custom
  (exec-path-from-shell-arguments '("-l"))
  (exec-path-from-shell-variables '("PATH" "MANPATH"))
  :config
  (exec-path-from-shell-initialize))
#+end_src

*** Find and replace

Besides the =ISearch= from Emacs itself or the search function from =evil=, I
also like to use =anzu=.

#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :delight isearch-mode
  :preface
  (defun hcps/anzu-update-func (here total)
    (when anzu--state
      (let ((status (cl-case anzu--state
                      (search (format "(%d/%d) " here total))
                      (replace-query (format "(%d replaces) " total))
                      (replace (format "(%d/%d) " here total)))))
        (propertize status 'face 'anzu-mode-line))))
  :custom
  (anzu-cons-mode-line-p t)
  (anzu-mode-line-update-function #'hcps/anzu-update-func)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m r" 'anzu-replace-at-cursor-thing)
  :config
  (global-anzu-mode 1))
#+end_src

I use only the =anzu-replace-at-cursor-thing=, which is a very useful to replace
multiple occurrences of a word fast.

I enjoy using =ripgrep= to search for stuff using =grep= syntax without the
slowness of it. So, I use =deadgrep=!

#+begin_src emacs-lisp :tangle yes
(use-package deadgrep
  :after evil-collection
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m g" 'deadgrep)
  :config
  (evil-collection-deadgrep-setup))
#+end_src

And, to upgrade Emacs to the 21st century, I use =visual-regexp=!

#+begin_src emacs-lisp :tangle yes
(use-package visual-regexp
  :ensure visual-regexp-steroids
  :ensure pcre2el
  :init
  (advice-add 'vr--get-regexp-modifiers-prefix
              :filter-return (lambda (fun-ret)
                               (if (not (string= "" fun-ret)) (concat fun-ret " "))))
  :custom
  (vr/default-feedback-limit 300)
  (vr/engine 'pcre2el)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "R" 'vr/query-replace))
#+end_src

*** History

Undo and redo and kools with =undo-tree=!

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :hook
  (after-init-hook . global-undo-tree-mode)
  :preface
  (defun reset-visualizer-diff ()
    "Because undo-tree-visualize sets the value of this variable to nil on quit."
    (setq undo-tree-visualizer-diff
          (eval (car (get 'undo-tree-visualizer-diff 'customized-value)))))
  :custom
  (undo-tree-visualizer-timestamps t)
  (undo-tree-enable-undo-in-region nil)
  (undo-tree-auto-save-history nil)
  (undo-tree-visualizer-diff t)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "u" 'undo-tree-visualize)
  :config
  (advice-add 'undo-tree-visualize :before #'reset-visualizer-diff))
#+end_src

*** Lines and characters

Let's monitor ourselves with =whitespace=.

#+begin_src emacs-lisp :tangle yes
(use-package whitespace
  :demand
  :hook
  ((after-save-hook . whitespace-cleanup)
   (text-mode-hook . whitespace-mode)
   (conf-mode-hook . whitespace-mode)
   (prog-mode-hook . whitespace-mode))
  :custom
  (whitespace-line-column 80)
  (whitespace-style '(face tabs empty trailing lines-tail)))
#+end_src

*** Compilation

Emacs has a default compile command, and it tries its best. Here's some
extra configuration about it:

#+begin_src emacs-lisp :tangle yes
(use-package compile
  :custom
  (compilation-ask-about-save nil)
  (compilation-always-kill t)
  (compilation-scroll-output 'first-error))
#+end_src

*** Mode line

I use =smart-mode-line= as it is very minimalist and informative (and it looks
very pretty on =gruvbox=).

#+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :demand
  :init
  (setq sml/no-confirm-load-theme t)
  :custom
  (sml/projectile-replacement-format "[%s] ")
  (sml/size-indication-format " %I ")
  (sml/line-number-format "%4l")
  (sml/use-projectile-p 'after-prefixes)
  (sml/shorten-directory nil)
  (sml/shorten-modes t)
  (sml/mode-width 'right)
  (sml/name-width 40)
  (sml/theme 'respectful)
  :config
  (sml/setup))
#+end_src

*** Remote editing

=tramp=, which is included by default in Emacs, is very useful when it comes to
editing remote files and to editing as super-user.

#+begin_src emacs-lisp :tangle yes
(use-package tramp
  :demand
  :custom
  (tramp-default-method "ssh"))
#+end_src

Here's a small package that allows remotely opening sessions.

#+begin_src emacs-lisp :tangle yes
(use-package ssh
  :after shell
  :preface
  (defcustom ssh-current-server nil
    "Last remote server created by SSH."
    :type 'string
    :safe #'stringp
    :group 'ssh)
  (defcustom ssh-defaut-server nil
    "Default remote server to be used when remotely using server with SSH (e.g. bolsa.inf)."
    :type 'string
    :safe #'stringp
    :group 'ssh)
  (defcustom ssh-remote-user-server nil
    "Dummy variable that holds a server name."
    :type 'string
    :safe #'stringp
    :group 'ssh)
  (defun ssh-connect-remote (SERVER)
    "Open a SSH session buffer to the desired target."
    (interactive (list (read-from-minibuffer
                        (format "What server to connect to (default: %s): "
                                ssh-default-server))))
    (let* ((server-to-connect (if (equal SERVER "") ssh-default-server SERVER)))
      (setq ssh-current-server (buffer-name (ssh server-to-connect))))
    (get-buffer-create ssh-current-server))
  (defun hcps/ssh-user-connect ()
    "Calls interactively the ssh-connect-remote function."
    (interactive)
    (call-interactively 'ssh-connect-remote))
  (defun hcps/get-user-server ()
    "Call to set and print the user server."
    (interactive)
    (if (equal ssh-remote-user-server nil)
        (setq ssh-remote-user-server
              (read-from-minibuffer "What server to store: ")))
    (concat "/scp:" ssh-remote-user-server ":"))
  (defun hcps/store-user-remote ()
    "Store a server name to the desired target."
    (interactive)
    (let* ((read-server (read-from-minibuffer
                         (format "What server to store (current: %s): " ssh-remote-user-server)))
           (server-to-connect (if (equal read-server "") ssh-remote-user-server read-server)))
      (setq ssh-remote-user-server server-to-connect)))
  :custom
  (shell-command-dont-erase-buffer t)
  (ssh-default-server "bolsa.inf")
  (ssh-directory-tracking-mode t)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m s" 'hcps/ssh-user-connect
   "m S" 'hcps/store-user-remote)
  :config
  (shell-dirtrack-mode t))
#+end_src

*** Helpful completion

This section comprises of text and command completion.

**** Text

I use =company= as my completion framework. In the words of Dmitry Gutov:

#+begin_quote
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package company
  :general
  (:keymaps 'company-active-map
   "TAB" 'company-complete-selection
   "<right>" 'company-complete-common)
  :custom
  (company-idle-delay .2)
  (company-minimum-prefix-length 1)
  (company-show-numbers t)
  (company-tooltip-limit 10)
  (company-tooltip-flip-when-above t)
  (company-require-match nil)
  (company-tooltip-align-annotations t)
  :config
  (global-company-mode 1))
#+end_src

**** Help

The package called =which-key= shows you possible completions to the command
you're typing in the mode-line.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :demand
  :delight
  :config
  (which-key-mode 1))
#+end_src

*** Language Server Protocol

I imagine anyone knows what is LSP, but oh well. Basically, it is one of the
best features of other famous editors, such as Visual Studio Code. By using
=lsp-mode=, we'll be able to have it too!

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :defer t
  :commands lsp
  :delight
  (lsp-mode " lsp")
  :hook
  ((prog-mode-hook . lsp)
   (lsp-mode-hook . lsp-enable-which-key-integration))
  :custom
  (lsp-log-io t)
  (lsp-auto-guess-root t)
  (lsp-prefer-flymake nil)
  (lsp-enable-completion-at-point t)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "L" '(:keymap lsp-command-map :package lsp-mode))
  :config
  (add-to-list 'lsp-language-id-configuration '(cuda-mode . "cuda"))
  (add-to-list 'lsp-language-id-configuration '(".*\\.cu$" . "cuda")))
#+end_src

This package does have 2 extra sister packages: =lsp-ui= and =lsp-company=

#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
  :after lsp-mode
  :delight
  (flycheck-mode)
  :hook
  (lsp-mode-hook . lsp-ui-mode)
  :custom
  (lsp-ui-doc-enable t)
  (lsp-ui-doc-use-childframe t)
  (lsp-ui-doc-include-signature t)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-flycheck-enable t)
  (lsp-ui-flycheck-list-position 'right)
  (lsp-ui-flycheck-live-reporting t))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package company-lsp
  :after lsp-mode
  :custom
  (company-lsp-cache-candidates t)
  (company-lsp-async t)
  (company-lsp-enable-recompletion t)
  :config
  (add-to-list 'company-backends 'company-lsp))
#+end_src

*** Syntax and Highlighting

=Flycheck= provides a reliable source to syntax checking in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :disabled
  :demand
  :delight
  (flycheck-mode)
  :init
  (global-flycheck-mode)
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay .3)
  :config
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message) line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))
  (add-to-list 'flycheck-checkers 'proselint))
#+end_src

This highlights numbers in =prog-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-numbers
  :defer t
  :hook
  (prog-mode-hook . highlight-numbers-mode))
#+end_src

And this is to highlight escape sequences in some common modes:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-escape-sequences
  :hook
  (after-init-hook . turn-on-hes-mode)
  :preface
  (defconst hes-shell-escape-sequence-re
    (rx (submatch
         (and ?\\ (submatch (any "\"\'\\bfnrtv")))))
    "Simple regex to match any common escaped character in sh-mode")
  ;; :config
  ;; (add-to-list 'hes-mode-alist '(sh-mode . (:eval hes-shell-escape-sequence-re)))
  )
#+end_src

Of course, =flyspell= corrects your writing!

#+begin_src emacs-lisp :tangle yes
(use-package flyspell
  :demand
  :delight
  (flyspell-mode " flysp")
  (flyspell-prog-mode " flysp")
  :hook
  ((prog-mode-hook . flyspell-prog-mode)
   (text-mode-hook . flyspell-mode))
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra"))
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m d" 'ispell-change-dictionary))
#+end_src

*** Hydra

=hydra= is a package that allows keybindings to be activated under the pressing
of a specific combination of keys. These will then be active as long as only
them are being pressed, as on the moment a key which isn't part of the hydra is
pressed the hydra is killed and the keybindings deactivated.

#+begin_src emacs-lisp :tangle yes
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :general
  ("C-c e" 'hydra-eyebrowse/body)
  ("C-c f" 'hydra-flycheck/body)
  :custom
  (hydra-default-hint nil))
#+end_src

**** Eyebrowse

 #+begin_src emacs-lisp
 (defhydra hydra-eyebrowse (:color blue)
   "
 ^
 ^Eyebrowse^         ^Do^                ^Switch^
 ^─────────^─────────^──^────────────────^──────^────────────
 _q_ quit            _c_ create          _<_ previous
 ^^                  _k_ kill            _>_ next
 ^^                  _r_ rename          _e_ last
 ^^                  ^^                  _s_ switch
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" eyebrowse-prev-window-config :color red)
   (">" eyebrowse-next-window-config :color red)
   ("c" eyebrowse-create-window-config)
   ("e" eyebrowse-last-window-config)
   ("k" eyebrowse-close-window-config :color red)
   ("r" eyebrowse-rename-window-config)
   ("s" eyebrowse-switch-to-window-config))
 #+end_src

**** Flycheck

 #+begin_src emacs-lisp
 (defhydra hydra-flycheck (:color pink)
   "
 ^
 ^Flycheck^          ^Errors^            ^Checker^
 ^────────^──────────^──────^────────────^───────^───────────
 _q_ quit            _<_ previous        _?_ describe
 _m_ manual          _>_ next            _d_ disable
 _v_ verify setup    _f_ check           _s_ select
 ^^                  _l_ list            ^^
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" flycheck-previous-error)
   (">" flycheck-next-error)
   ("?" flycheck-describe-checker :color blue)
   ("d" flycheck-disable-checker :color blue)
   ("f" flycheck-buffer)
   ("l" flycheck-list-errors :color blue)
   ("m" flycheck-manual :color blue)
   ("s" flycheck-select-checker :color blue)
   ("v" flycheck-verify-setup :color blue))
 #+end_src

*** Buffers and windows

=windmove= is a package that creates commands to move around windows.

#+begin_src emacs-lisp
(use-package windmove
  :general
  ("C-M-h" 'windmove-left)
  ("C-M-l" 'windmove-right)
  ("C-M-k" 'windmove-up)
  ("C-M-j" 'windmove-down))
#+end_src

Originally, =midnight= is used to /run something at midnight/. I use its feature
that kills old buffers.

#+begin_src emacs-lisp
(use-package midnight
  :custom
  (clean-buffer-list-delay-general 0.5)
  (clean-buffer-list-delay-special (* 1 3600))
  (clean-buffer-list-kill-buffer-names
   '("*Help*" "*Apropos*" "*Buffer List*" "*Compile-Log*" "*info*" "*vc*"
     "*vc-diff*" "*diff*" "*IBuffer*" "*Finder*")))
#+end_src

=uniquify= creates automatic meaningful names for buffers with the same name:

#+begin_src emacs-lisp :tangle yes
(use-package uniquify
  :ensure nil
  :demand
  :custom
  (uniquify-buffer-name-style 'forward)
  (uniquify-separator "/")
  (uniquify-after-kill-buffer-p t)
  (uniquify-ignore-buffers-re "^\\*"))
#+end_src

=ace-window= creates labels so we can jump windows with precision:

#+begin_src emacs-lisp :tangle yes
(use-package ace-window
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "w o" 'ace-window))
#+end_src

=super-save= auto-saves buffers when you switch or close buffers or when Emacs
loses focus, etc.

#+begin_src emacs-lisp :tangle yes
(use-package super-save
  :demand
  :delight
  :custom
  (super-save-auto-save-when-idle t)
  (super-save-remote-files nil)
  :config
  (add-to-list 'super-save-triggers 'ace-window)
  (super-save-mode 1))
#+end_src

*** Templates and snippets

I use =yasnippet= to handle my snippet needs.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :demand
  :delight yas-minor-mode
  :hook
  ((emacs-lisp-mode-hook . yas-minor-mode)
   (html-mode-hook . yas-minor-mode))
  :init
  (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  :general
  (:keymaps 'yas-minor-mode-map
   :states 'insert
   "<tab>" yas-maybe-expand)
  :custom
  (yas-snippet-dirs '("~/.emacs.d/snippets"))
  :config
  (yas-reload-all))
#+end_src

*** Folding

Enables vim-like folding of regions.

#+begin_src emacs-lisp
(use-package vimish-fold
  :general
  (:keymaps 'vimish-fold-folded-keymap
   "C-<tab>" 'vimish-fold-unfold)
  (:keymaps 'vimish-fold-unfolded-keymap
   "C-<tab>" 'vimish-fold-refold)
  :custom
  (vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory))
  (vimish-fold-header-width 79)
  :config
  (vimish-fold-global-mode 1))
#+end_src

*** Project management

For project management in Emacs, there's no better choice than =projectile=,
which is widely loved by the community.

It supports project-wide commands and actions, like killing all project buffers
or searching the whole project and replacing something.

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :hook
  (after-init-hook . projectile-mode)
  ;; there's already a hint to the project name in the name of the buffer,
  ;; thanks to smart-mode-line
  :delight
  :custom
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action 'projectile-find-file)
  (projectile-find-dir-includes-top-level t)
  (projectile-project-root-files-top-down-recurring
   '("compile_commands.json" ".ccls" ".svn" "CVS" "Makefile"))
  (projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o"))
  (projectile-globally-ignored-files '(".DS_Store" "Icon" "TAGS" "__PYCACHE__"))
  :general
  ([remap compile] 'projectile-compile-project)
  (:states '(normal visual)
   :prefix hcps/leader-key
   "p" '(:keymap projectile-command-map :package projectile))
  :config
  ;; clean dead projects when Emacs is idle
  (run-with-idle-timer 10 nil #'projectile-cleanup-known-projects))
#+end_src

And, as a further integration of =ivy= and =projectile=, there is a package that
makes actions such as =switch-project= to use =counsel='s completion and
ordering of results.

#+begin_src emacs-lisp :tangle yes
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+end_src

*** Versioning

Obviously, any configuration file that says it deserves *any* respect should
feature =magit=, as it is, hands down, the best =git= front-end in the visible
universe, nay, in the whole multiverse.

#+begin_src emacs-lisp :tangle yes
(use-package magit
  :defer t
  :hook
  ((after-save-hook . magit-after-save-refresh-status)
   (git-commit-mode-hook . evil-emacs-state))
  :preface
  ;; easy on-off for the following function
  (defcustom magit-push-protected-branch nil
    "When set, ask for confirmation before pushing to this branch (e.g. master)."
    :type 'string
    :safe #'stringp
    :group 'magit)
  ;; are you sure you wanna push to master?
  (defun magit-push--protected-branch (magit-push-fun &rest args)
    "Ask for confirmation before pushing a protected branch."
    (if (equal magit-push-protected-branch (magit-get-current-branch))
        ;; Arglist is (BRANCH TARGET ARGS)
        (if (yes-or-no-p (format "Push branch %s? " (magit-get-current-branch)))
            (apply magit-push-fun args)
          (error "Push aborted by user"))
      (apply magit-push-fun args)))
  :init
  (advice-add 'magit-push-current-to-pushremote :around #'magit-push--protected-branch)
  (advice-add 'magit-push-current-to-upstream :around #'magit-push--protected-branch)
  :custom
  (git-commit-major-mode 'text-mode)
  (magit-push-protected-branch "master")
  (magit-save-repository-buffers 'dontask)
  (magit-refs-show-commit-count 'all)
  (magit-log-buffer-file-locked t)
  (magit-revision-show-gravatars nil)
  (magit-bury-buffer-function 'magit-mode-quit-window)
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "g p" 'magit-list-repositories
   "g g" 'magit-status
   "g d" 'magit-dispatch
   "g f" 'magit-file-dispatch
   "g l" 'magit-log
   "g b" 'magit-blame)
  :config
  (evil-add-hjkl-bindings magit-log-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-diff-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-commit-mode-map 'emacs)
  (evil-add-hjkl-bindings magit-branch-manager-mode-map 'emacs
    "K" 'magit-discard
    "L" 'magit-log)
  (evil-add-hjkl-bindings magit-status-mode-map 'emacs
    "K" 'magit-discard
    "l" 'magit-log
    "h" 'magit-diff-toggle-refine-hunk))
#+end_src

Also, =git-timemachine= is a beautiful way to walk through git history:

#+begin_src emacs-lisp :tangle yes
(use-package git-timemachine
  :after magit
  :hook
  (git-timemachine-mode-hook . evil-normalize-keymaps)
  :general
  (:states '(normal visual)
   :keymaps 'git-timemachine-mode-map
   "C-j" 'git-timemachine-show-next-revision
   "C-k" 'git-timemachine-show-previous-revision
   "q" 'git-timemachine-quit
   "w" 'git-timemachine-kill-abbreviated-revision
   "g" 'git-timemachine-show-nth-revision
   "c" 'git-timemachine-show-commit)
  (:states '(normal visual)
   :prefix hcps/leader-key
   "g t" 'git-timemachine)
  :config
  (evil-make-overriding-map git-timemachine-mode-map 'normal))
#+end_src

*** Regions, pointers and pairs

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+begin_src emacs-lisp
(use-package expand-region
  :general
  ("C-+" 'er/contract-region
   "C-=" 'er/expand-region))
#+end_src

When in need of smart pairing, look no further than =smartparens=!

#+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :delight (smartparens-mode " sp")
  :custom
  (sp-base-key-bindings 'paredit)
  (sp-autoskip-closing-pair 'always)
  (sp-hybrid-kill-entire-symbol nil)
  :config
  (require 'smartparens-config)
  (sp-use-paredit-bindings))
#+end_src

With that, =rainbow-delimiters= is a great match:

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters)
#+end_src

This little add-on will highlight big cursor movements.

#+begin_src emacs-lisp :tangle yes
(use-package beacon
  :demand
  :delight
  :config
  (beacon-mode 1))
#+end_src

*** Indentation

I use =aggressive-indent= to keep my code indented as I type.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+end_src

Also =highligh-indent-guides= is very useful, as Emacs doesn't come with it out
of the box.

#+begin_src emacs-lisp :tangle yes
(use-package highlight-indent-guides
  :demand
  :disabled
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-delay 0.05)
  (highlight-indent-guides-auto-odd-face-perc 5)
  (highlight-indent-guides-auto-even-face-perc 5)
  (highlight-indent-guides-auto-character-face-perc 10)
  :hook
  (prog-mode-hook . highlight-indent-guides-mode))
#+end_src

*** Command evaluation

This package enhances the default =eval-expression= function.

#+begin_src emacs-lisp :tangle yes
(use-package eval-expr
  :demand
  :config
  (eval-expr-install))
#+end_src

*** Utilities

Random utilities that don't fit anywhere else.

**** =helpful=

=helpful= is a package that is overall an improvement over the default =help=
windows.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :general
  ("C-h f" 'helpful-callable)
  ("C-h v" 'helpful-variable)
  ("C-h k" 'helpful-key))
#+end_src

**** =dumb-jump=

=dumb-jump= is a package that allows you to jump to definition with minimal
setup (i.e. no TAG or RTAGS or etc.).

#+begin_src emacs-lisp :tangle yes
(use-package dumb-jump
  :general
  ("M-g o" 'dumb-jump-go-other-window)
  ("M-g j" 'dumb-jump-go))
#+end_src

**** =engine-mode=

=engine-mode= is a minor mode that allow you to easily make queries to the web
without leaving Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package engine-mode
  :config
  (defengine google
    "https://www.google.com/search?q="
    :keybinding "g")
  (engine-mode t))
#+end_src

**** =no-littering=

=no-littering= is a package that helps to maintain your =.emacs.d/= clean.

#+begin_src emacs-lisp :tangle yes
(use-package no-littering
  :demand)
#+end_src

**** =openwith=

=openwith= is a small and useful tool to set how you want to open your files
with Emacs. I use it to set the opener of pdfs in my Emacs, as well to other
diverse media files.

#+begin_src emacs-lisp :tangle yes
(use-package openwith
  :demand
  :custom
  (openwith-associations
   '(("\\.pdf\\'" "zathura" (file))
     ("\\.jpg\\'" "sxiv" (file))
     ("\\.svg\\'" "sxiv" (file))
     ("\\.jpeg\\'" "sxiv" (file))
     ("\\.bmp\\'" "sxiv" (file))
     ("\\.flac\\'" "mpv" (file))
     ("\\.mkv\\'" "mpv" (file))
     ("\\.mp3\\'" "mpv" (file))
     ("\\.mp4\\'" "mpv" (file))))
  :config
  (openwith-mode t))
#+end_src

**** =crux=

Which stands for...

#+begin_quote
A Collection of Ridiculously Useful eXtensions for Emacs.
#+end_quote

... yeah.

#+begin_src emacs-lisp :tangle yes
(use-package crux
  :demand
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   ;; file stuff
   "f s" 'crux-sudo-edit
   "f r" 'crux-rename-buffer-and-file
   "f d" 'crux-delete-buffer-and-file
   "f c" 'crux-find-user-custom-file
   "f i" 'crux-find-user-init-file)
  :config
  (crux-with-region-or-buffer indent-region)
  (crux-with-region-or-buffer untabify))
#+end_src

**** =page-break-lines=

To make pretty page breaks in your Emacs buffers:

#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines
  :delight
  :hook
  ((prog-mode-hook . page-break-lines-mode)
   (text-mode-hook . page-break-lines-mode))
  :custom
  (page-break-lines-max-width nil)
  (page-break-lines-char ?-)
  :custom-face
  (page-break-lines ((t :inherit font-lock-comment-face :bold t :italic nil))))
#+end_src

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides nice
support for a lot of packages and is very pleasant for the eyes.

#+begin_src emacs-lisp :tangle yes
(use-package gruvbox-theme
  :demand
  :config
  (load-theme 'gruvbox-dark-medium t))
#+end_src

* File modes

Here I'll store any package load and configurations related to languages and
file types.

I still need to add packages relating to these languages:

- [X] Org
- [X] C/C++
- [X] Python
- [ ] Scala
- [X] LaTeX (use-package-ensure-system-package texlive-most)
- [X] R
- [X] Shell
- [X] Makefile
- [ ] Dot (using Graphviz)
- [X] Lisp (duh)
- [X] PlantUML
- [ ] English (as in literal english)
- [X] CMake
- [X] Dockerfile
- [X] GMPL
- [X] Julia
- [X] Jupyter
- [ ] Coq (yes, I'm slowly turning into what I most hate)
- [X] CUDA (subset of C, yeah, but /still/)
- [X] Meson (the build system)
- [X] bspwm/sxhkd
- [X] systemd services/units
- [X] Rust

** Org

=org-mode= is probably *the* killer mode and one of the main reasons as to why
anyone should try Emacs. With it I also use =toc-org=, which is an useful way to
automatically maintain an updated table of contents of your =.org= file.

#+begin_src emacs-lisp :tangle yes
(use-package org
  :defer t
  :mode (("\\.org\\'" . org-mode))
  :ensure org-plus-contrib
  :ensure toc-org
  :delight
  (org-indent-mode nil org-indent)
  :hook
  ((org-mode-hook . toc-org-mode)
   (org-mode-hook . turn-on-auto-fill)
   (org-mode-hook . yas-minor-mode)
   (org-mode-hook . display-line-numbers-mode)
   (org-babel-after-execute-hook . org-redisplay-inline-images))
  :custom
  (org-return-follows-link t)
  ;; the following used to be '(latex script entities)
  (org-highlight-latex-and-related nil)
  (org-hide-leading-stars t)
  (org-support-shift-select nil)
  (org-link-descriptive t)
  (org-log-done t)
  (org-directory "~/org/")
  (org-cycle-emulate-tab 'exc-hl-bol)
  (org-startup-indented t)
  (org-modules
   (append org-modules '(org-tempo org-inlinetask)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   "t" 'org-todo ; mark a TODO item as DONE
   "$" 'org-end-of-line ; smarter behaviour on headlines etc.
   "0" 'org-beginning-of-line ; ditto
   "-" 'org-ctrl-c-minus ; change bullet style
   "<" 'org-metaleft ; outdent
   ">" 'org-metaright ; indent
   "C-i" 'org-toggle-inline-images
   "C-j" 'outline-next-visible-heading
   "C-k" 'outline-previous-visible-heading
   "C-S-k" 'outline-up-heading
   "<tab>" 'outline-toggle-children
   "<backtab>" 'org-global-cycle
   "<return>" 'org-open-at-point)
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "l t" 'org-set-tags-command
   "l l" 'org-toggle-link-display
   "l a" 'org-attach)
  (:states 'insert
   :keymaps 'org-mode-map
   "<tab>" 'org-cycle))
#+end_src

*** Export

Configurations relating all the numerous org exporters.

#+begin_src emacs-lisp :tangle yes
(use-package ox
  :ensure nil
  :defer t
  :after org
  :ensure htmlize
  :preface
  (defun org-export-output-file-name-modified (orig-fun extension &optional subtreep pub-dir)
    "Collect all generated files from an export in a neat folder."
    (unless pub-dir
      (setq pub-dir "org-exports")
      (unless (file-directory-p pub-dir)
        (make-directory pub-dir)))
    (apply orig-fun extension subtreep pub-dir nil))
  :init
  (advice-add 'org-export-output-file-name :around #'org-export-output-file-name-modified)
  :custom
  (org-export-backends '(latex html ascii))
  (org-export-allow-bind-keywords t)
  (org-export-with-latex t)
  (org-export-babel-evaluate t)
  (org-export-in-background nil)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "l e" 'org-export-dispatch))
#+end_src

**** Extras

=ox-extra= defines a couple of cool extras, like =ignore-headlines=!

#+begin_src emacs-lisp :tangle yes
(use-package ox-extra
  :ensure nil
  :after ox
  :hook
  (org-export-filter-parse-tree-functions . org-export-ignore-headlines))
#+end_src

**** LaTeX

Configurations to the LaTeX org exporter.

#+begin_src emacs-lisp :tangle yes
(use-package ox-latex
  :ensure nil
  :after ox
  :custom
  (org-latex-image-default-width "1\\linewidth")
  (org-latex-packages-alist
   '(("cache=false,outputdir=org-exports" "minted")
     ("T1" "fontenc")
     ("utf8" "inputenx")
     ("" "placeins")))
  (org-latex-listings 'minted)
  (org-latex-minted-options
   '(("breaklines")
     ("breakafter" "d")
     ("linenos" "true")
     ("xleftmargin" "\\parindent")))
  (org-latex-pdf-process
   '("latexmk -pdflatex='pdflatex -shell-escape -interaction=nonstopmode' -f -pdf -outdir=%o %f"))
  :config
  (add-to-list 'org-latex-classes
               '("iiufrgs"
                 "\\documentclass{iiufrgs}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("newlfm"
                 "\\documentclass{newlfm}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
  (add-to-list 'org-latex-classes
               '("IEEEtran"
                 "\\documentclass{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

**** Hugo

To the oh-so-pretty Hugo markdown format!

#+begin_src emacs-lisp :tangle yes
(use-package ox-hugo
  :after ox)
#+end_src

**** Twitter Bootstrap HTML

It's very pretty oh-kay?

#+begin_src emacs-lisp :tangle yes
(use-package ox-twbs
  :after ox)
#+end_src

*** Babel

Now, some configurations relating org-babel and its magic source blocks.

#+begin_src emacs-lisp :tangle yes
(use-package ob
  :ensure nil
  :defer t
  :after org
  :ensure ob-async
  :delight
  (org-src-mode)
  :preface
  (defun org-babel-tangle-block ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-babel-tangle)))
  :custom
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-src-preserve-identation t)
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-babel-default-header-args
   '((:async . "yes")
     (:session . "none")
     (:results . "value replace")
     (:exports . "code")
     (:cache . "none")
     (:noweb . "no")
     (:hlines . "no")
     (:tangle . "no")))
  (ob-async-no-async-languages-alist
   '("ipython" "jupyter-julia" "jupyter-python"))
  (org-babel-load-languages
   '((shell . t)
     (python . t)
     (makefile . t)
     (R . t)
     (C . t)
     (ruby . t)
     (ditaa . t)
     (dot . t)
     (octave . t)
     (sqlite . t)
     (perl . t)
     (screen . t)
     (plantuml . t)
     ;; (julia . t)
     (latex . t)
     (jupyter . t)
     (lilypond . t)
     (emacs-lisp . t)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "l x" 'org-babel-execute-buffer
   "l z" 'org-babel-tangle-block
   "l Z" 'org-babel-tangle)
  :config
  (require 'ob-async))
#+end_src

*** Journal

=org-journal= is a powerful tool to journal your day.

#+begin_src emacs-lisp :tangle yes
(use-package org-journal
  :defer t
  :after org
  :custom
  (org-journal-dir (format-time-string "~/OneDrive/Documentos/Journal/%Y/"))
  (org-journal-file-format "%Y%m%d")
  (org-journal-date-format "%e %b %Y (%A)")
  (org-journal-time-format "")
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "m j" 'org-journal-new-entry))
#+end_src

** CC-Mode

Here I set some defaults I appreciate for cc-mode (the mode for all c-like
languages):

#+begin_src emacs-lisp :tangle yes
(use-package cc-mode
  :defer t
  :ensure nil
  :ensure highlight-doxygen
  :hook
  ((c-mode-common-hook . highlight-doxygen-mode)
   (c-mode-common-hook . rainbow-delimiters-mode)
   (c-mode-common-hook . aggressive-indent-mode))
  :custom
  (c-default-style
   '((java-mode . "java")
     (awk-mode . "awk")
     (other . "linux")))
  (c-basic-offset 4)
  (c-offsets-alist '((substatement-open . 0))))
#+end_src

*** C/C++

Better C++ font lock:

#+begin_src emacs-lisp :tangle yes
(use-package modern-cpp-font-lock
  :defer t
  :delight
  (modern-c++-font-lock-mode)
  :hook
  (c++-mode-hook . modern-c++-font-lock-mode))
#+end_src

LSP integration:

#+begin_src emacs-lisp :tangle yes
(use-package ccls
  :defer t
  :hook
  ((c-mode-hook c++-mode-hook objc-mode-hook cuda-mode-hook) . (lambda () (require 'ccls) (lsp))))
#+end_src

In the department of code formatting, =clang-format= is a lovely tool that can
really be of great use while editing C and C++ code.

#+begin_src emacs-lisp :tangle yes
(use-package clang-format
  :defer t
  :ensure-system-package clang
  :preface
  (defun cc-format-on-save-hook ()
    (when c-buffer-is-cc-mode
      (clang-format-buffer)))
  :general
  (:states '(normal visual)
   :keymaps 'c-mode-base-map
   :prefix hcps/leader-key
   "i" 'clang-format-region)
  :custom
  (clang-format-style "webkit")
  :config
  (crux-with-region-or-buffer clang-format-region))
#+end_src

*** CUDA

Suporting CUDA syntax per-se is kinda easy, as it's a subset of C after all. The
thing is I want proper syntax highlighting for all those special keywords and
types that CUDA introduces. So, let's install =cuda-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package cuda-mode
  :defer t
  :mode "\\.cu\\'"
  :commands cuda
  :hook
  ((cuda-mode-hook . (lambda () (run-hooks 'prog-mode-hook)))
   (cuda-mode-hook . modern-c++-font-lock-mode))
  :custom
  (cuda-font-lock-keywords 'cuda-font-lock-keywords-3))
#+end_src

It falls back on =c++-mode= by default, so we are safe here.

** R

For R you pretty much /need/ the =ess= package, i.e. /Emacs Speaks Statistics/.
It provides you with everything you need from R.

#+begin_src emacs-lisp :tangle yes
(use-package ess-r-mode
  :defer t
  ;; as we gotta add the extra lsp client
  :after lsp-mode
  :ensure ess
  :commands R
  :hook
  ((ess-r-mode-hook . aggressive-indent-mode)
   (ess-r-mode-hook . lsp))
  :preface
  (defcustom existing-remote-session nil
    "Defines the existence of a remote R session."
    :type 'boolean
    :safe #'booleanp
    :group 'R)
  (defun hcps/insert-r-pipe ()
    "Lets us insert the magrittr piping operator %>% in R"
    (interactive)
    (just-one-space 1)
    (insert "%>%")
    (reindent-then-newline-and-indent))
  (defun hcps/make-remote-r-session (BUFFER)
    (interactive (list (call-interactively 'ssh-connect-remote)))
    (with-current-buffer (buffer-name BUFFER)
      (goto-char (point-max))
      (insert "R")
      (comint-send-input))
    (setq existing-remote-session t))
  (defun hcps/use-remote-r-session ()
    (interactive)
    (if (equal ssh-current-server nil)
        (call-interactively 'hcps/make-remote-r-session))
    (if (not existing-remote-session)
        (hcps/make-remote-r-session (get-buffer-create ssh-current-server)))
    ssh-current-server)
  :general
  (:states 'insert
   :keymaps 'ess-r-mode-map
   "M-RET" 'hcps/insert-r-pipe)
  :custom
  (ess-auto-width 'frame)
  (ess-style 'RStudio)
  (lsp-register-client
   (make-lsp-client :new-connection
     (lsp-stdio-connection '("R" "--slave" "-e" "languageserver::run()"))
     :major-modes '(ess-r-mode inferior-ess-r-mode)
     :server-id 'lsp-R)))
#+end_src

** Shell

As for shell-scripting:

#+begin_src emacs-lisp :tangle yes
(use-package sh-script
  :defer t
  :preface
  (defvar more-sh-utilities
    '("addbib" "apropos" "ar" "at" "awk" "banner" "basename" "batch" "biff"
      "cal" "calendar" "cancel" "cat" "cb" "cc" "checkeq" "checknr" "chgrp"
      "chmod" "chown" "chroot" "clear" "cmp" "colcrt" "comm" "compress" "cp"
      "cpio" "cpp" "csh" "ctags" "cut" "date" "dbx" "dd" "deroff" "df" "diff"
      "dirname" "du" "e" "ed" "edit" "env" "eqn" "ex" "expand" "expr" "file"
      "find" "finger" "fmt" "fold" "ftp" "git" "gprof" "grep" "groups" "head"
      "hostname" "indent" "install" "join" "last" "ld" "leave" "less" "lex"
      "lint" "ln" "login" "look" "lookbib" "lorder" "lp" "lpq" "lpr" "lprm"
      "ls" "mail" "make" "man" "mesg" "mkdir" "mkfifo" "mkstr" "more" "mv"
      "neqn" "nice" "nm" "nroff" "od" "page" "passwd" "paste" "pgrep" "pkill"
      "pr" "prof" "ps" "ranlib" "rcp" "rev" "rlogin" "rm" "rmdir" "roffbib"
      "rsh" "rup" "ruptime" "rusers" "rwall" "rwho" "sccs" "script" "sed" "seq"
      "sh" "size" "sleep" "sort" "sortbib" "spell" "split" "strings" "strip"
      "stty" "su" "sudo" "tabs" "tac" "tail" "talk" "tar" "tbl" "tee" "telnet"
      "tftp" "time" "timeout" "touch" "tr" "troff" "tsort" "tty" "ul" "uname"
      "uncompress" "unexpand" "uniq" "units" "unlink" "uptime" "users" "uucp"
      "vacation" "vedit" "vi" "view" "w" "wall" "wc" "whatis" "whereis" "which"
      "who" "whoami" "write" "xargs" "xstr" "yacc" "yes" "zcat" "gawk")
    "A list of common shell commands to be fontified especially in `sh-mode'.")
  (defvar more-sh-builtins
    '("alias" "bg" "bind" "break" "builtin" "caller" "cd"
      "command" "compgen" "complete" "compopt" "continue" "declare" "dirs"
      "disown" "echo" "enable" "eval" "exec" "exit" "export" "false" "fc" "fg"
      "getopts" "hash" "help" "history" "jobs" "kill" "let" "local" "logout"
      "mapfile" "popd" "printf" "pushd" "pwd" "read" "readarray" "readonly"
      "return" "set" "shift" "shopt" "source" "suspend" "test" "times" "trap"
      "true" "type" "typeset" "ulimit" "umask" "unalias" "unset" "wait")
    "Actual list of common keywords and builtins in `sh-mode'.")
  (defun zsh-prezto-files ()
    "Function to ease switching to zsh when dealing with a zsh file."
    (if (and buffer-file-name
             (member (file-name-nondirectory buffer-file-name) prezto-files))
        (sh-set-shell "zsh")))
  (defun sh--match-variables-in-quotes (limit)
    "Search for variables in double-quoted strings bounded by LIMIT."
    (with-syntax-table sh-mode-syntax-table
      (let (res)
        (while (and
                (setq res (re-search-forward
                           "[^\\]\\(\\$\\)\\({.+?}\\|\\<[a-zA-Z0-9_]+\\|[@*#!]\\)"
                           limit t))
                (not (eq (nth 3 (syntax-ppss)) ?\"))))
        res)))
  (defun sh--match-command-subst-in-quotes (limit)
    "Search for a command in double-quoted strings bounded by LIMIT."
    (with-syntax-table sh-mode-syntax-table
      (let (res)
        (while (and
                (setq res (re-search-forward "[^\\]\\(\\$(.+?)\\|`.+?`\\)"
                                             limit t))
                (not (eq (nth 3 (syntax-ppss)) ?\"))))
        res)))
  :custom
  (prezto-files '("zlogin" "zlogin" "zlogout" "zpreztorc" "zprofile" "zshenv" "zshrc"))
  :hook
  ((sh-mode-hook . zsh-prezto-files)
   (sh-mode-hook . aggressive-indent-mode)
   (sh-mode-hook . smartparens-mode)
   (sh-mode-hook . rainbow-delimiters-mode))
  :config
  (font-lock-add-keywords
   'sh-mode `((sh--match-variables-in-quotes
               (1 'default prepend)
               (2 'font-lock-variable-name-face prepend))
              (sh--match-command-subst-in-quotes
               (0 'sh-quoted-exec prepend))
              (,(regexp-opt more-sh-utilities 'words)
               (0 'sh-quoted-exec append))
              (,(regexp-opt more-sh-builtins 'words)
               (0 'font-lock-builtin-face append))))
  (add-to-list 'sh-imenu-generic-expression
               '(sh (nil "^\\s-*function\\s-+\\([[:alpha:]_-][[:alnum:]_-]*\\)\\s-*\\(?:()\\)?" 1)
                    (nil "^\\s-*\\([[:alpha:]_-][[:alnum:]_-]*\\)\\s-*()" 1))))
#+end_src

For =shell= completion I use =bash-complete=, which auto completes several
=bash= functions.

#+begin_src emacs-lisp :tangle yes
(use-package bash-completion
  :hook
  (shell-dynamic-complete-funtions-hook . bash-completion-dynamic-complete))
#+end_src

** Makefile

In Makefile files we have a special case: it /needs/ tabulators to work. So,
we'll set that up.

#+begin_src emacs-lisp :tangle yes
(use-package make-mode
  :ensure nil
  :preface
  (defun makefile-mode-defaults ()
    "Turn on tabs only for make-mode."
    (whitespace-toggle-options '(tabs))
    (setq-local indent-tabs-mode t))
  :hook
  ((makefile-mode-hook . makefile-mode-defaults)
   (makefile-mode-hook . smartparens-strict-mode)
   (makefile-mode-hook . rainbow-delimiters-mode)))
#+end_src

** PlantUML

/PlantUML/ is a graph language that describes loads of different diagram types,
mainly focusing on /UML/, of course.

#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
  :defer t
  :mode "\\.plantuml\\'"
  :interpreter "plantuml")
#+end_src

** Lisp

Fix for the annoying keyword default indentation:

#+begin_src emacs-lisp :tangle yes
(defun fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
,* `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+end_src

and the necessary hook:

#+begin_src emacs-lisp :tangle yes
(defun lisp-coding-hook ()
  (setq-local lisp-indent-function #'fuco1/lisp-indent-function)
  (highlight-numbers-mode 1)
  (smartparens-strict-mode 1)
  (aggressive-indent-mode 1)
  (rainbow-delimiters-mode 1))

(add-hook 'lisp-mode-hook #'lisp-coding-hook)
#+end_src

** Elisp

Emacs version!

#+begin_src emacs-lisp :tangle yes
(use-package elisp-mode
  :defer t
  :ensure nil
  :ensure elisp-slime-nav
  :preface
  (defun recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (when (and
           (string-prefix-p prelude-dir (file-truename buffer-file-name))
           (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (emacs-lisp-byte-compile)))
  :hook
  ((after-save-hook . recompile-elc-on-save)
   (emacs-lisp-mode-hook . lisp-coding-hook)))
#+end_src

** English

Something I found out while scrolling /Github/ is the =mw-thesaurus= package,
which provides a nice interface for the Merriam-Webster thesaurus.

#+begin_src emacs-lisp :tangle yes
(use-package mw-thesaurus
  :defer t
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   "T" 'mw-thesaurus-lookup-at-point))
#+end_src

** Python

#+begin_quote
Elpy is an Emacs package to bring powerful Python editing to Emacs. It combines
and configures a number of other packages, both written in Emacs Lisp as well as
Python.
#+end_quote

#+begin_src emacs-lisp :tangle yes
(use-package elpy
  :defer t
  :commands elpy-enable
  :init
  (advice-add 'python-mode :after 'elpy-enable))
#+end_src

** CMake

Just as a bonus, this package helps me to read CMake code. As CMake is very
simple, each word carries a load of meaning and importance. This little mode
colors them accordingly.

#+begin_src emacs-lisp :tangle yes
(use-package cmake-font-lock
  :defer t
  :commands cmake-font-lock-activate
  :hook
  ((cmake-mode-hook . smartparens-strict-mode)
   (cmake-mode-hook . rainbow-delimiters-mode)
   (cmake-mode-hook . highlight-numbers-mode))
  :init
  (advice-add 'cmake-mode :after 'cmake-font-lock-activate))
#+end_src

** Dockerfile

=dockerfile-mode= adds support to syntax highlighting and to build the image
directly from the buffer using =C-c C-b=.

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :defer t
  :ensure docker-compose-mode
  :mode "Dockerfile\\'")
#+end_src

** GMPL

So I have syntax highlighting while editing GLPK files.

#+begin_src emacs-lisp :tangle yes
(use-package gmpl-mode
  :defer t
  :mode "\\.mod\\'")
#+end_src

** Julia

Packages to write Julia source code in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-julia
  :defer t
  :custom
  (lsp-julia-default-environment "~/.julia/environments/v1.2")
  (lsp-julia-package-dir nil))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package julia-mode
  :defer t
  :after lsp-julia
  :ensure julia-repl
  :mode "\\.jl\\'"
  :hook
  ((julia-mode-hook . julia-repl-mode)
   (julia-mode-hook . lsp)
   (julia-mode-hook . highlight-numbers-mode))
  :custom
  (inferior-julia-program-name "/usr/bin/julia"))
#+end_src

** Jupyter

An interface to communicate with Jupyter kernels in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package jupyter
  :defer t
  :ensure zmq
  :ensure websocket
  :custom
  (org-babel-default-header-args:jupyter-julia
   '((:eval . "no-export")
     (:exports . "both")
     (:kernel . "julia-1.2")))
  (org-babel-default-header-args:jupyter-python
   '((:eval . "no-export")
     (:exports . "both")
     (:kernel . "python3"))))
#+end_src

** LaTeX

Let's start with some basic =auctex= editing so it starts the way I want (as
theoretically it should come bundled with Emacs).

#+begin_src emacs-lisp :tangle yes
(use-package auctex
  :defer t
  :ensure company-auctex
  :ensure company-reftex
  :mode (("\\.tex\\'" . latex-mode))
  :hook
  ((latex-mode-hook . turn-on-reftex)
   (latex-mode-hook . company-auctex-init)
   (tex-mode-hook . turn-on-auto-fill)
   (tex-mode-hook . yas-minor-mode)
   (latex-mode-hook . turn-on-auto-fill)
   (latex-mode-hook . rainbow-delimiters-mode)
   (latex-mode-hook . turn-on-smartparens-mode))
  :custom
  (TeX-auto-save t)
  (TeX-parse-self t)
  (TeX-save-query nil)
  (TeX-source-correlate-method 'synctex)
  (TeX-master nil)
  (reftex-plug-into-AUCTeX t)
  (reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))
  :config
  (add-to-list 'company-backends 'company-math-symbols-latex)
  (add-to-list 'company-backends 'company-latex-commands))
#+end_src

So, for my LaTeX config I'll mainly use =latexmk= as it's way simpler to use.

#+begin_src emacs-lisp :tangle yes
(use-package auctex-latexmk
  :after (tex auctex)
  :preface
  (defun hcps/set-latexmk-as-default ()
    (add-to-list
     'TeX-expand-list
     '("%(-PDF)"
       (lambda ()
         (cond ((string-match "TeX-engine: pdftex" (buffer-string)) "-pdf")
               ((string-match "TeX-engine: luatex" (buffer-string)) "-pdflatex=lualatex -pdf")
               ((string-match "TeX-engine: xetex" (buffer-string)) "-pdflatex=xelatex -pdf")
               (t "-dvi -pdfps")))))
    (add-to-list
     'TeX-command-list
     '("Latexmk" "latexmk %(-PDF) -synctex=1 %s"
       TeX-run-TeX nil t
       :help "Run Latexmk on file to build everything."))
    (setq TeX-command-default "Latexmk"))
  :init
  (auctex-latexmk-setup)
  :hook
  ((tex-mode-hook . hcps/set-latexmk-as-default)
   (latex-mode-hook . hcps/set-latexmk-as-default))
  :custom
  (auctex-latexmk-inherit-TeX-PDF-mode t))
#+end_src

The hook stuff is because all =TeX= get defined when the mode starts, so we need
to redefine them then.

** Coq

Not set up, but when I get to it:

- proof-general
- company-coq-mode
- hrs config!

** Meson

Syntax support for the Meson build system DSL (which is based from Python).

#+begin_src emacs-lisp :tangle yes
(use-package meson-mode
  :defer t
  :mode "meson.build\\'"
  :commands meson
  :hook
  ((meson-mode-hook . (lambda () (run-hooks 'prog-mode-hook)))
   (meson-mode-hook . company-mode)))
#+end_src

** bspwm/sxhkd

Derives from =conf-mode[space]=. Got it from
[[https://notabug.org/arkhan/emacs-bspwm][here]].

#+begin_src emacs-lisp :tangle yes
(use-package bspwm
  :ensure nil
  :load-path "vendor/"
  :mode
  (("sxhkdrc\\'" . bspwm-config-mode)
   ("bspwmrc\\'" . bspwm-config-mode))
  :hook
  (bspwm-config-mode-hook . page-break-lines-mode))
#+end_src

*** File

In the flesh! I'll tangle it to the =vendor= directory.

#+begin_src emacs-lisp :tangle vendor/bspwm.el
(defface i3wm-action-face
  '((t :inherit font-lock-function-name-face))
  "Face for actions or verbs like 'set', 'bindsym', 'move' etc.")

(defface bspwm-modifiers-face
  '((t :inherit font-lock-type-face))
  "Face for modifiers like '--release' and '--no-startup-id'.")

(defface bspwm-numbers-face
  '((t :inherit font-lock-constant-face))
  "Face for numbers.")

(defface bspwm-value-assign-face
  '((t :inherit font-lock-variable-name-face))
  "Face value assignments - e.g. the 'y' in 'set x y'.")

(defface bspwm-bindsym-key-face
  '((t :inherit font-lock-variable-name-face))
  "Face for the keys used in bindsym assignments.")

(defface bspwm-variable-face
  '((t :inherit font-lock-constant-face))
  "Face for $variables.")

(defface bspwm-unit-face
  '((t :inherit font-lock-type-face))
  "Face for units like 'px', 'ms', 'ppt'.")

(defface bspwm-for-window-predictate-face
  '((t :inherit font-lock-builtin-face))
  "Face for the predicates in for_window assignments -
the 'x' in 'for_window [x=y]'.")

(defface bspwm-exec-face
  '((t :inherit font-lock-builtin-face))
  "Face for the text inside an exec statement.")

(defface bspwm-modifier-face
  '((t :inherit font-lock-type-face))
  "Face for action modifiers like 'floating', 'tabbed', 'sticky' or 'current'.")

(defface bspwm-keyword-face
  '((t :inherit font-lock-keyword-face))
  "Face for fixed keywords like 'workspace', 'mode', 'position' or 'fullscreen'.")

(defface bspwm-constant-face
  '((t :inherit font-lock-constant-face))
  "Face for constant values like 'top', 'invisble', 'yes' or 'no'.")

(defface bspwm-block-opener-face
  '((t :inherit font-lock-type-face))
  "Face for the names of items denoting blocks like 'bar {}' and 'colors {}'.")

(defface bspwm-string-face
  '((t :inherit font-lock-string-face))
  "Face for text enclosed in quotes.")

(defface bspwm-comment-face
  '((t :inherit font-lock-comment-face))
  "Face for comments.")

(defface bspwm-operator-face
  '((t :inherit font-lock-builtin-face))
  "Face for various operators like '&&', '+', and '|'.")

(define-derived-mode bspwm-config-mode conf-space-mode "bspwm Config")

(font-lock-add-keywords
 'bspwm-config-mode
 `(

   ;; Actions
   ( ,(rx
       (seq
        symbol-start
        (or
         "Left")
        symbol-end))
     0
     'bspwm-action-face)

   ;; --modifiers
   ( ,(rx (seq
           symbol-start
           (or "--no-startup-id" "--release")
           symbol-end))
     0
     'bspwm-modifiers-face)

   ;; numbers
   ( ,(rx (seq
           symbol-start
           (? (or "-" "+"))
           (group-n 1 (1+ num))))
     1
     'bspwm-numbers-face)

   ;; value part of `set x y'
   ( ,(rx (seq
           bol
           "set"
           (? "_from_resource")
           (1+ space)
           "$" (1+ (or "_" "-" word))
           (1+ space)
           (group-n 1 symbol-start (1+ (or "-" "_" alnum)) symbol-end)))
     1
     'bspwm-value-assign-face
     t)

   ;; Keys used in `bindsym'
   ( ,(rx (or
           (seq "bindsym" (1+ space) (? (seq "--release" (1+ space))))
           "+")
          (group-n 1 (1+ (or word "_")))
          )
     1
     'bspwm-bindsym-key-face
     t)

   ;; Variables
   ( ,(rx (seq
           symbol-start
           "$"
           (1+ (or "-" "_" word))))
     0
     'bspwm-variable-face
     t)

   ;; units of measurement
   ( ,(rx (seq
           (? (1+ num))
           (group-n 1 (or "px" "pixel" "ms" "ppt"))
           symbol-end))
     1
     'bspwm-unit-face)

   ;; `for_window' predicates
   ( ,(rx (or
           "class"
           "title"
           "instance"
           "window_role"
           "window_type"))
     0
     'bspwm-for-window-predictate-face)

   ;; Command part of an `exec' statement
   ( ,(rx (seq
           "exec"
           (? "_always")
           (1+ space)
           (? "--" (1+ (or "-" word)) (1+ space))
           (group-n 1 (1+ any))
           eol))
     1
     'bspwm-exec-face
     t)

   ;; Action modifiers
   ( ,(rx (seq
           (or
            "tiled")
           symbol-end))
     0
     'bspwm-modifier-face)

   ;; Keywords
   ( ,(rx (seq
           bow
           (or
            "super"
            "hyper"
            "meta"
            "alt"
            "control"
            "ctrl"
            "shift"
            "mode_switch"
            "lock"
            "mod1"
            "mod2"
            "mod3"
            "mod4"
            "mod5")
           eow
           ))
     0
     'bspwm-keyword-face)

   ;; single letter modifiers
   ( ,(rx (seq
           symbol-start
           (or "h" "x" "v")
           symbol-end))
     0
     'bspwm-unit-face)

   ;; Constant values
   ( ,(rx (or
           "bspc"))
     0
     'bspwm-constant-face)

   ;; Values assignments after a `:'
   ( ,(rx (seq
           (1+ nonl)
           ":"
           (group-n 1 (1+ (not (any "\n" "\""))))))
     1
     'bspwm-value-assign-face
     t)

   ;; Block openers
   ( ,(rx (seq
           symbol-start
           (group-n 1 (1+ (or "_" "-" word)))
           symbol-end
           (1+ space)
           "{"))
     1
     'bspwm-block-opener-face)

   ;; + = | : etc
   ( ,(rx (or "+" "&&" "-" "=" "|" ":" "," ";"))
     0
     'bspwm-operator-face)

   ;; commands with more or less arbitrary values
   ( ,(rx (seq
           (or "tray_output" "status_command" "i3bar_command")
           (1+ space)
           (group-n 1 (1+ any) eol)))
     1
     'bspwm-value-assign-face
     t)

   ;; i3-msg, which needs to overwrite the `exec' highlight
   ( ,(rx (seq
           symbol-start
           "i3-msg"
           symbol-end))
     0
     'bspwm-action-face
     t)

   ;; client.*color* assigments
   ( ,(rx (seq
           symbol-start
           (1+ (or "_" word))
           "."
           (1+ (or "_"  word))
           symbol-end))
     0
     'bspwm-keyword-face
     t)

   ;; enforce strings again
   ( ,(rx (seq
           "\"" (1+ (not (any "\""))) "\""))
     0
     'bspwm-string-face
     t)

   ;; enforce comments again
   ( ,(rx (seq
           "#"
           (? (1+ nonl))))
     0
     'bspwm-comment-face
     t)))

(provide 'bspwm-config-mode)
#+end_src

** systemd services

Just a little hook to start the desired =conf-mode= when we open these files.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.service\\'" . conf-mode))
#+end_src

** Rust

The newest greatest compiled language!

#+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :defer t
  :demand cargo
  :demand flycheck-rust
  :hook
  ((rust-mode-hook . lsp)
   (rust-mode-hook . cargo-minor-mode)
   (rust-mode-hook . subword-mode)
   (rust-mode-hook . smartparens-strict-mode)
   (rust-mode-hook . rainbow-delimiters-mode)
   (rust-mode-hook . highlight-numbers-mode))
  :custom
  (rust-format-on-save t)
  (rust-indent-method-chain t))
#+end_src

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff you
coded yourself.

To-do:

- [X] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Functions

Some very useful functions I got from other people or that I coded myself.

*** Fetching text

To get the current selected text without newlines.

#+begin_src emacs-lisp :tangle yes
(defun hcps/get-selected-text (start end)
  (interactive "r")
  (kill-new
   (replace-regexp-in-string
    "\n" " "
    (if (use-region-p)
        (regionp (buffer-substring start end))))))
#+end_src

*** Date

Insert the current date.

#+begin_src emacs-lisp
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+end_src

*** Opening things

Like the title says...

#+begin_src emacs-lisp :tangle yes
(defun hcps/open-scratch ()
  "Switch to the *scratch* buffer whenever you are."
  (interactive)
  (switch-to-buffer "*scratch*" nil t))
#+end_src

** Keybindings

Here I'll define some of my personal keybindings, which means "keybindings not
related to some package configured in the sections above"!

#+begin_src emacs-lisp :tangle yes
(general-def
  "C-x k" 'kill-this-buffer
  "C-c x" 'hcps/date-iso
  "<f9>" 'hcps/get-selected-text
  "M--" 'text-scale-decrease
  "M-+" 'text-scale-increase)

(general-def
  :states '(normal visual)
  "C-S-h" 'previous-buffer
  "C-S-l" 'next-buffer)

(general-def
  :states '(normal visual)
  :prefix hcps/leader-key
  "B" 'ibuffer
  "s" 'save-buffer
  "k" 'kill-this-buffer
  "i" 'indent-region
  "c" 'comment-dwim
  "f n" 'hcps/open-scratch
  "w k" 'delete-window
  "w v" 'split-window-vertically
  "w h" 'split-window-horizontally)
#+end_src
