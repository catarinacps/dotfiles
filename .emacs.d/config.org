#+title: My Emacs configuration file
#+author: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br

These configurations represent my preferred version of Emacs, one that uses =evil=
everywhere it can and one that tries to be as minimalist as +I want+ possible.
Beware that this configuration uses a cutting-edge version of Emacs, so YMMV.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]
- [[https://github.com/hlissner][The doom-emacs guy]]

* Table of contents                                                     :TOC:
- [[Introduction][Introduction]]
  - [[What packages you can find here][What packages you can find here]]
  - [[=use-package=][=use-package=]]
    - [[:after][:after]]
    - [[:defer][:defer]]
    - [[:demand][:demand]]
    - [[:init][:init]]
    - [[:config][:config]]
- [[Personal][Personal]]
  - [[Information][Information]]
  - [[Functions and Macros][Functions and Macros]]
    - [[Fetching text][Fetching text]]
    - [[Date][Date]]
    - [[One-time advice][One-time advice]]
    - [[Automatic byte-compile][Automatic byte-compile]]
    - [[Auto-removing hook][Auto-removing hook]]
    - [[Trim functions][Trim functions]]
    - [[Fontification of sub-blocks][Fontification of sub-blocks]]
    - [[Modeline][Modeline]]
    - [[Move lines][Move lines]]
    - [[Fixes][Fixes]]
  - [[Definitions and preferences][Definitions and preferences]]
    - [[Paths and =defconst=][Paths and =defconst=]]
    - [[GUI elements][GUI elements]]
    - [[Text][Text]]
    - [[Mode line][Mode line]]
    - [[Line numbering and scrolling][Line numbering and scrolling]]
    - [[Randoms][Randoms]]
    - [[Custom variables][Custom variables]]
- [[Package configuration][Package configuration]]
  - [[Setting-up][Setting-up]]
  - [[Support][Support]]
    - [[=use-package=][=use-package=]]
    - [[=general=][=general=]]
    - [[=delight=][=delight=]]
    - [[=no-littering=][=no-littering=]]
    - [[=hide-mode-line=][=hide-mode-line=]]
    - [[=mode-local=][=mode-local=]]
    - [[=hydra=][=hydra=]]
  - [[Built-in][Built-in]]
    - [[=package=][=package=]]
    - [[=whitespace=][=whitespace=]]
    - [[=compile=][=compile=]]
    - [[=tramp=][=tramp=]]
    - [[=ansi-color=][=ansi-color=]]
    - [[=windmove=][=windmove=]]
    - [[=midnight=][=midnight=]]
    - [[=uniquify=][=uniquify=]]
    - [[=recentf=][=recentf=]]
    - [[=ibuffer=][=ibuffer=]]
    - [[=autoinsert=][=autoinsert=]]
    - [[=comint=][=comint=]]
    - [[=paren=][=paren=]]
    - [[=elec-pair=][=elec-pair=]]
    - [[=electric=][=electric=]]
    - [[=xref=][=xref=]]
    - [[=gdb=][=gdb=]]
    - [[=project=][=project=]]
    - [[=files=][=files=]]
    - [[=smerge-mode=][=smerge-mode=]]
    - [[=sendmail=][=sendmail=]]
  - [[Extensions][Extensions]]
    - [[=evil=][=evil=]]
    - [[=smart-mode-line=][=smart-mode-line=]]
    - [[=orderless=][=orderless=]]
    - [[=vertico=][=vertico=]]
    - [[=corfu=][=corfu=]]
    - [[=company=][=company=]]
    - [[=consult=][=consult=]]
    - [[=marginalia=][=marginalia=]]
    - [[=undo-tree=][=undo-tree=]]
    - [[=dashboard=][=dashboard=]]
    - [[=treemacs=][=treemacs=]]
    - [[=exec-path-from-shell=][=exec-path-from-shell=]]
    - [[=anzu=][=anzu=]]
    - [[=deadgrep=][=deadgrep=]]
    - [[=link-hint=][=link-hint=]]
    - [[=avy=][=avy=]]
    - [[=which-key=][=which-key=]]
    - [[=lsp-mode=][=lsp-mode=]]
    - [[=flycheck=][=flycheck=]]
    - [[=eglot=][=eglot=]]
    - [[=highlight-numbers=][=highlight-numbers=]]
    - [[=highlight-escape-sequences=][=highlight-escape-sequences=]]
    - [[=flyspell=][=flyspell=]]
    - [[=diff-hl=][=diff-hl=]]
    - [[=ace-window=][=ace-window=]]
    - [[=super-save=][=super-save=]]
    - [[=yasnippet=][=yasnippet=]]
    - [[=vimish-fold=][=vimish-fold=]]
    - [[=projectile=][=projectile=]]
    - [[=magit=][=magit=]]
    - [[=git-timemachine=][=git-timemachine=]]
    - [[=expand-region=][=expand-region=]]
    - [[=smartparens=][=smartparens=]]
    - [[=rainbow-delimiters=][=rainbow-delimiters=]]
    - [[=beacon=][=beacon=]]
    - [[=aggressive-indent=][=aggressive-indent=]]
    - [[=highligh-indent-guides=][=highligh-indent-guides=]]
    - [[=helpful=][=helpful=]]
    - [[=engine-mode=][=engine-mode=]]
    - [[=openwith=][=openwith=]]
    - [[=crux=][=crux=]]
    - [[=page-break-lines=][=page-break-lines=]]
    - [[=writeroom-mode=][=writeroom-mode=]]
    - [[=ssh=][=ssh=]]
    - [[=ligature.el=][=ligature.el=]]
    - [[=emacs-vterm=][=emacs-vterm=]]
    - [[=mixed-pitch-mode=][=mixed-pitch-mode=]]
    - [[=hl-todo=][=hl-todo=]]
    - [[=emacs-tree-sitter=][=emacs-tree-sitter=]]
    - [[=lispy=][=lispy=]]
    - [[=docker=][=docker=]]
    - [[=embark=][=embark=]]
    - [[=embark-consult=][=embark-consult=]]
    - [[=notmuch=][=notmuch=]]
  - [[Theme][Theme]]
- [[File modes][File modes]]
  - [[Org][Org]]
    - [[Add-ons][Add-ons]]
    - [[Export][Export]]
    - [[Babel][Babel]]
  - [[C-like languages][C-like languages]]
    - [[C/C++][C/C++]]
    - [[CUDA][CUDA]]
  - [[R][R]]
  - [[Shell script][Shell script]]
  - [[Makefile][Makefile]]
  - [[PlantUML][PlantUML]]
  - [[Lisp][Lisp]]
  - [[Elisp][Elisp]]
  - [[Python][Python]]
  - [[CMake][CMake]]
  - [[Dockerfile][Dockerfile]]
  - [[GMPL][GMPL]]
  - [[Julia][Julia]]
  - [[LaTeX][LaTeX]]
  - [[Meson][Meson]]
  - [[{bspwm,sxhkd}rc][{bspwm,sxhkd}rc]]
  - [[Configuration files][Configuration files]]
  - [[Rust][Rust]]
  - [[Perl][Perl]]
  - [[Dot (Graphviz)][Dot (Graphviz)]]
  - [[Bison/Flex/Yacc][Bison/Flex/Yacc]]
  - [[Markdown][Markdown]]
  - [[PKGBUILD][PKGBUILD]]
  - [[JavaScript][JavaScript]]
  - [[Typescript][Typescript]]
  - [[Clojure][Clojure]]
  - [[Racket][Racket]]
  - [[YAML][YAML]]
  - [[GGO][GGO]]
  - [[Git-related files][Git-related files]]
- [[Local variables][Local variables]]

* Introduction

First of all, welcome to my configuration file for Emacs. I built it from almost
the ground up, picking up configs from several sources, some of which I've cited
in the beginning of this file.

As I'd like that this file be used as a source of inspiration for others, I
wrote it in an =.org= file, using all of =org-mode='s black magic powers of tangling
source blocks to intertwine both source =.el= and prose.

Also, I've used in almost all sections of this document a package called
=use-package= in order to organize all the additional packages that I use to get a
better Emacs experience. So, I'll teach you to read a =use-package= statement!
That way you can understand what's happening beneath all sugar syntax.

** What packages you can find here

You can find the following packages in this configuration file:

#+begin_src bash :exports results :results output list org
[ ! -f 'config.el' ] && emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "config.org")'

grep -E '(^\(use-package .*|^ *:straight .*)' config.el |
    tr -d '()' |
    awk '!/\<built-in\>|\<nil\>|\<t\>/ {print $2}' |
    sort -u
#+end_src

#+RESULTS:
#+begin_src org
- ace-window
- aggressive-indent
- ansi-color
- anzu
- auctex-latexmk
- autoinsert
- avy
- bash-completion
- beacon
- bison
- bspwm
- cargo
- cc-mode
- cider
- clang-format
- clj-refactor
- clojure-mode
- cmake-font-lock
- cmake-mode
- comint
- company
- compile
- conf-mode
- consult
- corfu
- cperl-mode
- crux
- cuda-mode
- dashboard
- deadgrep
- delight
- diff-hl
- dockerfile-mode
- docker-tramp
- eglot
- elec-pair
- electric
- elisp-mode
- elisp-slime-nav
- embark
- embark-consult
- engine-mode
- ess
- ess-r-mode
- evil
- evil-collection
- evil-matchit
- evil-mc
- evil-numbers
- evil-states
- evil-surround
- exec-path-from-shell
- expand-region
- files
- flyspell
- gdb-mi
- general
- ggo-mode
- git-timemachine
- gmpl-mode
- graphviz-dot-mode
- gruvbox-theme
- gud
- helpful
- hide-mode-line
- highlight-doxygen
- highlight-escape-sequences
- highlight-indent-guides
- highlight-numbers
- hl-todo
- htmlize
- hydra
- ibuffer
- js
- julia-mode
- jupyter
- ligature
- link-hint
- lisp-extra-font-lock
- lisp-mode
- lispy
- lispyville
- lsp-ui
- magit
- make-mode
- marginalia
- markdown-mode
- meson-mode
- midnight
- mixed-pitch
- mode-local
- modern-cpp-font-lock
- no-littering
- ob
- ob-R
- openwith
- orderless
- org
- org-agenda
- org-appear
- org-attach
- org-capture
- org-id
- org-journal
- org-ref
- org-refile
- ox
- ox-beamer
- ox-dnd
- ox-extra
- ox-hugo
- ox-latex
- ox-twbs
- page-break-lines
- paren
- pkgbuild-mode
- plantuml-mode
- preproc-font-lock
- project
- projectile
- python
- racket-mode
- rainbow-delimiters
- recentf
- reftex
- rust-mode
- sh-script
- smart-mode-line
- ssh
- super-save
- tex
- toc-org
- tramp
- treemacs
- treemacs-evil
- treemacs-projectile
- tree-sitter
- tree-sitter-langs
- typescript-mode
- undo-tree
- uniquify
- use-package
- vertico
- vimish-fold
- visual-fill-column
- vterm
- websocket
- which-key
- whitespace
- windmove
- writeroom-mode
- xref
- yaml-mode
- yasnippet
- zmq
#+end_src

** =use-package=

Briefly, this package wraps your configuration for a given package in a
neat little statement, which can include several useful categorizations
and sub-tools.

Here are all little keywords you can use to organize your configs:

*** :after

The =:after= keyword sets a relation of dependency between the loading
of two packages. In other words, you can tell =use-package= that a given
package should only be loaded if that other package is already loaded.

#+begin_src emacs-lisp
(use-package foo)

(use-package bar
  :after foo)

(use-package moo
  :after (foo bar))    ; Supports mmultiple dependencies!
#+end_src

*** :defer

The =:defer= keyword tells =use-package= that it can defer the loading
of your package until its absolutely needed. Its behaviour is the
opposite of the keyword =:demand=.

#+begin_src emacs-lisp
(use-package foo
  :defer t)
#+end_src

*** :demand

The =:demand= keyword says to =use-package= that this package must not
be lazy-loaded, and should be loaded right away as Emacs loads.

#+begin_src emacs-lisp
(use-package foo
  :demand)
#+end_src

*** :init

The =:init= keyword can tell =use-package= to execute said commands
*BEFORE* the package is loaded. In reality, said execution will happen
as soon as the =use-package= statement is processed on the Emacs loading
process.

#+begin_src emacs-lisp
(use-package foo
  :init
  (setq bar t))
#+end_src

*** :config

The =:config= keyword, much like the =:init= keyword, tells
=use-package= to execute commands. The difference is that commands
defined with this keyword will only execute *AFTER* the package is
loaded. There is an important difference here, as =use-package= uses
what's called /lazy loading/, i.e. only load the package when you
actually need it.

#+begin_src emacs-lisp
(use-package foo
  :config
  (foo-init))
#+end_src

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff you
coded yourself.

To-do:

- [X] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Information

Some basic info about me.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Henrique Silva"
      user-mail-address "hcpsilva@inf.ufrgs.br")
#+end_src

** Functions and Macros

Some very useful functions I got from other people or that I coded
myself.

*** Fetching text

To get the current selected text without newlines.

#+begin_src emacs-lisp :tangle yes
(defun hcps/get-selected-text (start end)
  (interactive "r")
  (if (use-region-p)
      (kill-new
       (replace-regexp-in-string
        "\n" " "
        (regionp (buffer-substring start end))))))
#+end_src

*** Date

Insert the current date.

#+begin_src emacs-lisp :tangle yes
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+end_src

*** One-time advice

'Cause that is kinda cool to have. Got it from [[https://emacs.stackexchange.com/questions/26251/one-time-advice][this]] place.

#+begin_src emacs-lisp :tangle yes
(defun advise-once (symbol where function &optional props)
  (advice-add symbol :after `(lambda (&rest _) (advice-remove ',symbol ',function)))
  (advice-add symbol where function props))
#+end_src

*** Automatic byte-compile

To use with this configuration file.

#+begin_src emacs-lisp :tangle yes
(defconst config-file-name (expand-file-name "config.org" user-emacs-directory)
  "The path to the configuration")

(defun hcps/async-byte-compile-org-config ()
  "To add as a hook when saving the config file."
  (when (yes-or-no-p "Recompile config?")
    (let ((default-directory user-emacs-directory)
          (compile-script (concat "compile-" (file-name-base config-file-name) ".el")))
      (start-process
       "Emacs : Config compilation" (concat "*" (file-name-sans-extension compile-script) "*")
       "emacs" "--batch" "-l" compile-script))))
#+end_src

*** Auto-removing hook

Sometimes it's cool to have a single-use hook.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (defmacro hcps/hook-require-once (hook package)
    "Add a hook to `pre-command-hook' which requires the given package once."
    (let ((func (intern (concat "hcps/" (symbol-name hook) "-require-" (symbol-name package)))))
      `(progn
         (defun ,func ()
           (remove-hook ',hook #',func)
           (require ',package))
         (add-hook ',hook #',func)))))
#+end_src

*** Trim functions

Directly from Magnar Sveen's =s.el=

#+begin_src emacs-lisp :tangle yes
(defun hcps/s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (declare (pure t) (side-effect-free t))
  (if (string-match "\\`[ \t\n\r]+" s)
      (replace-match "" t t s)
    s))

(defun hcps/s-trim-right (s)
  "Remove whitespace at the end of S."
  (declare (pure t) (side-effect-free t))
  (if (string-match "[ \t\n\r]+\\'" s)
      (replace-match "" t t s)
    s))

(defun hcps/s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (declare (pure t) (side-effect-free t))
  (s-trim-left (s-trim-right s)))
#+end_src

*** Fontification of sub-blocks

Inside other languages or strings, like in shell-scripts and such.

- [ ] =org-src-font-lock-fontify-block=
  - =org-fontify-meta-lines-and-blocks=

#+begin_src emacs-lisp :tangle yes
(defun hcps/externally-fontify-sub-block (lang start end)
  "Shamelessly stolen from `org-mode' implementation (sort-of).
Many languages include code sections in a different language.
This way we don't need to reimplement the font-lock rules and we
still get the pretty colors."
  (when (fboundp lang)
    (let ((string (buffer-substring-no-properties start end))
          (modified (buffer-modified-p))
          (this-buffer (current-buffer)))
      (remove-text-properties start end '(face nil))
      (with-current-buffer
          (get-buffer-create (format " *block-fontification:%s*" (symbol-name lang)))
        (let ((inhibit-modification-hooks nil))
          (erase-buffer)
          ;; Add string and a final space to ensure property change.
          (insert string " "))
        (unless (eq major-mode lang) (funcall lang))
        (font-lock-ensure)
        (let ((pos (point-min))
              next)
          (while (setq next (next-property-change pos))
            ;; Handle additional properties from font-lock, so as to
            ;; preserve, e.g., composition.
            (dolist (prop (cons 'face font-lock-extra-managed-props))
              (let ((new-prop (get-text-property pos prop)))
                (put-text-property
                 (+ start (1- pos)) (1- (+ start next)) prop new-prop
                 this-buffer)))
            (setq pos next))))
      (add-text-properties
       start end
       '(font-lock-fontified t fontified t font-lock-multiline t))
      (set-buffer-modified-p modified))))

(defun hcps/fontify-region-as-lang (lang rx-start rx-end)
  (lambda (limit)
    (let ((case-fold-search t))
      (when (re-search-forward rx-start limit t)
        (let ((block-start (match-end 0))
              (block-end nil))
          (when (re-search-forward rx-end nil t)
            (setq block-end (match-beginning 0))
            (hcps/externally-fontify-sub-block lang block-start block-end)))))))
#+end_src

*** Modeline

A clear modeline is prettier sometimes

#+begin_src emacs-lisp :tangle yes
(defun hcps/clean-mode-line ()
  "Clean mode-line format."
  (setq-local mode-line-format ""))
#+end_src

And sometimes there's no need in having an evil tag

#+begin_src emacs-lisp :tangle yes
(defun hcps/hide-evil-tag ()
  "Some buffers don't need it."
  (setq-local evil-normal-state-tag nil)
  (setq-local evil-emacs-state-tag nil)
  (setq-local evil-insert-state-tag nil)
  (setq-local evil-replace-state-tag nil)
  (setq-local evil-motion-state-tag nil)
  (setq-local evil-visual-state-tag nil)
  (setq-local evil-operator-state-tag nil))
#+end_src

also goddamnit can we please not have variable pitch?

#+begin_src emacs-lisp :tangle yes
(custom-set-faces '(mode-line-active ((t (:inherit mode-line)))))
#+end_src

*** Move lines

Using the ~transpose-lines~ function.

#+begin_src emacs-lisp :tangle yes
(defmacro ew/save-column (&rest body)
  `(let ((column (current-column)))
     (unwind-protect
     (progn ,@body)
       (move-to-column column))))

(defun hcps/move-line-up ()
  "Move up the current line."
  (interactive)
  (ew/save-column
   (transpose-lines 1)
   (forward-line -2)))

(defun hcps/move-line-down ()
  "Move down the current line."
  (interactive)
  (ew/save-column
   (forward-line 1)
   (transpose-lines 1)
   (forward-line -1)))
#+end_src

*** Fixes

Stuff changed in trunk and I'm way too eager to return to stable.

#+begin_src emacs-lisp :tangle yes
(defun define-obsolete-fix (func obsolete current &optional when &rest args)
  (apply func obsolete current (or when "now") args))

(advice-add #'define-obsolete-function-alias :around #'define-obsolete-fix)
(advice-add #'define-obsolete-variable-alias :around #'define-obsolete-fix)

(defun disable-scroll-margin (fun &rest args)
  "Disable margin from active line in modes where it is detrimental."
  (let ((temp-scroll-margin scroll-margin))
    (setq-local scroll-margin 0)
    (apply fun args)
    (setq-local scroll-margin temp-scroll-margin)))

(defun turn-off-cursor (&rest _)
  "It is kinda unnecessary while inside some modes."
  (internal-show-cursor nil nil))
#+end_src

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** Paths and =defconst=

Silly names for easier path usage.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (defconst current-user (getenv "USER") "The current user.")
  (defconst home-dir (expand-file-name current-user "/home/") "The user home dir.")

  (defconst root-dir (expand-file-name user-emacs-directory) "The root dir of Emacs.")
  (defconst var-user-dir (expand-file-name "var" root-dir) "The temporaries directory.")
  (defconst vendor-user-dir (expand-file-name "vendor" root-dir) "The random .el directory.")
  (defconst proj-user-dir (expand-file-name "Repositories" home-dir) "Default projects directory.")
  (defconst onedrive-user-dir (expand-file-name "OneDrive" home-dir) "Default OneDrive path."))
#+end_src

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen
space. Most of those are turned off in my =early-init.el= config.

And then there's the title question. I for one like Emacs capitalized,
so...

#+begin_src emacs-lisp :tangle yes
(setq-default frame-title-format
          '((capitalize invocation-name)
        (:eval (if (buffer-file-name)
               (abbreviate-file-name (buffer-file-name))
             "%b"))))
#+end_src

*** Text

Here's every other setting relating to text editing I can't categorize
any further.

#+begin_src emacs-lisp :tangle yes
(setq-default fill-column 80
              ;; posssible values: (left right center full nil)
              default-justification 'left
              indent-tabs-mode nil
              tab-always-indent 'complete
              tab-first-completion 'word
              bidi-paragraph-direction 'left-to-right
              sentence-end-double-space nil
              tab-width 4
              truncate-lines t
              truncate-partial-width-windows nil
              require-final-newline t
              x-stretch-cursor t
              cursor-in-non-selected-windows nil)
#+end_src

Also, =auto-fill-mode= is very useful to justify paragraphs
automatically while writing.

#+begin_src emacs-lisp :tangle yes
(add-hook 'text-mode-hook #'turn-on-auto-fill)
#+end_src

*** Mode line

Here's everything related to the mode-line.

#+begin_src emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M "
          display-time-default-load-average nil)

(display-time-mode +1)
(line-number-mode +1)
(column-number-mode +1)
(size-indication-mode +1)
#+end_src

*** Line numbering and scrolling

+I like the vim style of relative numbering of lines.+ Never mind, I
grew tired of it.

#+begin_src emacs-lisp :tangle yes
(setq-default display-line-numbers-type t
              display-line-numbers-width-start t)

;; I used to do this globally, but now let's only do selectively
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

And I also like the vim style of scrolling better.

#+begin_src emacs-lisp :tangle yes
(setq-default auto-window-vscroll t
              ;; line-move-visual nil
              scroll-conservatively 101
              scroll-margin 10)
#+end_src

Small fix for =scroll-margin=

#+begin_src emacs-lisp :tangle yes
(defun get-lines-from-top ()
  (save-excursion
    (beginning-of-line)
    (count-screen-lines (point) (window-start))))

(defun scroll-margin-fix (func &rest args)
  (apply func args)
  (if (> scroll-margin 0)
      (let ((diff (- (min scroll-margin (floor (* maximum-scroll-margin (window-screen-lines))))
                     (get-lines-from-top))))
        (when (> diff 0)
          (scroll-down 1)))))

(advice-add #'previous-line :around 'scroll-margin-fix)

;; (add-hook 'prog-mode-hook #'visual-line-mode)
#+end_src

Highlighting the current line is also very useful.

#+begin_src emacs-lisp :tangle yes
(global-hl-line-mode +1)
#+end_src

*** Randoms

Random configs and definitions that don't have a clear category.

#+begin_src emacs-lisp :tangle yes
(setq ad-redefinition-action 'accept         ; Silence warnings for redefinition
      confirm-kill-emacs #'yes-or-no-p       ; Confirm before exiting Emacs
      select-enable-clipboard t              ; Merge system's and Emacs' clipboard
      blink-matching-paren nil               ; Disable annoying blink-matching-paren
      window-combination-resize t            ; Resize windows proportionally
      resize-mini-windows t
      read-process-output-max (* 1024 1024)
      ring-bell-function 'ignore)            ; No bell ring

(add-hook 'after-save-hook
          #'executable-make-buffer-file-executable-if-script-p)

;; (setq initial-major-mode 'text-mode)
;; (setq initial-scratch-message "\
;; This buffer is for notes you don't want to save.
;; If you want to create a file, visit that file with \\[find-file],
;; then enter the text in that file's own buffer.")

;; Replace yes/no prompts with y/n
(fset #'yes-or-no-p #'y-or-n-p)

;; Set Emacs to call the garbage collector on focus-out
;; (add-hook 'focus-out-hook #'garbage-collect)

;; use GPG-agent instead of the default
(setenv "SSH_AUTH_SOCK"
    (expand-file-name "gnupg/S.gpg-agent.ssh" (getenv "XDG_RUNTIME_DIR")))
(setq epg-pinentry-mode 'loopback)

(global-auto-revert-mode t)

;; (setq hippie-expand-try-functions-list '(try-expand-dabbrev
;;                                          try-expand-dabbrev-all-buffers
;;                                          try-expand-dabbrev-from-kill
;;                                          try-complete-file-name-partially
;;                                          try-complete-file-name
;;                                          try-expand-all-abbrevs
;;                                          try-expand-list
;;                                          try-expand-line
;;                                          try-complete-lisp-symbol-partially
;;                                          try-complete-lisp-symbol))

;; (require 'ediff)
;; (setq ediff-window-setup-function 'ediff-setup-windows-plain)

;; (require 'eshell)
;; (setq eshell-directory-name (expand-file-name "eshell" var-user-dir))

;; (global-diff-hl-mode +1)
;; (add-hook 'dired-mode-hook 'diff-hl-dired-mode)

;; ;; use hippie-expand instead of dabbrev
;; (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

*** Custom variables

Finally, let's load our custom variables

#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" var-user-dir))

(load-file custom-file)
#+end_src

* Package configuration

Everything that isn't an specific file-mode =.el=.

** Setting-up

Some setting up before we start configuring the packages themselves.

#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  (defvar bootstrap-version)
  (let ((bootstrap-file (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq package-user-dir (expand-file-name "straight" user-emacs-directory)
        straight-use-package-by-default t)

  (unless (file-directory-p package-user-dir)
    (make-directory package-user-dir t)))
#+end_src

I use =use-package= to load my packages and to organize them neatly in this org
file.

#+begin_src emacs-lisp :tangle yes
(eval-when-compile
  (straight-use-package 'use-package)

  (setq use-package-verbose t
        use-package-always-defer t
        use-package-hook-name-suffix nil
        byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local)))

;; general requires this bit otherwise everything blows up when native
;; compiling
(eval-and-compile
  (straight-use-package 'general)
  (require 'general))
#+end_src

also lets add a ~(require 'cl-lib)~ for good measure

#+begin_src emacs-lisp :tangle yes
(eval-when-compile
  (require 'cl-lib))
#+end_src

** Support

All these packages just help on the configuration of the rest of the other
packages.

*** =use-package=

The one and only, for runtime use only!

#+begin_src emacs-lisp :tangle yes
(use-package use-package
  :commands (use-package-core use-package))
#+end_src

*** =general=

To facilitate my keybinding issues, I also use =general.el=. It adds some very
welcome keywords to =use-package=, in which I'll use extensively throughout this
file.

#+begin_src emacs-lisp :tangle yes
(use-package general
  :demand t
  :commands general-define-key
  :preface
  (defconst hcps/leader-key "SPC"
    "Leader key for some special commands.")
  (defconst hcps/alt-leader-key "C-:"
    "Alternate leader key.")
  (defvar hcps/leader-map (make-sparse-keymap)
    "Keymap for all my leader bindings.")
  :init
  (general-unbind 'global-map
    hcps/leader-key)
  (general-def
    :keymaps 'override
    hcps/alt-leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  (general-def
    :keymaps 'special-mode-map
    hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  :config
  ;; common emacs styled keybindings
  (general-def 'override
    "C-x C-b" #'ibuffer
    "C-x k" #'kill-this-buffer
    "C-c x" #'hcps/date-iso
    "<f9>" #'hcps/get-selected-text
    "M--" #'text-scale-decrease
    "M-+" #'text-scale-increase
    "C-S-h" #'tab-previous
    "C-S-l" #'tab-next
    "C-S-n" #'tab-new
    "C-S-c" #'tab-close
    "C-S-s" #'tab-select
    "M-K" #'hcps/move-line-up
    "M-J" #'hcps/move-line-down
    "<f12>" #'menu-bar-mode)
  ;; leader-map keybindings
  (general-def 'hcps/leader-map
    "s" #'save-buffer
    "k" #'kill-this-buffer
    "i" #'indent-region
    "b" #'switch-to-buffer
    "e c" #'comment-dwim
    "e a" #'align-current
    "e p" #'yank-pop
    "e e" #'eval-region
    "n j" #'goto-line
    "f f" #'find-file
    "w k" #'delete-window
    "w v" #'split-window-vertically
    "w h" #'split-window-horizontally
    "v n p" #'narrow-to-page
    "v n f" #'narrow-to-defun
    "v n r" #'narrow-to-region
    "v n w" #'widen)
  ;; cute names for the prefixes (some will only be defined further
  ;; along)
  (general-def '(normal visual insert emacs special-mode-map)
    :prefix hcps/leader-key
    :non-normal-prefix hcps/alt-leader-key
    "g" '(:ignore t :wk "magit")
    "f" '(:ignore t :wk "file")
    "w" '(:ignore t :wk "window")
    "n" '(:ignore t :wk "navigate")
    "o" '(:ignore t :wk "org")
    "m" '(:ignore t :wk "mode")
    "v" '(:ignore t :wk "view")
    "e" '(:ignore t :wk "edit")
    "p" '(:ignore t :wk "project")
    "l" '(:ignore t :wk "mail")
    "m e" '(:ignore t :wk "eglot")
    "v n" '(:ignore t :wk "narrow")))
#+end_src

*** =delight=

And we'll use =delight= to hide minor-modes names and such.

#+begin_src emacs-lisp :tangle yes
(use-package delight
  :demand t
  :commands delight
  :delight
  (auto-fill-function " af")
  (eldoc-mode " ed")
  (editorconfig-mode)
  (flymake-mode " fm" flymake)
  (visual-line-mode " vl")
  (abbrev-mode))
#+end_src

*** =no-littering=

=no-littering= will help us by setting sane paths to all cache and history files
the packages might set.

#+begin_src emacs-lisp :tangle yes
(use-package no-littering
  :demand t)
#+end_src

*** =hide-mode-line=

Made by the doom-emacs guy. Yeah I know I could just write a function for this,
but eh.

#+begin_src emacs-lisp :tangle yes
(use-package hide-mode-line
  :commands hide-mode-line-mode)
#+end_src

*** =mode-local=

Pretty little package that hides unnecessary hooks to set local variables

#+begin_src emacs-lisp :tangle yes
(use-package mode-local
  :demand t
  :straight (:type built-in))
#+end_src

*** =hydra=                                                             :WIP:

=hydra= is a package that allows keybindings to be activated under the pressing of
a specific combination of keys. These will then be active as long as only them
are being pressed, as on the moment a key which isn't part of the hydra is
pressed the hydra is killed and the keybindings deactivated.

#+begin_src emacs-lisp :tangle yes
(use-package hydra
  :commands defhydra
  :custom
  (hydra-default-hint nil))
#+end_src

**** Eyebrowse

#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'hydra
  (defhydra hydra-eyebrowse (:color blue)
    "
^Eyebrowse^         ^Do^                ^Switch^
^---------^---------^--^----------------^------^------------
_q_ quit            _c_ create          _<_ previous
^^                  _k_ kill            _>_ next
^^                  _r_ rename          _e_ last
^^                  ^^                  _s_ switch
^^                  ^^                  ^^
"
    ("q" nil)
    ("<" eyebrowse-prev-window-config :color red)
    (">" eyebrowse-next-window-config :color red)
    ("c" eyebrowse-create-window-config)
    ("e" eyebrowse-last-window-config)
    ("k" eyebrowse-close-window-config :color red)
    ("r" eyebrowse-rename-window-config)
    ("s" eyebrowse-switch-to-window-config))

  (with-eval-after-load 'general
    (general-def '(global-map special-mode-map)
      "C-c e" 'hydra-eyebrowse/body)))
#+end_src

**** Flycheck

#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'hydra
  (defhydra hydra-flycheck (:color pink)
    "
^
^Flycheck^          ^Errors^            ^Checker^
^────────^──────────^──────^────────────^───────^───────────
_q_ quit            _<_ previous        _?_ describe
_m_ manual          _>_ next            _d_ disable
_v_ verify setup    _f_ check           _s_ select
^^                  _l_ list            ^^
^^                  ^^                  ^^
"
    ("q" nil)
    ("<" flycheck-previous-error)
    (">" flycheck-next-error)
    ("?" flycheck-describe-checker :color blue)
    ("d" flycheck-disable-checker :color blue)
    ("f" flycheck-buffer)
    ("l" flycheck-list-errors :color blue)
    ("m" flycheck-manual :color blue)
    ("s" flycheck-select-checker :color blue)
    ("v" flycheck-verify-setup :color blue))

  (with-eval-after-load 'general
    (general-def '(global-map special-mode-map)
      "C-c f" 'hydra-flycheck/body)))
#+end_src

** Built-in

The ones that /really/ don't require =use-package :straight t=.

- [ ] bookmark
- [ ] dired
- [ ] hippie-expand
- [ ] eshell
- [ ] save-place
- [X] ibuffer
- [-] autoinsert
  - [ ] org
  - [X] shellscript
  - [ ] elisp
  - [X] c
  - [X] makefile
- [X] electric-pairs
- [ ] project
- [ ] flymake
- [X] xref

*** =package=

Same as above but with keybindings and =package-initialize=.

#+begin_src emacs-lisp :tangle no
(use-package package
  :straight (:type built-in)
  :custom
  (package-archives
   '(("melpa" . "https://melpa.org/packages/")
     ("org"   . "https://orgmode.org/elpa/")
     ("gnu"   . "https://elpa.gnu.org/packages/")))
  :general
  (:keymaps 'hcps/leader-map
   "p l" 'package-list-packages
   "p d" 'package-delete
   "p i" 'package-install
   "p r" 'package-reinstall)
  :config
  (package-initialize))
#+end_src

*** =whitespace=

Let's monitor ourselves with =whitespace=.

#+begin_src emacs-lisp :tangle yes
(use-package whitespace
  :straight (:type built-in)
  :commands (whitespace-mode whitespace-cleanup delete-trailing-whitespace)
  :hook
  ((before-save-hook . whitespace-cleanup)
   (text-mode-hook   . whitespace-mode)
   (prog-mode-hook   . whitespace-mode))
  :custom
  (whitespace-line-column nil)
  (whitespace-style
   '(face ;;
     tabs indentation trailing lines-tail missing-newline-at-eof
     space-after-tab space-before-tab))
  :custom-face
  (whitespace-missing-newline-at-eof ((t (:foreground unspecified :background unspecified)))))
#+end_src

*** =compile=

This compilation helper mode facilitates the navigation of error outputs on
compilations.

#+begin_src emacs-lisp :tangle yes
(use-package compile
  :straight (:type built-in)
  :commands compile-mode
  :custom
  (compilation-ask-about-save nil)
  (compilation-always-kill t)
  (compilation-scroll-output 'first-error)
  (compilation-auto-jump-to-first-error t))
#+end_src

*** =tramp=

=tramp= is very useful when it comes to editing remote files and to editing as
super-user.

#+begin_src emacs-lisp :tangle yes
(use-package tramp
  :straight (:type built-in)
  :custom
  (tramp-default-method "ssh")
  (tramp-terminal-type "xterm-mono"))
#+end_src

*** =ansi-color=

To have pretty colors on ansi output.

#+begin_src emacs-lisp :tangle yes
(use-package ansi-color
  :straight (:type built-in)
  :commands
  (ansi-color-for-comint-mode-on ansi-color-filter-apply ansi-color-process-output)
  :hook
  ((shell-mode-hook                   . ansi-color-for-comint-mode-on)
   (eshell-preoutput-filter-functions . ansi-color-filter-apply)
   (comint-output-filter-functions    . ansi-color-process-output)))
#+end_src

*** =windmove=

A package that creates commands to move around windows.

#+begin_src emacs-lisp :tangle yes
(use-package windmove
  :straight (:type built-in)
  :general
  (:keymaps 'override
   "C-M-h" #'windmove-left
   "C-M-l" #'windmove-right
   "C-M-k" #'windmove-up
   "C-M-j" #'windmove-down))
#+end_src

*** =midnight=

Originally, =midnight= is used to /run something at midnight/. I use its feature
that kills old buffers.

#+begin_src emacs-lisp :tangle yes
(use-package midnight
  :disabled
  :defer 60
  :straight (:type built-in)
  :custom
  (clean-buffer-list-delay-general (/ 1 12))
  (clean-buffer-list-delay-special (* 1 3600))
  (clean-buffer-list-kill-buffer-names
   '("*Help*" "*Apropos*" "*Buffer List*" "*Compile-Log*" "*info*" "*vc*"
     "*vc-diff*" "*diff*" "*IBuffer*" "*Finder*")))
#+end_src

*** =uniquify=

=uniquify= creates automatic meaningful names for buffers with the same name:

#+begin_src emacs-lisp :tangle yes
(use-package uniquify
  :demand t
  :straight (:type built-in)
  :custom
  (uniquify-buffer-name-style 'post-forward)
  (uniquify-separator ":")
  (uniquify-after-kill-buffer-p t)
  (uniquify-ignore-buffers-re "^[*[:space:]]"))
#+end_src

*** =recentf=

Keep a list of recent files with =recentf=

#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :straight (:type built-in)
  :commands recentf-open-files
  :hook
  (kill-emacs-hook . recentf-cleanup)
  :custom
  (recentf-save-file (expand-file-name "recentf-save.el" var-user-dir))
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 300)
  (recentf-exclude
   (list
    'file-remote-p
    "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
    "^/tmp/"
    "^/ssh:"
    "\\.?ido\\.last$"
    "\\.revive$"
    "/TAGS$"
    var-user-dir
    package-user-dir
    (expand-file-name "savefile" root-dir)))
  (recentf-auto-cleanup 'never)
  :config
  (recentf-mode +1))
#+end_src

*** =ibuffer=

Way better than the default one (and is built-in!)

#+begin_src emacs-lisp :tangle yes
(use-package ibuffer
  :straight (:type built-in)
  :hook
  ((ibuffer-mode-hook . hcps/hide-evil-tag)
   (ibuffer-mode-hook . evil-emacs-state))
  :general
  (:keymaps 'ibuffer-mode-map
   "q" 'kill-this-buffer
   "j" 'ibuffer-forward-line
   "k" 'ibuffer-backward-line
   "K" 'ibuffer-do-kill-lines
   "J" 'ibuffer-jump-to-buffer
   hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  (:keymaps 'hcps/leader-map
   "B" 'ibuffer)
  (:keymaps 'override
   "C-x C-b" 'ibuffer))
#+end_src

*** =autoinsert=

To easily insert boilerplate text into files that need it, e.g. an org-mode
beamer file, org-mode latex-file or a shell-script. The default is already
pretty packed with templates, but I intend to ignore most of them. In my
opinion, if I created an =autoinsert= directory, the templates would be easier to
maintain and the configuration would be cleaner.

- [[https://emacs.stackexchange.com/questions/45629/template-for-new-file]]
- [[https://www.emacswiki.org/emacs/AutoInsertMode]]
- [[https://www.emacswiki.org/emacs/AutoInsertChoose]]

#+begin_src emacs-lisp :tangle yes
(use-package autoinsert
  :straight (:type built-in)
  :preface
  (defmacro hcps/yas-auto-insert-template (name mode)
    "Looks up the given name and expands it on point."
    (let ((func (intern (concat "hcps/" (symbol-name mode) "-insert-" name))))
      `(defun ,func ()
     (interactive)
     (yas-expand-snippet (yas-lookup-snippet ,name #',mode)))))
  (defmacro auto-insert-choose-and-call (template-alist)
    "Interactively choose and call a function from TEMPLATE-ALIST.
TEMPLATE-ALIST should be a list whose elements are (STRING FUNCTION).
Intended for use in `auto-insert-alist'"
    `(let ((cell (assoc (completing-read "Template: " ,template-alist) ,template-alist)))
       (when cell
     (funcall (cadr cell)))))
  :init
  (hcps/yas-auto-insert-template "header-template" c-mode)
  (hcps/yas-auto-insert-template "header-template" c++-mode)
  (hcps/yas-auto-insert-template "source-template" c-mode)
  (hcps/yas-auto-insert-template "simple-template" cmake-mode)
  (hcps/yas-auto-insert-template "simple-template" makefile-mode)
  (hcps/yas-auto-insert-template "simple-template" sh-mode)
  (advice-add #'auto-insert :around
          (lambda (func &rest args) (yas-minor-mode) (apply func args)))
  :hook
  (find-file-hook . auto-insert)
  :custom
  (auto-insert t)
  (auto-insert-query nil)
  (auto-insert-directory (expand-file-name "templates/" root-dir))
  (auto-insert-alist
   `((("\\.h$" . "C header") . [hcps/c-mode-insert-header-template])
     (("\\.[Hh]\\(pp\\|\\+\\+\\)$" . "C++ header") . [hcps/c++-mode-insert-header-template])
     (("\\.[Cc]\\(pp\\|\\+\\+\\)?$" . "C / C++ source") . [hcps/c-mode-insert-source-template])
     ;; ((org-mode . "Org mode")
     ;;  lambda nil
     ;;  ,(auto-insert-choose-and-call
     ;;    (("Beamer presentation"
     ;;      (hcps/yas-auto-insert-template "org-beamer-template" org-mode))
     ;;     ("LaTeX document"
     ;;      (hcps/yas-auto-insert-template "org-latex-template" org-mode))
     ;;     ("Common document"
     ;;      (hcps/yas-auto-insert-template "org-template" org-mode)))))
     ((cmake-mode . "CMake") . [hcps/cmake-mode-insert-simple-template])
     ((makefile-mode . "Makefile") . [hcps/makefile-mode-insert-simple-template])
     ((sh-mode . "Shell Script") . [hcps/sh-mode-insert-simple-template]))))
#+end_src

*** =comint=

If this works, I'll be very much pleasantly surprised.

#+begin_src emacs-lisp :tangle yes
(use-package comint
  :straight (:type built-in)
  :preface
  (defun comint-fix-window-size ()
    "Change process window size."
    (when (derived-mode-p 'comint-mode)
      (let ((process (get-buffer-process (current-buffer))))
        (when process
          (set-process-window-size process (window-height) 72)))))
  :hook
  ((comint-exec-hook . comint-fix-window-size)
   (comint-mode-hook . evil-emacs-state)))
#+end_src

*** =paren=

Minor mode to highlight matching parenthesis after point.

#+begin_src emacs-lisp :tangle yes
(use-package paren
  :demand t
  :straight (:type built-in)
  :hook
  (prog-mode-hook . show-paren-mode)
  :custom
  (show-paren-delay 0)
  (show-paren-style 'parenthesis)
  :custom-face
  (show-paren-match ((t (:inherit hl-line :foreground unspecified :background "#504945" :extend nil)))))
#+end_src

*** =elec-pair=

For pretty much every programming language it's interesting to have automatic
pair close insert.

#+begin_src emacs-lisp :tangle yes
(use-package elec-pair
  :demand t
  :straight (:type built-in)
  :config
  (electric-pair-mode +1))
#+end_src

*** =electric=

Like the previous one but for indentation.

#+begin_src emacs-lisp :tangle yes
(use-package electric
  :demand t
  :straight (:type built-in)
  :config
  (electric-indent-mode +1))
#+end_src

*** =xref=

#+begin_src emacs-lisp :tangle yes
(use-package xref
  :straight (:type built-in)
  :general
  (:keymaps 'hcps/leader-map
   "m d" #'xref-find-definitions
   "m r" #'xref-find-references
   "m a" #'xref-find-apropos)
  :custom
  (xref-search-program 'ripgrep))
#+end_src

*** =gdb=

Basic =GUD= configuration as setup to =gdb-mi=

#+begin_src emacs-lisp :tangle yes
(use-package gud
  :straight (:type built-in)
  :custom
  (gud-chdir-before-run nil))
#+end_src

An upgrade from =GUD=, has more shiny stuff

#+begin_src emacs-lisp :tangle yes
(use-package gdb-mi
  :straight (:type built-in)
  :commands gdb
  :custom
  (gdb-many-windows t))
#+end_src

*** =project=

Built-in replacement for =projectile=???

#+begin_src emacs-lisp :tangle yes
(use-package project
  :straight (:type built-in)
  :commands project-root
  :general
  (:keymaps 'hcps/leader-map
   "p" '(:keymap project-prefix-map)))
#+end_src

*** =files=

No better place to put these, honestly

#+begin_src emacs-lisp :tangle yes
(use-package files
  :demand t
  :straight (:type built-in)
  :hook
  ((focus-out-hook . do-auto-save)
   (mouse-leave-buffer-hook . do-auto-save))
  :custom
  (auto-save-timeout 5)
  (auto-save-file-name-transforms `((".*" ,(expand-file-name "auto-save/" var-user-dir) t))))
#+end_src

*** =smerge-mode=

For dealing with merges in VCSs

#+begin_src emacs-lisp :tangle yes
(use-package smerge-mode
  :straight (:type built-in)
  :delight
  (smerge-mode " sm")
  :init
  (with-eval-after-load 'hydra
    (defhydra hydra-smerge (:color pink
                            :pre (smerge-mode +1))
      "
^Movement^       ^Merge Action^          ^Other
^^^^^^------------------------------------------------
_n_: next hunk   _b_: keep base          _M_: makeup
_p_: prev hunk   _m_: keep mine          _r_: resolve
^ ^              _a_: keep all           _R_: refine
^ ^              _o_: keep other         _s_: swap
^ ^              _c_: keep current       _q_: quit
^ ^              _C_: combine with next
^ ^              _e_: ediff
"
      ("n" smerge-next)
      ("p" smerge-prev)
      ("a" smerge-keep-all)
      ("b" smerge-keep-base)
      ("m" smerge-keep-upper)
      ("o" smerge-keep-lower)
      ("c" smerge-keep-current)
      ("C" smerge-combine-with-next)
      ("e" smerge-ediff :color blue)
      ("M" smerge-makeup-conflict)
      ("r" smerge-resolve)
      ("R" smerge-refine)
      ("s" smerge-swap)
      ("q" nil :color blue)))
  :general
  (:keymaps 'hcps/leader-map
   "f e" '(:ignore t :wk "smerge")
   "f e h" #'hydra-smerge/body
   "f e n" #'smerge-next
   "f e p" #'smerge-prev
   "f e r" #'smerge-resolve
   "f e a" #'smerge-keep-all
   "f e b" #'smerge-keep-base
   "f e o" #'smerge-keep-lower           ; for the obsolete keep-other
   "f e l" #'smerge-keep-lower
   "f e m" #'smerge-keep-upper           ; for the obsolete keep-mine
   "f e u" #'smerge-keep-upper
   "f e E" #'smerge-ediff
   "f e C" #'smerge-combine-with-next
   "f e R" #'smerge-refine)
  :config
  (require 'hydra))
#+end_src

*** =sendmail=

Default package for sending email, originally uses the homonymous Perl script,
now setup to use =msmtp=

#+begin_src emacs-lisp :tangle yes
(use-package sendmail
  :straight (:type built-in)
  :commands sendmail-send-it
  :custom
  (sendmail-program "/usr/bin/msmtp")
  (send-mail-function #'sendmail-send-it)
  (mail-specify-envelope-from t)
  (message-sendmail-envelope-from 'header)
  (mail-envelope-from 'header))
#+end_src

** Extensions

The ones from MELPA and ELPA and whatever.

- [X] vterm

*** =evil=

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs text editing
keybindings to match the modal edit modes of vi and vim. Yes, you can have the
best of both worlds!

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :demand t
  :commands (evil-set-initial-state evil-emacs-state)
  :defines (evil-normal-state-map evil-visual-state-map)
  :preface
  (defun hcps/shift-left-region ()
    "Shift left and restore visual selection."
    (interactive)
    (evil-shift-left (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  (defun hcps/shift-right-region ()
    "Shift right and restore visual selection."
    (interactive)
    (evil-shift-right (region-beginning) (region-end))
    (evil-normal-state)
    (evil-visual-restore))
  (defun dzop/evil-org-insert-state-in-edit-buffer (fun &rest args)
    "Bind `evil-default-state' to `insert' before calling FUN with ARGS."
    (let ((evil-default-state 'insert)
          ;; Force insert state
          (evil-emacs-state-modes nil)
          (evil-normal-state-modes nil)
          (evil-motion-state-modes nil)
          (evil-visual-state-modes nil)
          (evil-operator-state-modes nil)
          (evil-replace-state-modes nil))
      (apply fun args)
      (evil-refresh-cursor)))
  :init
  (setq evil-want-keybinding nil)
  (advice-add #'org-babel-do-key-sequence-in-edit-buffer
              :around #'dzop/evil-org-insert-state-in-edit-buffer)
  (hcps/hook-require-once pre-command-hook evil)
  :general
  (:states '(normal visual)
   hcps/leader-key '(:wk "leader" :keymap hcps/leader-map :package general))
  (:states 'insert
   "C-y" nil
   "<up>" #'previous-line
   "<down>" #'next-line
   "<left>" #'left-char
   "<right>" #'right-char
   "<return>" #'newline-and-indent)
  (:states 'visual
   ">" #'hcps/shift-right-region
   "<" #'hcps/shift-left-region)
  :custom
  (evil-esc-delay 0)
  (evil-scroll-count 15)
  (evil-shift-width 2)
  (evil-auto-indent t)
  (evil-undo-system 'undo-tree)
  (evil-want-fine-undo t)
  (evil-search-wrap t)
  (evil-regexp-search t)
  (evil-search-module 'isearch)
  (evil-echo-state nil)
  (evil-want-C-u-scroll t)
  (evil-want-C-d-scroll t)
  (evil-want-Y-yank-to-eol t) ; why doesn't this work???
  (evil-ex-substitute-global t)
  (evil-respect-visual-line-mode t)
  (evil-mode-line-format '(before . mode-line-front-space))
  :config
  (evil-mode +1))
#+end_src

**** States

Apparently the =evil-states= package isn't being loaded correctly after
=evil=...

#+begin_src emacs-lisp :tangle yes
(use-package evil-states
  :after evil
  :demand t
  :straight (:type built-in)
  :custom
  (evil-emacs-state-cursor    '("red" box))
  (evil-normal-state-cursor   '("gray" box))
  (evil-visual-state-cursor   '("gray" hollow))
  (evil-insert-state-cursor   '("gray" bar))
  (evil-motion-state-cursor   '("gray" hbar))
  (evil-operator-state-cursor '("gray" evil-half-cursor))
  (evil-normal-state-tag   (propertize "   NORMAL   " 'face '((:background "DarkGoldenrod2" :foreground "black"))))
  (evil-emacs-state-tag    (propertize "   EMACS    " 'face '((:background "SkyBlue2"       :foreground "black"))))
  (evil-insert-state-tag   (propertize "   INSERT   " 'face '((:background "chartreuse3"    :foreground "black"))))
  (evil-replace-state-tag  (propertize "  REPLACE   " 'face '((:background "chocolate"      :foreground "black"))))
  (evil-motion-state-tag   (propertize "   MOTION   " 'face '((:background "plum3"          :foreground "black"))))
  (evil-visual-state-tag   (propertize "   VISUAL   " 'face '((:background "gray"           :foreground "black"))))
  (evil-operator-state-tag (propertize "  OPERATOR  " 'face '((:background "sandy brown"    :foreground "black")))))
#+end_src

**** Cursors

Here we have both =evil-matchit=, which allows you to jump between tags
automatically,

#+begin_src emacs-lisp :tangle yes
(use-package evil-matchit
  :after evil
  :demand t
  :custom
  (evilmi-may-jump-by-percentage nil)
  :config
  (global-evil-matchit-mode +1))
#+end_src

and =evil-mc= implements the =multiple-cursors= functionality to
=evil-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package evil-mc
  :after evil
  :demand t
  :delight
  :general
  (:states 'visual
   "A" #'evil-mc-make-cursor-in-visual-selection-end
   "I" #'evil-mc-make-cursor-in-visual-selection-beg)
  (:states '(normal visual)
   "" #'evil-mc-make-and-goto-prev-cursor)
  (:keymaps 'hcps/leader-map
   "ESC" #'evil-mc-undo-all-cursors)
  :config
  (global-evil-mc-mode +1)
  (fmakunbound 'evil-mc-make-and-goto-prev-cursor))
#+end_src

**** Pairs

On pairs (and regions really) we have =evil-smartparens=, to use better
bindings to =smartparens=,

#+begin_src emacs-lisp :tangle no
(use-package evil-smartparens
  :after evil
  :demand t
  :delight
  :hook
  (smartparens-enabled-hook . evil-smartparens-mode))
#+end_src

and =evil-surround=, which is a port of =surround= from vim and allow
you to quickly delete or change surrounding ="= and ='= from words or
paragraphs or whatever, as it integrates with vim's verb way of
expressing actions.

#+begin_src emacs-lisp :tangle yes
(use-package evil-surround
  :after evil
  :demand t
  :general
  (:states 'operator
   "s" #'evil-surround-edit
   "S" #'evil-Surround-edit)
  (:states 'visual
   "S" #'evil-surround-region
   "gS" #'evil-Surround-region)
  :config
  (add-to-list 'evil-surround-pairs-alist '(?/ . ("/" . "/")))
  (add-to-list 'evil-surround-pairs-alist '(?* . ("*" . "*")))
  (global-evil-surround-mode +1))
#+end_src

**** Utilities

As it gets impossible to not use vim keybindings everywhere,
=evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages,

#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :demand t
  :delight evil-collection-unimpaired-mode
  :config
  (setq evil-collection-mode-list
        (cl-set-difference evil-collection-mode-list
                           '(magit markdown-mode dashboard ibuffer lispy)))
  (evil-collection-init))
#+end_src

and also =evil-numbers=, to have nice keybindings to increase or
decrease numbers.

#+begin_src emacs-lisp :tangle yes
(use-package evil-numbers
  :after evil
  :demand t
  :general
  (:states 'normal
   "C-a" #'evil-numbers/inc-at-pt
   "C-A" #'evil-numbers/dec-at-pt))
#+end_src

*** =smart-mode-line=

I use =smart-mode-line= as it is very minimalist and informative (and it looks
very pretty on =gruvbox=).

#+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :demand t
  :custom
  (sml/size-indication-format " %I ")
  (sml/line-number-format "%4l")
  (sml/use-projectile-p nil)
  (sml/shorten-directory nil)
  (sml/shorten-modes t)
  (sml/mode-width 'right)
  (sml/name-width 40)
  (sml/theme 'respectful)
  (sml/no-confirm-load-theme t)
  (sml/replacer-regexp-list
   '(("^~/\\.emacs\\.d/straight/repos/" ":STRAIGHT:")
     ("^~/\\.emacs\\.d/" ":ED:")
     ("^/sudo:.*:" ":SU:")
     ("^~/Documents/" ":DOC:")
     ("^~/Repositories/" ":VCS:")
     ("^~/OneDrive/CIC/" ":UNI:")
     ("^~/OneDrive/" ":OD:")))
  :config
  (sml/setup))
#+end_src

*** =orderless=

#+begin_src emacs-lisp :tangle yes
(use-package orderless
  :demand t
  :commands (orderless-filter orderless-highlight-matches)
  :init
  (setq completion-category-defaults nil)
  :custom
  (completion-styles '(orderless))
  (completion-category-overrides '((file (styles . (partial-completion)))))
  (orderless-matching-styles '(orderless-regexp orderless-initialism orderless-prefixes))
  :custom-face
  (orderless-match-face-0 ((t (:weight bold :foreground "#d75f5f"))))
  (orderless-match-face-1 ((t (:weight bold :foreground "#ffaf00"))))
  (orderless-match-face-2 ((t (:weight bold :foreground "#87afaf"))))
  (orderless-match-face-3 ((t (:weight bold :foreground "#d787af"))))
  :config
  (savehist-mode +1))
#+end_src

*** =vertico=

#+begin_src emacs-lisp :tangle yes
(use-package vertico
  :after orderless
  :demand t
  :general
  (:keymaps 'vertico-map
   "M-k" #'vertico-previous
   "M-j" #'vertico-next
   "C-f" #'vertico-exit-input
   "C-u" #'vertico-scroll-down
   "C-d" #'vertico-scroll-up)
  :custom
  (vertico-count 7)
  (read-file-name-completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  :custom-face
  (vertico-current ((t (:inherit hl-line :extend t))))
  :config
  (vertico-mode +1))
#+end_src

*** =corfu=

=corfu.el= (Complete Overlay Region FUnction) is a pretty way to get in-buffer
completion and narrowing within a popup. Issue is, it doesn't play along well
with LSP servers in general (at least with both =lsp-mode= and =eglot=). Really hope
that eventually changes in the future, 'cause I like Corfu more than I like
=company=.

#+begin_src emacs-lisp :tangle yes
(use-package corfu
  :after orderless
  :demand t
  :custom
  (corfu-cycle t)
  (corfu-quit-at-boundary t)
  (corfu-quit-no-match t)
  (corfu-max-width 50)
  (corfu-scroll-margin 5)
  :custom-face
  (corfu-current ((t (:inherit hl-line :extend t))))
  :general
  (:keymaps 'corfu-map
   "M-k" #'corfu-previous
   "M-j" #'corfu-next)
  :config
  (corfu-global-mode +1))
#+end_src

*** =company=                                                    :DEPRECATED:

Attempt #37483745 to make in-buffer completion look pretty. That is, when =eglot=
is turned on. Wish I wouldn't need to use =company=, but LSP completion is wonky
with simpler completion systems. That is, =company= practices black magic.

#+begin_src emacs-lisp :tangle yes
(use-package company
  :after orderless
  :commands (company-mode company-capf--candidates)
  :preface
  (defun orderless-just-one-face (fn &rest args)
    (let ((orderless-match-faces [completions-common-part]))
      (apply fn args)))
  :delight company-mode
  :init
  (advice-add #'company-capf--candidates :around #'orderless-just-one-face)
  ;; :hook
  ;; (company-mode-hook . corfu-mode) ; disable corfu when company is on
  :custom
  (company-backends '(company-capf)))
#+end_src

*** =consult=

Think of it as =counsel= but without needing =ivy= to work.

#+begin_src emacs-lisp :tangle yes
(use-package consult
  :preface
  (defun hcps/evil-scroll-to-top (&rest _)
    "Almost like a hook, kinda"
    (call-interactively #'evil-scroll-line-to-top))
  :init
  (dolist (fun '(consult-line consult-goto-line consult-outline))
    (advice-add fun :after #'hcps/evil-scroll-to-top))
  :general
  (:keymaps 'hcps/leader-map
   "b" #'consult-buffer
   "f b" #'consult-bookmark
   "f r" #'consult-recent-file
   "e p" #'consult-yank-pop
   "n l" #'consult-line
   "n m" #'consult-mark
   "n o" #'consult-outline
   "n g" #'consult-ripgrep
   "n G" #'consult-git-grep
   "n e" #'consult-compile-error
   "n f" #'consult-flycheck
   "n j" #'consult-goto-line
   "m f" #'consult-flymake)
  (:keymaps 'global-map
   "<help> a" #'consult-apropos)
  :custom
  (consult-narrow-key "<")
  (consult-project-root-function
   (lambda ()
     (when-let (project (project-current))
       (car (project-roots project))))))
#+end_src

*** =marginalia=

Adds information on some selection functions such as =find-file= and others. Feels
good to use Emacs built-in function in a prettier way.

#+begin_src emacs-lisp :tangle yes
(use-package marginalia
  :after vertico
  :demand t
  :custom
  (marginalia-annotators
   '(marginalia-annotators-heavy
     marginalia-annotators-light
     nil))
  :general
  (:keymaps 'minibuffer-local-map
   "M-A" #'marginalia-cycle)
  :config
  (marginalia-mode +1))
#+end_src

*** =undo-tree=

Undo and redo and kools with =undo-tree=!

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :delight
  :preface
  (defconst hcps/undo-tree-visualizer-diff t
    "My value for the `undo-tree-visualizer-diff' variable.")
  (defun reset-visualizer-diff (&rest _)
    "Because undo-tree-visualize sets the value of this variable to nil on quit."
    (setq undo-tree-visualizer-diff hcps/undo-tree-visualizer-diff))
  (defun wolfgang/clean-undo-tree ()
    "Clear current buffer's undo-tree."
    (interactive)
    (let ((buff (current-buffer)))
      (if (local-variable-p 'buffer-undo-tree)
          (if (y-or-n-p "Clear buffer-undo-tree? ")
              (progn
                (setq buffer-undo-tree nil)
                (message "Cleared undo-tree of buffer: %s" (buffer-name buff)))
            (message "Cancelled clearing undo-tree of buffer: %s" (buffer-name buff)))
        (error "Buffer %s has no local binding of `buffer-undo-tree'" (buffer-name buff)))))
  :hook
  ((after-init-hook . global-undo-tree-mode)
   (undo-tree-visualizer-mode-hook . hide-mode-line-mode)
   (diff-mode-hook . hcps/hide-evil-tag))
  :init
  (advice-add #'undo-tree-visualize :before #'reset-visualizer-diff)
  :custom
  (undo-tree-visualizer-timestamps t)
  (undo-tree-enable-undo-in-region t)
  (undo-tree-auto-save-history nil)
  (undo-tree-history-directory-alist `((".*" . ,temporary-file-directory)))
  (undo-tree-visualizer-diff hcps/undo-tree-visualizer-diff)
  :general
  (:keymaps 'hcps/leader-map
   "u" #'undo-tree-visualize
   "U" #'wolfgang/clean-undo-tree))
#+end_src

*** =dashboard=

There's some utility in having a cool initial screen actually. And there's a
cool extension that provides such functionality.

#+begin_src emacs-lisp :tangle yes
(use-package dashboard
  :functions dashboard-mode
  :commands (dashboard-mode dashboard-insert-startupify-lists dashboard-refresh-buffer)
  :init
  (defun hcps/open-dashboard ()
    (let ((buffer (switch-to-buffer "*dashboard*")))
      (dashboard-mode)
      buffer))
  (setq-default initial-buffer-choice #'hcps/open-dashboard)
  :custom
  (dashboard-banner-logo-title (format "Welcome to Emacs, %s!" current-user))
  (dashboard-set-heading-icons nil)
  (dashboard-set-file-icons nil)
  (dashboard-center-content t)
  (dashboard-page-separator "\n\n\n")
  (dashboard-startup-banner 'logo)
  (dashboard-items '((recents  . 10)
                     (bookmarks . 5)))
  :general
  (:keymaps 'dashboard-mode-map
   "j" #'widget-forward
   "k" #'widget-backward
   "m" #'dashboard-jump-to-bookmarks
   "r" #'dashboard-jump-to-recent-files)
  :config
  (setq-mode-local dashboard-mode scroll-margin 0)
  (evil-set-initial-state #'dashboard-mode 'emacs)
  (dashboard-setup-startup-hook))
#+end_src

*** =treemacs=

While I've somewhat used =neotree.el=, I believe that =treemacs= is turning out to
be a better option, as it offers a bunch of extra integrating packages and is
overall more popular than the former.

#+begin_src emacs-lisp :tangle yes
(use-package treemacs
  :straight t
  :straight treemacs-evil
  :straight treemacs-projectile
  :init
  (advice-add #'treemacs-mode :around #'disable-scroll-margin)
  :hook
  ((treemacs-mode-hook . hide-mode-line-mode)
   (cfrs-input-mode-hook . evil-emacs-state))
  :custom
  (treemacs-persist-file (expand-file-name "treemacs/persist.org" var-user-dir))
  (treemacs-display-in-side-window t)
  (treemacs-follow-after-init t)
  (treemacs-show-cursor nil)
  (treemacs-no-png-images t)
  (treemacs-project-follow-cleanup t)
  (treemacs-sorting 'alphabetic-desc)
  (treemacs-width 22)
  :general
  ("M-0" #'treemacs-select-window
   "M-t" #'treemacs)
  :config
  (treemacs-follow-mode +1)
  (treemacs-filewatch-mode +1)
  (treemacs-fringe-indicator-mode -1)
  (require 'treemacs-evil)
  (require 'treemacs-projectile))
#+end_src

*** =exec-path-from-shell=

To ensure that Emacs uses the same path and environment as =shell= uses, I use
=exec-path-from-shell=. That way commands that work on the =shell= will certainly
work on Emacs!

#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :straight
  (exec-path-from-shell
   :type git
   :host github
   :repo "purcell/exec-path-from-shell")
  :init
  (setenv "SHELL" "/usr/bin/bash")
  :custom
  (exec-path-from-shell-arguments '("-l"))
  (exec-path-from-shell-variables '("PATH" "MANPATH"))
  :config
  (exec-path-from-shell-initialize))
#+end_src

*** =anzu=

Besides the =ISearch= from Emacs itself or the search function from =evil=, I also
like to use =anzu=.

#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :delight
  (isearch-mode)
  (anzu-mode)
  :preface
  (defun hcps/anzu-update-func (here total)
    (when anzu--state
      (let ((status (cl-case anzu--state
                      (search (format "(%d/%d) " here total))
                      (replace-query (format "(%d replaces) " total))
                      (replace (format "(%d/%d) " here total)))))
        (propertize status 'face 'anzu-mode-line))))
  :custom
  (anzu-cons-mode-line-p t)
  (anzu-mode-line-update-function #'hcps/anzu-update-func)
  :general
  (:keymaps 'hcps/leader-map
   :prefix "e"
   "r" #'anzu-replace-at-cursor-thing
   "q" #'anzu-query-replace-regexp)
  :config
  (global-anzu-mode 1))
#+end_src

I use only the =anzu-replace-at-cursor-thing=, which is a very useful to replace
multiple occurrences of a word fast.

*** =deadgrep=

I enjoy using =ripgrep= to search for stuff using =grep= syntax without the slowness
of it. So, I use =deadgrep=!

#+begin_src emacs-lisp :tangle yes
(use-package deadgrep
  :after evil-collection
  :general
  (:keymaps 'hcps/leader-map
   :prefix "f"
   "g" #'deadgrep)
  :config
  (evil-collection-deadgrep-setup))
#+end_src

*** =link-hint=

=link-hint= replicates the hinting mechanic from trydactil and such.

#+begin_src emacs-lisp :tangle yes
(use-package link-hint
  :custom
  (browse-url-browser-function 'browse-url-firefox)
  :general
  (:keymaps 'hcps/leader-map
   "h" #'link-hint-open-link))
#+end_src

*** =avy=                                                               :WIP:

As I love some overkill, here's =avy=.

#+begin_src emacs-lisp :tangle yes
(use-package avy
  :after evil
  :custom
  (avy-styles-alist
   '((avy-goto-char-2 . post)
     (avy-goto-line   . at-full)))
  (avy-background t)
  :general
  (:states 'normal
   "s" #'avy-goto-char-2
   "S" #'avy-goto-line))
#+end_src

*** =which-key=

The package called =which-key= shows you possible completions to the command
you're typing in the mode-line.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :delight
  :init
  (hcps/hook-require-once pre-command-hook which-key)
  :custom
  (which-key-allow-evil-operators t)
  :config
  (which-key-mode +1))
#+end_src

*** =lsp-mode=                                                   :DEPRECATED:

I imagine anyone knows what is LSP, but oh well. Basically, it is one of the
best features of other famous editors, such as Visual Studio Code. By using
=lsp-mode=, we'll be able to have it too!

#+begin_src emacs-lisp :tangle no
(use-package lsp-mode
  :commands (lsp lsp-mode)
  :delight
  (lsp-mode " lsp")
  :hook
  ((lsp-mode-hook . lsp-headerline-breadcrumb-mode)
   (lsp-mode-hook . lsp-enable-which-key-integration))
  :custom
  (lsp-log-io nil)
  (lsp-auto-guess-root t)
  (lsp-modeline-code-actions-enable t)
  (lsp-auto-configure t)
  (lsp-completion-enable t)
  (lsp-completion-provider :capf)
  (lsp-completion-show-detail nil)
  (lsp-completion-use-last-result nil)
  (lsp-completion-show-kind nil)
  (lsp-idle-delay 0.25)
  (lsp-enable-snippet nil)
  (lsp-enable-semantic-highlighting nil)
  (lsp-modeline-diagnostics-scope :project)
  ;; (lsp-keymap-prefix (concat hcps/leader-key " m l"))
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m l" '(:wk "lsp-mode" :keymap lsp-command-map))
  :config
  (require 'projectile)
  (add-to-list 'lsp-language-id-configuration '(cuda-mode . "cuda"))
  (add-to-list 'lsp-language-id-configuration '(".*\\.cu$" . "cuda")))
#+end_src

This package does have an extra sister package: =lsp-ui=.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
  :after lsp-mode
  :custom
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-delay 2.0)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-sideline-delay 1)
  (lsp-ui-sideline-update-mode 'line)
  (lsp-ui-sideline-show-diagnostics t)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-sideline-show-code-actions nil)
  (lsp-ui-peek-enable nil))
#+end_src

*** =flycheck=

=flycheck= provides a reliable source to syntax checking in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :straight t
  :straight pos-tip
  :straight flycheck-pos-tip
  :commands (global-flycheck-mode flycheck-mode)
  :delight
  (flycheck-mode " fc")
  :hook
  (flycheck-mode-hook . flycheck-pos-tip-mode)
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay 1.0)
  (flycheck-idle-change-delay 1.5)
  :config
  (require 'flycheck-pos-tip))
#+end_src

*** =eglot=                                                             :WIP:

Non-bloated =lsp-mode= alternative. Always strive for leaner, simpler alternatives
(and try to contribute to them when possible).

#+begin_src emacs-lisp :tangle yes
(use-package eglot
  :commands eglot-ensure
  :hook
  ((eglot-managed-mode-hook . turn-on-eldoc-mode)
   (eglot-managed-mode-hook . company-mode))
  :init
  (setq-default eglot-workspace-configuration
                '((:diagnostics . ((:onChange . 5)))
                  (:completion . ((:filterAndSort . :json-false)))))
  :general
  (:keymaps 'hcps/leader-map
   :prefix "m e"
   "f" #'eglot-format
   "r" #'eglot-rename
   "a" #'eglot-code-actions
   "d" #'eglot-find-declaration
   "i" #'eglot-find-implementation
   "C-r" #'eglot-reconnect
   "C-s" #'eglot-shutdown
   "C-a" #'eglot-shutdown-all)
  :custom
  (eglot-autoreconnect t)
  (eglot-autoshutdown t)
  (eglot-extend-to-xref t)
  (eglot-connect-timeout 60)
  (eglot-send-changes-idle-time 0.10)
  :config
  (add-to-list 'eglot-server-programs
               '((c++-mode c-mode) . ("clangd")))
  (add-to-list 'eglot-server-programs
               '((clojure-mode clojurec-mode clojurescript-mode) . ("clojure-lsp")))
  (require 'xref))
#+end_src

*** =highlight-numbers=

This highlights numbers in =prog-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-numbers
  :commands highlight-numbers-mode
  :hook
  (prog-mode-hook . highlight-numbers-mode))
#+end_src

*** =highlight-escape-sequences=

And this is to highlight escape sequences in some common modes:

#+begin_src emacs-lisp :tangle yes
(use-package highlight-escape-sequences
  :commands turn-on-hes-mode
  :preface
  (defconst hes-shell-escape-sequence-re "\\(\\\\\\([\"'?\\abfnrtv]\\)\\)"
    "Simple regex to match any common escaped character in sh-mode")
  :hook
  (prog-mode-hook . turn-on-hes-mode)
  :config
  (add-to-list 'hes-mode-alist `(ggo-mode . ,hes-shell-escape-sequence-re))
  (add-to-list 'hes-mode-alist `(shell-script-mode . ,hes-shell-escape-sequence-re)))
#+end_src

*** =flyspell=

Of course, =flyspell= corrects your writing!

#+begin_src emacs-lisp :tangle yes
(use-package wucuo
  :delight
  (flyspell-mode " fs")
  (flyspell-prog-mode " fs")
  :hook
  (text-mode-hook . wucuo-start)
  :custom
  (ispell-program-name "aspell")
  (ispell-extra-args '("--sug-mode=ultra" "--run-together" "--run-together-limit=16"))
  (flyspell-issue-message-flag nil)
  (flyspell-issue-welcome-flag nil)
  :general
  (:keymaps 'hcps/leader-map
   "e d" #'ispell-change-dictionary)
  :config
  (add-to-list 'ispell-skip-region-alist '("^#+begin_src" . "^#+end_src")))
#+end_src

*** =diff-hl=

=diff-hl= to highlight any diffs!

#+begin_src emacs-lisp :tangle yes
(use-package diff-hl
  :commands (diff-hl-mode turn-on-diff-hl-mode diff-hl-magit-post-refresh))
#+end_src

*** =ace-window=

=ace-window= creates labels so we can jump windows with precision:

#+begin_src emacs-lisp :tangle yes
(use-package ace-window
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :general
  (:keymaps 'hcps/leader-map
   "w o" #'ace-window))
#+end_src

*** =super-save=

=super-save= auto-saves buffers when you switch or close buffers or when Emacs
loses focus, etc.

#+begin_src emacs-lisp :tangle yes
(use-package super-save
  :disabled
  :delight
  :init
  (hcps/hook-require-once before-save-hook super-save)
  :custom
  (super-save-auto-save-when-idle t)
  (super-save-remote-files nil)
  (super-save-idle-duration 60)
  :config
  (add-to-list 'super-save-triggers #'ace-window)
  (super-save-mode +1))
#+end_src

*** =yasnippet=

I use =yasnippet= to handle my snippet needs.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :delight
  (yas-minor-mode " ys")
  :commands (yas-minor-mode yas-expand-snippet yas-lookup-snippet)
  :preface
  (defun hcps/get-pretty-source-path (path)
    (replace-regexp-in-string
     ".*\\(?:src\\|source\\|include\\|inc\\)/\\(.+\\)$" "\\1"
     path))
  (defun hcps/get-pretty-include-guard (path)
    (concat
     "_"
     (upcase (replace-regexp-in-string "[/.]" "_" (hcps/get-pretty-source-path path)))
     "_"))
  :init
  (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  :hook
  (html-mode-hook . yas-minor-mode)
  :custom
  (yas-snippet-dirs `(,(expand-file-name "snippets" root-dir)))
  :config
  (general-def 'insert 'yas-minor-mode-map
    "<tab>" yas-maybe-expand)
  (yas-reload-all)
  (yas-load-directory auto-insert-directory))
#+end_src

*** =vimish-fold=                                                       :WIP:

Enables vim-like folding of regions.

#+begin_src emacs-lisp :tangle yes
(use-package vimish-fold
  :general
  (:keymaps 'vimish-fold-folded-keymap
   "C-<tab>" #'vimish-fold-unfold)
  (:keymaps 'vimish-fold-unfolded-keymap
   "C-<tab>" #'vimish-fold-refold)
  :custom
  (vimish-fold-header-width 79)
  :config
  (vimish-fold-global-mode 1))
#+end_src

*** =projectile=

For project management in Emacs, there's no better choice than =projectile=, which
is widely loved by the community.

It supports project-wide commands and actions, like killing all project buffers
or searching the whole project and replacing something.

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :commands projectile-mode
  :preface
  (defun hcps/projectile-custom-mode-line ()
    "Report project name and type in the modeline."
    (let ((project (downcase (projectile-project-name))))
      (unless (or (string-equal project "-") (string-empty-p project))
        (format "%s:%s" projectile-mode-line-prefix project))))
  :custom
  (projectile-completion-system 'default)
  (projectile-mode-line-prefix " pj")
  (projectile-mode-line-function #'hcps/projectile-custom-mode-line)
  (projectile-switch-project-action 'projectile-find-file)
  (projectile-find-dir-includes-top-level t)
  (projectile-enable-caching t)
  (projectile-files-cache-expire nil)
  (projectile-indexing-method 'hybrid)
  (projectile-project-search-path (list proj-user-dir))
  (projectile-project-root-files-top-down-recurring
   '(".projectile" "compile_commands.json" ".ccls" ".svn" "CVS" "Makefile"))
  (projectile-globally-ignored-file-suffixes
   '(".elc" ".pyc" ".o" "~" ".so"))
  (projectile-globally-ignored-files
   '(".DS_Store" "Icon" "TAGS" "__PYCACHE__"))
  (projectile-globally-ignored-directories
   '(".DS_Store" "__PYCACHE__" ".idea" ".ensime_cache"
     ".eunit" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs"
     ".tox" ".svn" ".stack-work" ".clangd" ".vscode" ".cache"))
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "P" '(:wk "projectile" :keymap projectile-command-map))
  :config
  ;; clean dead projects when Emacs is idle
  (run-with-idle-timer 180 nil #'projectile-cleanup-known-projects)
  ;; enable projectile mode
  (projectile-mode))
#+end_src

*** =magit=

Obviously, any configuration file that says it deserves *any* respect should
feature =magit=, as it is, hands down, the best =git= front-end in the visible
universe, nay, in the whole multiverse.

#+begin_src emacs-lisp :tangle yes
(use-package magit
  :hook
  ((after-save-hook . magit-after-save-refresh-status)
   (magit-pre-display-buffer-hook . evil-emacs-state)
   (magit-mode-hook . hcps/hide-evil-tag)
   (git-commit-mode-hook . evil-emacs-state)
   (magit-file-mode-hook . diff-hl-mode)
   (magit-post-refresh-hook . diff-hl-magit-post-refresh))
  :preface
  ;; easy on-off for the following function
  (defcustom magit-push-protected-branch nil
    "When set, ask for confirmation before pushing to this branch (e.g. master)."
    :type 'string
    :safe #'stringp
    :group 'magit)
  ;; are you sure you wanna push to master?
  (defun magit-push--protected-branch (magit-push-fun &rest args)
    "Ask for confirmation before pushing a protected branch."
    (if (equal magit-push-protected-branch (magit-get-current-branch))
        ;; Arglist is (BRANCH TARGET ARGS)
        (if (yes-or-no-p (format "Push branch %s? " (magit-get-current-branch)))
            (apply magit-push-fun args)
          (error "Push aborted by user"))
      (apply magit-push-fun args)))
  :init
  (advice-add #'magit-push-current-to-pushremote
              :around #'magit-push--protected-branch)
  (advice-add #'magit-push-current-to-upstream
              :around #'magit-push--protected-branch)
  :custom
  (git-commit-major-mode 'text-mode)
  (magit-push-protected-branch "master")
  (magit-save-repository-buffers 'dontask)
  (magit-refs-show-commit-count 'all)
  (magit-log-buffer-file-locked t)
  (magit-revision-show-gravatars nil)
  (magit-bury-buffer-function 'magit-mode-quit-window)
  :general
  (:keymaps 'hcps/leader-map
   :prefix "g"
   "p" #'magit-list-repositories
   "g" #'magit-status
   "d" #'magit-dispatch
   "f" #'magit-file-dispatch
   "l" #'magit-log
   "b" #'magit-blame)
  (:keymaps '(magit-log-mode-map magit-diff-mode-map magit-status-mode-map magit-mode-map magit-diff-section-base-map)
   "j" #'magit-next-line
   "k" #'magit-previous-line
   "C-j" #'magit-section-forward
   "C-k" #'magit-section-backward
   "M-j" #'magit-section-forward-sibling
   "M-k" #'magit-section-backward-sibling)
  (:keymaps 'magit-status-mode-map
   "h" #'magit-diff-toggle-refine-hunk
   "l" #'magit-log
   "J" #'magit-status-jump
   "K" #'magit-discard)
  :config
  (transient-replace-suffix 'magit-dispatch #'magit-discard '("K" "Discard" magit-discard)))
#+end_src

*** =git-timemachine=

Also, =git-timemachine= is a beautiful way to walk through git history:

#+begin_src emacs-lisp :tangle yes
(use-package git-timemachine
  :after magit
  :demand t
  :hook
  (git-timemachine-mode-hook . evil-normalize-keymaps)
  :general
  (:states '(normal visual)
   :keymaps 'git-timemachine-mode-map
   "q" #'git-timemachine-quit
   "w" #'git-timemachine-kill-abbreviated-revision
   "g" #'git-timemachine-show-nth-revision
   "c" #'git-timemachine-show-commit
   "C-j" #'git-timemachine-show-next-revision
   "C-k" #'git-timemachine-show-previous-revision)
  (:keymaps 'hcps/leader-map
   "g t" #'git-timemachine)
  :config
  (evil-make-overriding-map git-timemachine-mode-map 'normal))
#+end_src

*** =expand-region=

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+begin_src emacs-lisp :tangle yes
(use-package expand-region
  :general
  ("C-+" #'er/contract-region
   "C-=" #'er/expand-region))
#+end_src

*** =smartparens=

When in need of smart pairing, look no further than =smartparens=!

#+begin_src emacs-lisp :tangle no
(use-package smartparens
  :delight (smartparens-mode " sp")
  :commands (smartparens-mode smartparens-strict-mode)
  :custom
  (sp-base-key-bindings 'paredit)
  (sp-autoskip-closing-pair 'always)
  (sp-hybrid-kill-entire-symbol nil)
  :config
  (require 'smartparens-config)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1))
#+end_src

*** =rainbow-delimiters=

With that, =rainbow-delimiters= is a great match:

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode)
#+end_src

*** =beacon=

This little add-on will highlight big cursor movements.

#+begin_src emacs-lisp :tangle yes
(use-package beacon
  :init
  (hcps/hook-require-once pre-command-hook beacon)
  :delight
  :config
  (beacon-mode +1))
#+end_src

*** =aggressive-indent=

I use =aggressive-indent= to keep my code indented as I type.

#+begin_src emacs-lisp :tangle yes
(use-package aggressive-indent
  :commands aggressive-indent-mode
  :custom
  (aggressive-indent-comments-too t)
  (aggressive-indent-sit-for-time 0.05)
  (aggressive-indent-dont-electric-modes '(c-mode c++-mode))
  :config
  (add-to-list 'aggressive-indent-protected-commands 'undo-tree-visualize-undo)
  (add-to-list 'aggressive-indent-protected-commands 'undo-tree-visualize-redo)
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim)
  (add-to-list 'aggressive-indent-protected-commands 'evil-redo)
  (add-to-list 'aggressive-indent-protected-commands 'evil-undo))
#+end_src

*** =highligh-indent-guides=

Also =highligh-indent-guides= is very useful, as Emacs doesn't come with it out of
the box.

#+begin_src emacs-lisp :tangle yes
(use-package highlight-indent-guides
  :delight
  (highlight-indent-guides-mode)
  :commands
  (highlight-indent-guides-auto-set-faces highlight-indent-guides-mode)
  :preface
  (defun highlight-indent-guides-auto-set-faces-with-frame (frame)
    (with-selected-frame frame
      (highlight-indent-guides-auto-set-faces)))
  :hook
  ((prog-mode-hook . highlight-indent-guides-mode)
   (highlight-indent-guides-mode-hook . highlight-indent-guides-auto-set-faces))
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (highlight-indent-guides-character ?|)
  (highlight-indent-guides-delay 0.05)
  (highlight-indent-guides-auto-odd-face-perc 5)
  (highlight-indent-guides-auto-even-face-perc 5)
  (highlight-indent-guides-auto-character-face-perc 10))
#+end_src

*** =helpful=

=helpful= is a package that is overall an improvement over the default =help=
windows.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :general
  (:keymaps '(global-map special-mode-map override)
   :prefix "C-h"
   "F" #'helpful-function
   "C" #'helpful-command
   "M" #'helpful-macro)
  (:keymaps '(global-map special-mode-map override)
   [remap describe-key] #'helpful-key
   [remap describe-variable] #'helpful-variable
   [remap describe-function] #'helpful-callable))
#+end_src

*** =engine-mode=                                                :DEPRECATED:

=engine-mode= is a minor mode that allow you to easily make queries to the web
without leaving Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package engine-mode
  :disabled
  :config
  (engine-mode +1)
  ;; (defengine google
  ;;   "https://www.google.com/search?q="
  ;;   :keybinding "g")
  )
#+end_src

*** =openwith=

=openwith= is a small and useful tool to set how you want to open your files with
Emacs. I use it to set the opener of pdfs in my Emacs, as well to other diverse
media files.

#+begin_src emacs-lisp :tangle yes
(use-package openwith
  :init
  (hcps/hook-require-once pre-command-hook openwith)
  :custom
  (openwith-associations
   '(("\\.pdf$" "zathura" (file))
     ;; ("\\.jpe?g$" "sxiv" (file))
     ;; ("\\.png$" "sxiv" (file))
     ;; ("\\.svg$" "sxiv" (file))
     ;; ("\\.jpeg$" "sxiv" (file))
     ;; ("\\.bmp$" "sxiv" (file))
     ("\\.flac$" "mpv" (file))
     ("\\.mkv$" "mpv" (file))
     ("\\.mp3$" "mpv" (file))
     ("\\.mp4$" "mpv" (file))))
  (openwith-confirm-invocation nil)
  :config
  (openwith-mode +1))
#+end_src

*** =crux=

Which stands for...

#+begin_quote
A Collection of Ridiculously Useful eXtensions for Emacs.
#+end_quote

... yeah.

#+begin_src emacs-lisp :tangle yes
(use-package crux
  :delight
  (crux-reopen-as-root-mode)
  :commands
  (crux-reopen-as-root-mode crux-reopen-as-root crux-with-region-or-buffer)
  :init
  ;; supposedly get expanded at compile time
  ;; also don't need to be here, but where else should i put them?
  (defadvice indent-region
      (before with-region-or-buffer activate compile)
    (interactive
     (if mark-active
         (list
          (region-beginning)
          (region-end))
       (list
        (point-min)
        (point-max)))))

  (defadvice eval-region
      (before with-region-or-buffer activate compile)
    (interactive
     (if mark-active
         (list
          (region-beginning)
          (region-end))
       (list
        (point-min)
        (point-max)))))

  (defadvice untabify
      (before with-region-or-buffer activate compile)
    (interactive
     (if mark-active
         (list
          (region-beginning)
          (region-end))
       (list
        (point-min)
        (point-max)))))
  :general
  (:keymaps 'hcps/leader-map
   ;; file stuff
   :prefix "f"
   "s" #'crux-sudo-edit
   "m" #'crux-rename-buffer-and-file ;; as in `move'
   "d" #'crux-delete-buffer-and-file
   "c" #'crux-find-user-custom-file
   "n" #'crux-create-scratch-buffer
   "i" #'crux-find-user-init-file))
#+end_src

*** =page-break-lines=

To make pretty page breaks in your Emacs buffers:

#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines
  :commands page-break-lines-mode
  :delight
  :hook
  ((prog-mode-hook . page-break-lines-mode)
   (text-mode-hook . page-break-lines-mode))
  :custom
  (page-break-lines-max-width (floor (/ fill-column 2)))
  (page-break-lines-char ?-)
  :custom-face
  (page-break-lines ((t :inherit font-lock-comment-face :bold nil :italic nil))))
#+end_src

*** =writeroom-mode=

A nice writing environment for Emacs in a minor-mode.

#+begin_src emacs-lisp :tangle yes
(use-package writeroom-mode
  :straight t
  :straight visual-fill-column
  :custom
  (writeroom-fullscreen-effect 'maximized)
  (writeroom-width (+ 3 fill-column))
  :general
  (:keymaps 'hcps/leader-map
   "v w" #'writeroom-mode))
#+end_src

*** =ssh=

Here's a small package that allows remotely opening sessions.

#+begin_src emacs-lisp :tangle yes
(use-package ssh
  :after shell
  :preface
  (defcustom ssh-remote-user-server nil
    "Dummy variable that holds a server name."
    :type 'string
    :safe #'stringp
    :group 'ssh)
  (defun hcps/get-user-server ()
    "Call to set and print the user server."
    (interactive)
    (if (equal ssh-remote-user-server nil)
    (setq ssh-remote-user-server
          (read-from-minibuffer "What server to store: ")))
    (concat "/ssh:" ssh-remote-user-server ":"))
  (defun hcps/store-user-remote ()
    "Store a server name to the desired target."
    (interactive)
    (let* ((read-server (read-from-minibuffer
             (format "What server to store (current: %s): " ssh-remote-user-server)))
       (server-to-connect (if (equal read-server "") ssh-remote-user-server read-server)))
      (setq ssh-remote-user-server server-to-connect)))
  :custom
  (shell-command-dont-erase-buffer t)
  (ssh-directory-tracking-mode t)
  :config
  (shell-dirtrack-mode t))
#+end_src

*** =ligature.el=

Obscure but nice way to enable ligature fonts.

#+begin_src emacs-lisp :tangle yes
(use-package ligature
  :disabled
  :demand t
  :straight
  (ligature
   :type git
   :host github
   :repo "mickeynp/ligature.el")
  :config
  (ligature-set-ligatures 't '("www"))
  ;; enable Iosevka ligatures in programming modes
  (ligature-set-ligatures
   'prog-mode
   '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->"
     "<--->" "<---->" "<!--" "<==" "<===" "<=" "=>" "=>>" "==>"
     "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---" "<~~"
     "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!==" ":=" ":-"
     ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:"
     "<******>" "++" "+++"))
  (global-ligature-mode +1))
#+end_src

*** =emacs-vterm=

So we have an usable terminal inside emacs that doesn't blow up at the slightest
stress.

#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :hook
  ((vterm-mode-hook . hcps-custom-vterm-setup)
   (vterm-mode-hook . buffer-face-mode)
   (vterm-mode-hook . (lambda () (hl-line-mode -1)))
   (vterm-mode-hook . evil-emacs-state))
  :custom
  (vterm-ignore-blink-cursor t)
  :config
  (setq-mode-local vterm-mode evil-move-cursor-back nil)
  (setq-mode-local vterm-mode evil-default-state 'emacs)
  (setq-mode-local vterm-mode buffer-face-mode-face '(:family "Unifont" :height 120)))
#+end_src

*** =mixed-pitch-mode=

So we don't trouble ourselves with setting which fonts should be fixed and which
should be variable.

#+begin_src emacs-lisp :tangle yes
(use-package mixed-pitch
  :disabled
  :delight
  (mixed-pitch-mode " mp")
  :hook
  (text-mode-hook . mixed-pitch-mode)
  :custom-face
  (variable-pitch ((t (:font "Iosevka Aile" :weight light)))))
#+end_src

*** =hl-todo=

Pretty =TODO= highlighting :)

#+begin_src emacs-lisp :tangle yes
(use-package hl-todo
  :hook
  (prog-mode-hook . hl-todo-mode))
#+end_src

*** =emacs-tree-sitter=

Trying out and hopefully will switch to in in a few languages.

#+begin_src emacs-lisp :tangle yes
(use-package tree-sitter
  :straight t
  :straight tree-sitter-langs
  :commands (tree-sitter-mode global-tree-sitter-mode)
  :delight (tree-sitter-mode " ts")
  :hook
  (tree-sitter-mode-hook . tree-sitter-hl-mode)
  :custom-face
  (tree-sitter-hl-face:function.call ((t (:foreground "#8ec07c"))))
  (tree-sitter-hl-face:method.call ((t (:foreground "#8ec07c"))))
  (tree-sitter-hl-face:label ((t (:inherit font-lock-builtin-face :slant italic))))
  :config
  (require 'tree-sitter-langs))
#+end_src

*** =lispy=

Supposedly this works better than =smartparens= when using Evil keybindings.
Hopefully this is the case, 'cause I don't really use =smartparens= keybindings
the way (nor the frequency) I should be.

#+begin_src emacs-lisp :tangle yes
(use-package lispy
  :disabled
  :commands (lispy-mode)
  :delight (lispy-mode " lp"))
#+end_src

With it, also configure the Evil support layer, =lispyville=

#+begin_src emacs-lisp :tangle yes
(use-package lispyville
  :delight (lispyville-mode " lv")
  :hook
  (eval-expression-minibuffer-setup-hook . lispyville-mode)
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     escape
     (additional-movement normal motion)
     (additional-wrap normal insert)
     additional-insert
     slurp/barf-lispy)))
#+end_src

*** =docker=

This configuration includes both easier interaction with Docker and =tramp=
support for editing files inside containers.

#+begin_src emacs-lisp :tangle yes
(use-package docker-tramp
  :disabled
  :after tramp
  :demand t)
#+end_src

*** =embark=

Finally, adding this amazing package

#+begin_src emacs-lisp :tangle yes
(use-package embark
  :general
  (:keymaps '(override normal visual motion)
   "M-SPC" #'embark-act
   "M-S-SPC" #'embark-dwim))
#+end_src

*** =embark-consult=

To provide live preview of =embark= actions.

#+begin_src emacs-lisp :tangle yes
(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook
  (embark-collect-mode-hook . consult-preview-at-point-mode))
#+end_src

*** =notmuch=

=notmuch= interface for Emacs!

#+begin_src emacs-lisp :tangle yes
(use-package notmuch
  :commands (notmuch-hello notmuch-show notmuch-tree notmuch-search)
  :hook
  ((notmuch-hello-mode-hook    . evil-emacs-state)
   (notmuch-hello-refresh-hook . evil-emacs-state)
   (notmuch-search-hook        . evil-emacs-state)
   (notmuch-search-mode-hook   . evil-emacs-state)
   (notmuch-tree-mode-hook     . evil-emacs-state)
   (notmuch-message-mode-hook  . evil-insert-state))
  :general
  (:keymaps 'hcps/leader-map
   :prefix "l"
   "h" #'notmuch-hello
   "s" #'notmuch-search
   "t" #'notmuch-tree
   "w" #'notmuch-show
   "n" #'notmuch-poll)
  :custom
  (notmuch-search-oldest-first nil)
  (notmuch-saved-searches
   '((:name "inbox" :query "tag:inbox" :key "i")
     (:name "unread" :query "tag:unread" :key "u")
     (:name "graduacao" :query "tag:graduacao" :key "g")
     (:name "cadeiras" :query "tag:cadeira" :key "c")
     (:name "sent" :query "tag:sent" :key "t")
     (:name "all mail" :query "*" :key "a"))))
#+end_src

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides nice
support for a lot of packages and is very pleasant for the eyes.

- [ ] Use [[https://gitlab.com/jjzmajic/ewal][this]].

#+begin_src emacs-lisp :tangle yes
(use-package gruvbox-theme
  :demand t
  :config
  (load-theme 'gruvbox-dark-medium t))
#+end_src

* File modes

Here I'll store any package load and configurations related to languages and
file types.

I still need to add packages relating to these languages:

- [ ] Scala
- [X] Dot (using Graphviz)
- [ ] English (as in literal english)
- [ ] Coq (yes, I'm slowly turning into what I most hate (check the hrs config!))
- [X] PKGBUILD
- [X] Markdown
- [X] Clojure
- [ ] =prog-mode=
- [ ] =text-mode=
- [X] =bison-mode=
- [ ] Typescript
- [ ] Scheme and Geiser

** Org

=org-mode= is probably *the* killer mode and one of the main reasons as to why
anyone should try Emacs.

*Important links*:
- [[https://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/]]
- [[https://doc.norang.ca/org-mode.html#AgendaSetup]]
- [[https://joshrollinswrites.com/help-desk-head-desk/2020-07-16/]]
- [[https://blog.jethro.dev/posts/capturing_inbox/]]

#+begin_src emacs-lisp :tangle yes
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :straight t
  :straight org-contrib
  :delight
  (org-indent-mode nil org-indent)
  :preface
  (defconst org-electric-pairs '((?/ . ?/) (?= . ?=) (?~ . ?~)))
  :hook
  ((org-mode-hook . auto-fill-mode)
   (org-mode-hook . hes-mode)
   (org-mode-hook . yas-minor-mode)
   ;; (org-mode-hook . flycheck-mode)
   (org-mode-hook . eldoc-mode)
   ;; (org-mode-hook . visual-line-mode)
   (org-mode-hook . (lambda () (whitespace-toggle-options 'lines-tail)))
   (org-log-buffer-setup-hook . evil-emacs-state)
   (org-log-buffer-setup-hook . hcps/hide-evil-tag))
  :custom
  (org-return-follows-link t)
  ;; the following used to be '(latex script entities)
  (org-highlight-latex-and-related nil)
  (org-hide-leading-stars t)
  (org-hide-emphasis-markers t)
  (org-support-shift-select nil)
  (org-link-descriptive t)
  (org-log-done 'note)
  (org-directory (expand-file-name "Org" onedrive-user-dir))
  (org-cycle-emulate-tab t)
  (org-use-property-inheritance nil)
  (org-startup-indented t)
  (org-startup-folded t)
  (org-outline-path-complete-in-steps nil)
  (org-fontify-done-headline t)
  (org-fontify-todo-headline t)
  ;; 10 pixels because default-font-width doesn't work with daemon mode
  (org-image-actual-width (round (* 10 fill-column 0.85)))
  (org-display-remote-inline-images 'download)
  (org-modules
   '(ol-w3m ;; this comment is here for identation purposes
     ol-bbdb ol-bibtex ol-docview ol-gnus ol-info ol-irc ol-mhe
     ol-rmail ol-eww org-tempo org-inlinetask org-indent))
  ;; logging stuff
  (org-tag-alist
   '(("noexport"   . ?e)
     ("ignore"     . ?i)
     ("TOC"        . ?t)
     ("DEPRECATED" . ?d)
     ("NOTE"       . ?n)
     ("WIP"        . ?g)
     ("PERSONAL"   . ?p)
     ("MEETING"    . ?m)
     ("REFILE"     . ?f)
     ("REPEAT"     . ?r)
     ("UNI"        . ?u)
     ("WORK"       . ?w)
     ("URGENT"     . ?a)))
  (org-todo-keywords '((sequence "TODO(t)" "STARTED(s!)" "|" "DONE(d!)")
                       (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))
  (org-log-into-drawer t)
  ;; (org-effort-property "EFFORT")
  (org-global-properties
   '(("EFFORT_ALL" . "0 1 2 3 4 5 6 7 8 9 10")))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   "t" #'org-todo              ; mark a TODO item as DONE
   "$" #'org-end-of-line       ; smarter behaviour on headlines etc.
   "0" #'org-beginning-of-line ; ditto
   "-" #'org-ctrl-c-minus      ; change bullet style
   "<" #'org-metaleft          ; outdent
   ">" #'org-metaright         ; indent
   "M-h" #'org-do-promote
   "M-l" #'org-do-demote
   "M-H" #'org-promote-subtree
   "M-L" #'org-demote-subtree
   "C-i" #'org-toggle-inline-images
   "C-l" #'org-toggle-link-display
   "C-j" #'outline-next-visible-heading
   "C-k" #'outline-previous-visible-heading
   "C-S-k" #'outline-up-heading
   "<tab>" #'outline-toggle-children
   "<backtab>" #'org-global-cycle
   "<return>" #'org-open-at-point
   "<S-left>" nil
   "<S-right>" nil
   "<S-up>" nil
   "<S-down>" nil)
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "v n s" #'org-narrow-to-subtree
   "v n b" #'org-narrow-to-block
   "m t" #'org-set-tags-command
   "m f" #'org-set-effort
   "m d" #'org-deadline
   "m h" #'org-schedule
   "m o" #'org-priority
   "m p" #'org-set-property
   "m s" #'org-match-sparse-tree
   "m l" #'org-insert-link)
  (:keymaps 'hcps/leader-map
   "o b" #'org-switchb)
  :config
  (setq org-effort-property "EFFORT")
  (setq-mode-local org-mode electric-pair-inhibit-predicate (lambda (c) (if (char-equal c ?<) t (electric-pair-default-inhibit c))))
  (setq-mode-local org-mode electric-pair-pairs (append electric-pair-pairs org-electric-pairs)))
#+end_src

*** Add-ons

Stuff that increases the capabilities of =org-mode=

**** =toc-org=

With it I also use =toc-org=, which is an useful way to automatically
maintain an updated table of contents of your =.org= file. [[https://github.com/snosov1/toc-org][Check it out!]]

#+begin_src emacs-lisp :tangle yes
(use-package toc-org
  :hook
  (org-mode-hook . toc-org-mode)
  :custom
  (toc-org-max-depth 3)
  (toc-org-hrefify-default "org"))
#+end_src

**** =org-appear=

Makes the emphasis markers magically show up when you hover those words!

#+begin_src emacs-lisp :tangle yes
(use-package org-appear
  :hook
  (org-mode-hook . org-appear-mode))
#+end_src

**** =org-ref=

[[https://github.com/jkitchin/org-ref][org-ref]] is the de-facto way to cite inside Emacs, as it supports
multiple export backends and such

#+begin_src emacs-lisp :tangle yes
(use-package org-ref
  :preface
  (defconst hcps/user-org-ref-path
    (expand-file-name "Documentos/Papers" onedrive-user-dir))
  :custom
  (org-ref-bibliography-notes (expand-file-name "notes.org" hcps/user-org-ref-path))
  (org-ref-default-bibliography `(,(expand-file-name "references.bib" hcps/user-org-ref-path)))
  (reftex-default-bibliography `(,(expand-file-name "references.bib" hcps/user-org-ref-path)))
  (org-ref-pdf-directory hcps/user-org-ref-path)
  (org-ref-completion-library 'org-ref-ivy-cite)
  (org-ref-insert-cite-function 'org-ref-ivy-insert-cite-link)
  (org-ref-insert-label-function 'org-ref-ivy-insert-label-link)
  (org-ref-insert-ref-function 'org-ref-ivy-insert-ref-link)
  (org-ref-show-broken-links nil)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m c" #'org-ref-cite-hydra/body)
  :config
  (require 'doi-utils))
#+end_src

**** =org-agenda=

The ultimate journaling tool of the ultimate note-taking tool.

#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :straight (:type built-in)
  :preface
  (defun hcps/open-agenda ()
    "Opens my custom org-agenda command."
    (interactive)
    (org-agenda nil " "))
  (defun hcps/goto-inbox ()
    "Open the organizer file."
    (interactive)
    (find-file (expand-file-name "organizer.org" org-directory)))
  :hook
  (org-agenda-mode-hook . hcps/hide-evil-tag)
  :custom
  (org-columns-default-format
   "%20CATEGORY(FILE) %35ITEM(TASK) %PRIORITY(P) %EFFORT(E) %DEADLINE(D) %TAGS(T)")
  (org-agenda-files
   (append (directory-files-recursively (expand-file-name "Org" onedrive-user-dir) "\\.org\\'")
       (directory-files-recursively proj-user-dir "^hcps[[:alnum:]-]*\\.org\\'")))
  (org-agenda-start-with-log-mode t)
  (org-agenda-use-tag-inheritance t)
  (org-agenda-block-separator nil)
  (org-agenda-view-columns-initially t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-log-mode-items '(clock closed))
  (org-agenda-custom-commands
   `((" " "Agenda"
      ((agenda ""
           ((org-agenda-span 'week)
        (org-deadline-warning-days 0)))
       (todo "STARTED"
         ((org-agenda-overriding-header "IN PROGRESS")
          (org-agenda-block-separator ?-)))
       (tags "URGENT"
         ((org-agenda-overriding-header "URGENT TASKS")))
       (tags "UNI"
         ((org-agenda-overriding-header "UNI STUFF")))
       (todo "TODO"
         ((org-agenda-overriding-header "PROJECTS")
          (org-agenda-files ',(directory-files-recursively proj-user-dir "^hcps[[:alnum:]-]*\\.org\\'"))))
       (tags "REFILE"
         ((org-agenda-overriding-header "TO REFILE")
          (org-agenda-files '(,(expand-file-name "Org/organizer.org" onedrive-user-dir)))))))))
  :general
  (:keymaps 'hcps/leader-map
   "o a" #'hcps/open-agenda
   "o i" #'hcps/goto-inbox))
#+end_src

**** =org-journal=

=org-journal= is a powerful tool to journal your day.

#+begin_src emacs-lisp :tangle yes
(use-package org-journal
  :custom
  (org-journal-dir (format-time-string (expand-file-name "Org/Journal/%Y" onedrive-user-dir)))
  (org-journal-file-type 'monthly)
  (org-journal-file-format "%Y%m")
  (org-journal-date-format "%e %b %Y (%A)")
  (org-journal-time-format "")
  :general
  (:keymaps 'hcps/leader-map
   "o j" #'org-journal-new-entry)
  :config
  (evil-initial-state 'org-journal-mode 'insert))
#+end_src

**** =org-capture=

It is built-in and it is beautiful.

#+begin_src emacs-lisp :tangle yes
(use-package org-capture
  :straight (:type built-in)
  :commands (org-capture-mode org-capture-upgrade-templates)
  :preface
  (defconst org-main-notes-file (expand-file-name "Org/organizer.org" onedrive-user-dir)
    "File that I use to store notes before reviewing them.")
  :hook
  (org-capture-mode-hook . evil-insert-state)
  :custom
  (org-default-notes-file org-main-notes-file)
  (org-capture-templates
   `(("t" "todo" entry (file+headline ,org-main-notes-file "Inbox")
      "* TODO %? :REFILE:\nDEADLINE: %^T\n%U\n"
      :empty-lines 1 :kill-buffer t)
     ("n" "note" entry (file+headline ,org-main-notes-file "Inbox")
      "* %? :NOTE:REFILE:\n%U\n"
      :empty-lines 1 :kill-buffer t)
     ("m" "meeting" entry (file+headline ,org-main-notes-file "Inbox")
      "* %? :MEETING:REFILE:\nSCHEDULED: %^{Meeting date?}T\n%U\n"
      :empty-lines 1 :kill-buffer t)))
  :general
  (:keymaps 'hcps/leader-map
   "o c" #'org-capture))
#+end_src

**** =org-id=

Apparently this doesn't get loaded with =org= by default?

#+begin_src emacs-lisp :tangle yes
(use-package org-id
  :after org
  :straight (:type built-in)
  :custom
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (org-id-locations-file-relative t))
#+end_src

**** =org-attach=

Configurations related to this feature in specific

#+begin_src emacs-lisp :tangle yes
(use-package org-attach
  :after org
  :straight (:type built-in)
  :custom
  (org-attach-use-inheritance 'selective)
  (org-attach-dir-relative t)
  (org-attach-id-dir "attach/")
  (org-attach-id-to-path-function-list
   '(org-attach-id-ts-folder-format org-attach-id-uuid-folder-format))
  (org-attach-preferred-new-method 'id)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m a" #'org-attach))
#+end_src

**** =org-refile=

As of Org 9.4, there is a =org-refile.el=!

#+begin_src emacs-lisp :tangle yes
(use-package org-refile
  :after org
  :straight (:type built-in)
  :custom
  (org-refile-use-outline-path 'file)
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-targets '((org-agenda-files :maxlevel . 1)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m r" #'org-refile))
#+end_src

**** =org-inline-pdf=

To see inline pdf images! Amazing right?

#+begin_src emacs-lisp :tangle yes
(use-package org-inline-pdf
  :after org
  :hook
  (org-mode-hook . org-inline-pdf-mode))
#+end_src

**** =org-bars=

Adds bars to visualize the indentation provided by the built-in =org-indent=

#+begin_src emacs-lisp :tangle yes
(use-package org-bars
  :straight
  (org-bars
   :type git
   :host github
   :repo "tonyaldon/org-bars")
  :hook
  (org-mode-hook . org-bars-mode)
  :config
  (setq org-bars-stars '(:empty "*" :invisible "*" :visible "*")
        org-bars-color-options '(:desaturate-level-faces 15
                                 :darken-level-faces 30)
        org-bars-extra-pixels-height 0))
#+end_src

*** Export

Configurations relating all the numerous org exporters.

#+begin_src emacs-lisp :tangle yes
(use-package ox
  :after org
  :straight (:type built-in)
  :straight htmlize
  :preface
  (defconst org-export-default-output-folder "build"
    "Defines the default export folder for `ox' and friends.")
  (defun org-export-output-file-name-modified (orig-fun extension &optional subtreep pub-dir)
    "Collect all generated files from an export in a neat folder."
    (unless pub-dir
      (setq pub-dir org-export-default-output-folder)
      (unless (file-directory-p pub-dir)
        (make-directory pub-dir)))
    (apply orig-fun extension subtreep pub-dir nil))
  :init
  (advice-add #'org-export-output-file-name
              :around #'org-export-output-file-name-modified)
  (advice-add #'org-export-dispatch
              :around #'disable-scroll-margin)
  :custom
  (org-export-backends '(latex html ascii))
  (org-export-exclude-tags '("noexport" "NOEXPORT"))
  (org-export-allow-bind-keywords t)
  (org-export-with-latex t)
  (org-export-babel-evaluate t)
  (org-export-in-background nil)
  (org-export-snippet-translation-alist
   '(("b" . "beamer")
     ("l" . "latex")
     ("h" . "html")
     ("o" . "odt")))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m e" #'org-export-dispatch)
  :config
  (require 'org-ref))
#+end_src

**** =ox-extra=

=ox-extra= defines a couple of cool extras, like =ignore-headlines=!

#+begin_src emacs-lisp :tangle yes
(use-package ox-extra
  :after (ox org-contrib)
  :straight (:type built-in)
  :hook
  ((org-export-filter-parse-tree-functions . org-export-ignore-headlines)
   (org-export-before-parsing-hook . org-latex-header-blocks-filter)))
#+end_src

**** =ox-latex=

Configurations to the LaTeX org exporter.

#+begin_src emacs-lisp :tangle yes
(use-package ox-latex
  :after ox
  :straight (:type built-in)
  :custom
  (org-latex-image-default-width "1\\linewidth")
  (org-latex-packages-alist
   `((,(concat "cache=false,outputdir=" org-export-default-output-folder) "minted")
     ("T1" "fontenc")
     ("" "placeins")))
  (org-latex-listings 'minted)
  (org-latex-minted-options
   '(("breaklines")
     ("breakafter" "d")
     ("linenos" "true")
     ("xleftmargin" "\\parindent")))
  (org-latex-pdf-process
   '("latexmk -pdfxelatex='xelatex -shell-escape -interaction=nonstopmode' -f -xelatex -outdir=%o %f"))
  :config
  (add-to-list 'org-latex-classes
           '("iiufrgs"
         "\\documentclass{iiufrgs}"
         ("\\chapter{%s}"       . "\\chapter*{%s}")
         ("\\section{%s}"       . "\\section*{%s}")
         ("\\subsection{%s}"    . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}"     . "\\paragraph*{%s}")))
  (add-to-list 'org-latex-classes
           '("newlfm"
         "\\documentclass{newlfm}"
         ("\\chapter{%s}"       . "\\chapter*{%s}")
         ("\\section{%s}"       . "\\section*{%s}")
         ("\\subsection{%s}"    . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
  (add-to-list 'org-latex-classes
           '("IEEEtran"
         "\\documentclass{IEEEtran}"
         ("\\section{%s}"       . "\\section*{%s}")
         ("\\subsection{%s}"    . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}"     . "\\paragraph*{%s}")
         ("\\subparagraph{%s}"  . "\\subparagraph*{%s}"))))
#+end_src

**** =ox-hugo=

To the oh-so-pretty Hugo markdown format!

#+begin_src emacs-lisp :tangle yes
(use-package ox-hugo
  :after ox
  :demand t)
#+end_src

**** =ox-twbs=

Twitter bootstrap htmls!

#+begin_src emacs-lisp :tangle yes
(use-package ox-twbs
  :after ox
  :demand t)
#+end_src

**** =ox-dnd=

Yeah. That's right.

I mean, it's basically a tool to interface with the D&D LaTeX class. Not
that nerdy, is it?

#+begin_src emacs-lisp :tangle yes
(use-package ox-dnd
  :after ox
  :straight (:type built-in)
  :load-path (lambda () (expand-file-name "emacs-org-dnd" vendor-user-dir)))
#+end_src

**** =ox-beamer=

To export pretty slide presentations

#+begin_src emacs-lisp :tangle yes
(use-package ox-beamer
  :after ox
  :straight (:type built-in)
  :delight
  (org-beamer-mode nil)
  :general
  (:states '(normal visual)
   :keymaps 'org-beamer-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m b" '(:ignore t :wk "beamer")
   "m b e" #'org-beamer-select-environment
   "m b p" #'org-beamer-export-to-pdf)
  :custom
  (org-beamer-environments-extra
   '(("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}")
     ("minipage" "m" "\\begin{minipage}[%R]{%O}" "\\end{minipage}%"))))
#+end_src

*** Babel

Now, some configurations relating org-babel and its magic source blocks.

#+begin_src emacs-lisp :tangle yes
(use-package ob
  :after org
  :straight (:type built-in)
  :delight
  (org-src-mode)
  :preface
  (defun org-babel-tangle-block ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'org-babel-tangle)))
  (defun org-babel-strip-ansi-codes (func &rest args)
    (let ((result (apply func args)))
      (unless (null result)
        (replace-regexp-in-string ansi-color-control-seq-regexp "" result))))
  (defun org-babel-region-strip-ansi-codes (func beg &rest args)
    "Remove all ansi-color codes from point (the end of the region) to `beg'."
    (while (re-search-forward ansi-color-control-seq-regexp beg t -1)
      (replace-match "" nil nil))
    (apply func beg args))
  :hook
  (org-babel-after-execute-hook . org-remove-inline-images)
  :init
  (advice-add #'org-trim :around #'org-babel-strip-ansi-codes)
  (advice-add #'org-no-properties :around #'org-babel-strip-ansi-codes)
  (advice-add #'org-element-normalize-string  :around #'org-babel-strip-ansi-codes)
  (advice-add #'org-babel-examplify-region :around #'org-babel-region-strip-ansi-codes)
  (advice-add #'org-string-nw-p :around #'org-babel-strip-ansi-codes)
  (advice-add #'org-element-interpret-data :around #'org-babel-strip-ansi-codes)
  ;; make tab-indent-natively work with evil
  (advice-add #'org-babel-do-key-sequence-in-edit-buffer
              :around #'dzop/evil-org-insert-state-in-edit-buffer)
  :custom
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-src-preserve-indentation t)
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'other-window)
  (org-babel-default-header-args
   '((:session . "none")
     (:results . "value replace")
     (:exports . "code")
     (:cache   . "none")
     (:noweb   . "no")
     (:async   . "yes")
     (:eval    . "never-export")
     (:hlines  . "no")
     (:tangle  . "no")))
  (org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (python . t)
     (julia . t)
     (makefile . t)
     (R . t)
     (C . t)
     (ruby . t)
     (ditaa . t)
     (dot . t)
     (octave . t)
     (sqlite . t)
     (perl . t)
     (screen . t)
     (plantuml . t)
     (lilypond . t)
     (latex . t)))
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m x" #'org-babel-execute-buffer
   "m z" #'org-babel-tangle-block
   "m Z" #'org-babel-tangle)
  (:keymaps 'org-mode-map
   "C-c SPC" #'org-edit-special)
  (:keymaps 'org-src-mode-map
   "C-c SPC" #'org-edit-src-exit)
  :config
  ;; set correct modes for some languages
  (setf (alist-get "dot" org-src-lang-modes) 'graphviz-dot
        (alist-get "latex" org-src-lang-modes) 'TeX-latex))
#+end_src

**** =ob-jupyter=

As a great way to run Python and Julia source blocks inside =org-mode=

#+begin_src emacs-lisp :tangle yes
(use-package jupyter
  :after ob
  :straight t
  :straight zmq
  :straight websocket
  :commands jupyter-org-interaction-mode
  :custom
  (org-babel-default-header-args:jupyter-julia
   '((:eval . "no-export")
     (:async . "yes")
     (:session . "*Julia*")
     (:results . "value")
     (:exports . "both")
     (:kernel . "julia-1.4")))
  (org-babel-default-header-args:jupyter-python
   '((:eval . "no-export")
     (:async . "yes")
     (:session . "*Python*")
     (:results . "value")
     (:exports . "both")
     (:kernel . "python3"))))
#+end_src

**** =ob-R=

Basic configuration about =org-babel= for R

#+begin_src emacs-lisp :tangle yes
(use-package ob-R
  :after ob
  :straight (:type built-in)
  :custom
  (org-babel-default-header-args:R
   '((:exports . "both"))))
#+end_src

** C-like languages

Here I set some defaults I appreciate for =cc-mode= (the mode for all c-like
languages):

#+begin_src emacs-lisp :tangle yes
(use-package cc-mode
  :straight (:type built-in)
  :commands (c-mode awk-mode java-mode c++-mode)
  :mode
  (("\\.c\\'" . c-mode)
   ("\\.h\\'" . c-mode)
   ("\\.awk\\'" . awk-mode)
   ("\\.java\\'" . java-mode))
  :hook
  ((c-mode-common-hook . eglot-ensure)
   (c-mode-common-hook . tree-sitter-mode)
   (c-mode-common-hook . rainbow-delimiters-mode))
  :custom
  (c-default-style
   '((java-mode . "java")
     (awk-mode  . "awk")
     (other     . "linux")))
  (c-basic-offset 4)
  (c-offsets-alist '((substatement-open . 0))))
#+end_src

As languages that are part of =cc-mode= are known to using a lot of
doxygen, here's a package that highlights it!

#+begin_src emacs-lisp :tangle yes
(use-package highlight-doxygen
  :hook
  (c-mode-common-hook . highlight-doxygen-mode)
  :custom-face
  (highlight-doxygen-comment ((t :inherit font-lock-doc-face :background "#363230" :extend t)))
  (highlight-doxygen-code-block ((t :background "#363230" :extend t))))
#+end_src

*** C/C++

Better C++ font lock

#+begin_src emacs-lisp :tangle yes
(use-package modern-cpp-font-lock
  :delight
  (modern-c++-font-lock-mode)
  :hook
  (c++-mode-hook . modern-c++-font-lock-mode))
#+end_src

And better pre-processor highlighting

#+begin_src emacs-lisp :tangle yes
(use-package preproc-font-lock
  :commands (preproc-font-lock-mode preproc-font-lock-global-mode)
  :hook
  ((c-mode-hook   . preproc-font-lock-mode)
   (c++-mode-hook . preproc-font-lock-mode))
  :custom-face
  (preproc-font-lock-preprocessor-background ((t :background "#302c2b"))))
#+end_src

In the department of code formatting, =clang-format= is a lovely tool
that can really be of great use while editing C and C++ code.

#+begin_src emacs-lisp :tangle yes
(use-package clang-format
  :preface
  (defun cc-format-on-save-hook ()
    (when c-buffer-is-cc-mode
      (clang-format-buffer)))
  :general
  (:states '(normal visual)
   :keymaps 'c-mode-base-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m f" #'clang-format-region)
  :custom
  (clang-format-fallback-style "webkit")
  :config
  ;; crux-with-region-or-buffer ...
  (defadvice clang-format-region
      (before with-region-or-buffer activate compile)
    (interactive
     (if mark-active
     (list
      (region-beginning)
      (region-end))
       (list
    (point-min)
    (point-max))))))
#+end_src

*** CUDA

Suporting CUDA syntax per-se is kinda easy, as it's a subset of C after all. The
thing is I want proper syntax highlighting for all those special keywords and
types that CUDA introduces. So, let's install =cuda-mode=:

#+begin_src emacs-lisp :tangle yes
(use-package cuda-mode
  :mode "\\.cu\\'"
  :commands cuda
  :hook
  (cuda-mode-hook . (lambda () (run-hooks 'c++-mode-hook)))
  :custom
  (cuda-font-lock-keywords 'cuda-font-lock-keywords-3))
#+end_src

It falls back on =c++-mode= by default, so we are safe here.

** R

For R you pretty much /need/ the =ess= package, i.e. /Emacs Speaks
Statistics/. It provides you with everything you need from R.

#+begin_src emacs-lisp :tangle yes
(use-package ess-r-mode
  :straight ess
  :commands (R R-mode r-mode ess-r-mode ess-r-transcript-mode)
  :preface
  (defun hcps/insert-r-pipe ()
    "Lets us insert the magrittr piping operator in R"
    (interactive)
    (just-one-space 1)
    (insert "%>%")
    (reindent-then-newline-and-indent))
  :hook
  ((ess-r-mode-hook . aggressive-indent-mode)
   (ess-r-mode-hook . eldoc-mode)
   (ess-r-mode-hook . rainbow-delimiters-mode)
   (ess-r-mode-hook . tree-sitter-mode)
   (inferior-ess-mode-hook . comint-fix-window-size))
  :general
  (:states 'insert
   :keymaps 'ess-r-mode-map
   "M-RET" #'hcps/insert-r-pipe
   "<tab>" #'ess-indent-or-complete)
  (:states '(normal visual)
   :keymaps 'ess-r-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m c" #'ess-eval-region-or-function-or-paragraph-and-step
   "m r" #'ess-eval-region)
  (:states 'normal
   :keymaps 'ess-r-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m e" #'Rd-mode-insert-skeleton
   "m f" #'Rd-font
   "m j" #'Rd-mode-insert-item
   "m n" #'ess-eval-line-visibly-and-step
   "m p" #'Rd-preview-help
   "m s" #'Rd-mode-insert-section
   "m v" #'ess-display-help-on-object
   "m w" #'ess-switch-process
   "m y" #'ess-switch-to-ESS
   "m z" #'ess-switch-to-end-of-ESS)
  :custom
  (ido-enable-flex-matching t)
  (ess-gen-proc-buffer-name-function #'ess-gen-proc-buffer-name:simple)
  (ess-auto-width fill-column)
  (ess-style 'RStudio))
#+end_src

** Shell script

As for shell-scripting:

#+begin_src emacs-lisp :tangle yes
(use-package sh-script
  :straight (:type built-in)
  :commands (shell-script-mode sh-mode)
  :mode ("\\.zsh\\'" . shell-script-mode)
  :preface
  (defconst prezto-files
    '(".zlogin" ".zlogin" ".zlogout" ".zpreztorc" ".zprofile" ".zshenv" ".zshrc")
    "Files that are too zsh-style files.")
  (defun zsh-prezto-files ()
    "Function to ease switching to zsh when dealing with a zsh file."
    (if (and buffer-file-name
             (member (file-name-nondirectory buffer-file-name) prezto-files))
        (sh-set-shell "zsh")))
  :hook
  ((sh-mode-hook . zsh-prezto-files)
   (sh-mode-hook . tree-sitter-mode)
   (sh-mode-hook . flycheck-mode)
   (sh-mode-hook . rainbow-delimiters-mode)
   (sh-mode-hook . sh-electric-here-document-mode))
  :general
  (:states '(normal visual)
   :keymaps 'sh-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m s" #'sh-set-shell
   "m i c" #'sh-case
   "m i f" #'sh-for
   "m i i" #'sh-if
   "m i s" #'sh-select
   "m i w" #'sh-while
   "m i o" #'sh-while-getopts
   "m i u" #'sh-until
   "m i F" #'sh-function
   "m i I" #'sh-indexed-loop))
#+end_src

For =shell= completion I use =bash-complete=, which auto completes several
=bash= functions.

#+begin_src emacs-lisp :tangle yes
(use-package bash-completion
  :hook
  (shell-dynamic-complete-functions . bash-completion-dynamic-complete)
  :custom
  (bash-completion-use-separate-processes t))
#+end_src

** Makefile

In Makefile files we have a special case: it /needs/ tabulators to work.
So, we'll set that up.

#+begin_src emacs-lisp :tangle yes
(use-package make-mode
  :straight (:type built-in)
  :commands makefile-mode
  :mode ("^[Mm]akefile\\'" . makefile-mode)
  :hook
  (makefile-mode-hook . rainbow-delimiters-mode)
  :config
  (setq-mode-local makefile-mode indent-tabs-mode t))
#+end_src

** PlantUML

/PlantUML/ is a graph language that describes loads of different diagram
types, mainly focusing on /UML/, of course.

#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
  :mode "\\.plantuml\\'"
  :interpreter "plantuml")
#+end_src

** Lisp

Fix for the annoying keyword default indentation:

#+begin_src emacs-lisp :tangle yes
(defun fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine if
the arguments of a Lisp function call should be indented
specially. INDENT-POINT is the position at which the line being
indented begins. Point is located at the point to indent
under (for default indentation); STATE is the
`parse-partial-sexp' state for that position. If the current line
is in a call to a Lisp function that has a non-nil property
`lisp-indent-function' (or the deprecated `lisp-indent-hook'), it
specifies how to indent. The property value can be:
,* `defun', meaning indent `defun'-style
  (this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
    (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
       (or (not (looking-at "\\sw\\|\\s_"))
           (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
          calculate-lisp-indent-last-sexp))
      (progn (goto-char calculate-lisp-indent-last-sexp)
         (beginning-of-line)
         (parse-partial-sexp (point)
                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
         (goto-char indent-point)
         (skip-syntax-forward " ")
         (not (looking-at ":")))
       (save-excursion
         (goto-char orig-point)
         (looking-at ":")))
      (save-excursion
    (goto-char (+ 2 (elt state 1)))
    (current-column)))
     (t
      (let ((function (buffer-substring (point)
                    (progn (forward-sexp 1) (point))))
        method)
    (setq method (or (function-get (intern-soft function)
                       'lisp-indent-function)
             (get (intern-soft function) 'lisp-indent-hook)))
    (cond ((or (eq method 'defun)
           (and (null method)
            (> (length function) 3)
            (string-match "\\`def" function)))
           (lisp-indent-defform state indent-point))
          ((integerp method)
           (lisp-indent-specform method state
                     indent-point normal-indent))
          (method
           (funcall method indent-point state))))))))
#+end_src

also extra magic font lock for Lisp and Scheme

#+begin_src emacs-lisp :tangle yes
(use-package lisp-extra-font-lock
  :commands (lisp-extra-font-lock-mode lisp-extra-font-lock-global-mode))
#+end_src

Finally, the mode's final configuration

#+begin_src emacs-lisp :tangle yes
(use-package lisp-mode
  :straight (:type built-in)
  :mode
  (("\\.lsp\\'"  . lisp-mode)
   ("\\.lisp\\'" . lisp-mode)
   ("\\.cl\\'"   . lisp-mode))
  :hook
  ((lisp-mode-hook . aggressive-indent-mode)
   (lisp-mode-hook . lisp-extra-font-lock-mode)
   (lisp-mode-hook . rainbow-delimiters-mode))
  :general
  (:states '(normal visual)
   :keymaps 'lisp-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m l" #'lispyville-mode)
  :custom
  (lisp-indent-function #'fuco1/lisp-indent-function))
#+end_src

** Elisp

Emacs version!

#+begin_src emacs-lisp :tangle yes
(use-package elisp-mode
  :straight (:type built-in)
  :straight elisp-slime-nav
  :commands emacs-lisp-mode
  :mode ("\\.el\\'" . emacs-lisp-mode)
  :preface
  (defun recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (when (and (string-prefix-p user-emacs-directory (file-truename buffer-file-name))
               (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (emacs-lisp-byte-compile)))
  :hook
  ((after-save-hook      . recompile-elc-on-save)
   (emacs-lisp-mode-hook . (lambda () (run-hooks 'lisp-mode-hook))))
  :general
  (:states '(normal visual)
   :keymaps 'emacs-lisp-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m l" #'lispyville-mode)
  :config
  (require 'use-package))
#+end_src

** Python

A simple yet effective Python configuration.

#+begin_src emacs-lisp :tangle yes
(use-package python
  :straight (:type built-in)
  :commands python-mode
  :hook
  ((python-mode-hook . tree-sitter-mode)
   (python-mode-hook . eglot-ensure)
   (python-mode-hook . rainbow-delimiters-mode)))
#+end_src

** CMake

As CMake is very simple, each word carries a load of meaning and
importance. This little mode colors them accordingly.

#+begin_src emacs-lisp :tangle yes
(use-package cmake-mode
  :mode
  (("^CMakeLists\\.txt\\'" . cmake-mode)
   ("\\.cmake\\'"          . cmake-mode))
  :hook
  (cmake-mode-hook . rainbow-delimiters-mode))
#+end_src

Also add extra colors

#+begin_src emacs-lisp :tangle yes
(use-package cmake-font-lock
  :after cmake-mode
  :demand t
  :hook
  (cmake-mode-hook . cmake-font-lock-activate))
#+end_src

** Dockerfile

=dockerfile-mode= adds support to syntax highlighting and to build the
image directly from the buffer using =C-c C-b=.

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :mode "[Dd]ockerfile\\'")
#+end_src

** GMPL

So I have syntax highlighting while editing GLPK files.

#+begin_src emacs-lisp :tangle yes
(use-package gmpl-mode
  :mode "\\.mod\\'")
#+end_src

** Julia

Packages to write Julia source code in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package julia-mode
  :mode "\\.jl\\'"
  :preface
  (defun hcps/insert-julia-pipe ()
    "Lets us insert the piping operator |> in Julia"
    (interactive)
    (just-one-space 1)
    (insert "|>")
    (reindent-then-newline-and-indent))
  :init
  (setq inferior-julia-program (hcps/s-trim-right (shell-command-to-string "which julia")))
  (defvaralias 'inferior-julia-program-name 'inferior-julia-program
    "Because jupyter still uses this symbol.")
  (advice-add #'julia :around (lambda (func &rest args) (set-buffer (apply func args))))
  :hook
  ((julia-mode-hook . tree-sitter-mode)
   (julia-mode-hook . rainbow-delimiters-mode)
   (julia-mode-hook . aggressive-indent-mode))
  :general
  (:states 'insert
   :keymaps 'julia-mode-map
   "M-RET" #'hcps/insert-julia-pipe))
#+end_src

** LaTeX

- [ ] [[https://github.com/jwiegley/use-package/issues/379#issuecomment-258217014][Interesting link]]

Let's start with some basic =AUCTeX= configuration

#+begin_src emacs-lisp :tangle yes
(use-package tex
  :straight
  (auctex
   :type git
   :host nil
   :files (:defaults (:exclude "*.el.in"))
   :repo "https://git.savannah.gnu.org/git/auctex.git"
   :branch "master"
   :pre-build
   (("./autogen.sh")
    ("./configure" "--without-texmf-dir" "--with-lispdir=.")
    ("make"))
   :build
   (:not info))
  :mode ("\\.tex\\'" . TeX-latex-mode)
  :commands (TeX LaTeX LaTeX-mode TeX-mode TeX-latex-mode)
  :hook
  ((LaTeX-mode-hook . auto-fill-mode)
   (LaTeX-mode-hook . rainbow-delimiters-mode))
  :init
  (setq reftex-plug-into-AUCTeX t)
  :general
  (:states '(normal visual)
   :keymaps 'LaTeX-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m e" #'LaTeX-environment
   "m s" #'LaTeX-section
   "m m" #'TeX-insert-macro)
  :custom
  ;; (TeX-auto-save t)
  ;; (TeX-master nil)
  (TeX-engine 'xetex)
  (TeX-parse-self t)
  (TeX-save-query nil)
  (TeX-source-correlate-method 'synctex)
  (TeX-output-dir "build")
  (TeX-view-program-selection
   '(((output-dvi has-no-display-manager) "dvi2tty")
     ((output-dvi style-pstricks) "dvips and gv")
     (output-dvi "xdvi")
     (output-pdf "xdg-open")
     (output-html "xdg-open"))))
#+end_src

And =RefTeX= to follow it

#+begin_src emacs-lisp :tangle yes
(use-package reftex
  :straight (:type built-in)
  :delight (reftex-mode " ref")
  :commands (reftex-mode turn-on-reftex)
  :hook
  (LaTeX-mode-hook . turn-on-reftex)
  :general
  (:states '(normal visual)
   :keymaps 'LaTeX-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m b" #'reftex-label
   "m r" #'reftex-reference
   "m c" #'reftex-citation
   "m t" #'reftex-toc
   "m i" #'reftex-index)
  :custom
  (reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")))
#+end_src

So, for my LaTeX config I'll mainly use =latexmk= as it's way simpler to
use.

#+begin_src emacs-lisp :tangle yes
(use-package auctex-latexmk
  :after tex
  :demand t
  :config
  (auctex-latexmk-setup))
#+end_src

With =latexmk= I do also use its configuration file in =~/.latexmkrc=, so
some important stuff may be defined there.

** Meson

Syntax support for the Meson build system DSL (which is based from
Python).

#+begin_src emacs-lisp :tangle yes
(use-package meson-mode
  :commands meson
  :mode "^meson\\.build\\'"
  :hook
  (meson-mode-hook . rainbow-delimiters-mode))
#+end_src

** {bspwm,sxhkd}rc

Derives from =conf-mode[space]=. Got it from [[https://notabug.org/arkhan/emacs-bspwm][here]].

#+begin_src emacs-lisp :tangle yes
(use-package bspwm
  :straight (:type built-in)
  :commands (bspwm-config-mode)
  :load-path (lambda () (expand-file-name "bspwm-mode" vendor-user-dir))
  :mode
  ("sxhkdrc\\'\\|bspwmrc\\'" . bspwm-config-mode)
  ;; :hook
  ;; (bspwm-config-mode-hook . page-break-lines-mode)
)
#+end_src

** Configuration files

Just a little hook to start the desired =conf-mode= when we open these
files.

#+begin_src emacs-lisp :tangle yes
(use-package conf-mode
  :straight (:type built-in)
  :mode "\\.service\\'"
  :hook
  (conf-mode-hook . (lambda () (run-hooks 'prog-mode-hook))))
#+end_src

** Rust

The newest greatest compiled language!

#+begin_src emacs-lisp :tangle yes
(use-package rust-mode
  :straight t
  :straight cargo
  ;; :straight flycheck-rust
  :hook
  ((rust-mode-hook . lsp)
   (rust-mode-hook . cargo-minor-mode)
   (rust-mode-hook . rainbow-delimiters-mode))
  :custom
  (rust-format-on-save t)
  (rust-indent-method-chain t))
#+end_src

** Perl

Old language, still great for doing admin stuff in few lines.

#+begin_src emacs-lisp :tangle yes
(use-package cperl-mode
  :straight (:type built-in)
  :mode "\\.p[lm]\\'"
  :interpreter "perl"
  :commands cperl-mode
  :preface
  (defalias #'perl-mode #'cperl-mode "CPerl has better handling and utilities.")
  :hook
  (cperl-mode-hook . rainbow-delimiters-mode)
  :general
  (:states '(normal visual)
   :keymaps 'cperl-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "i" #'cperl-indent-region)
  :custom
  (cperl-font-lock t)
  (cperl-info-on-command-no-prompt t)
  (cperl-clobber-lisp-bindings nil)
  (cperl-indent-level 4)
  :custom-face
  (cperl-nonoverridable-face ((t (:inherit font-lock-builtin-face :foreground unspecified))))
  (cperl-array-face ((t nil)))
  (cperl-hash-face ((t nil)))
  :config
  (font-lock-add-keywords
   'cperl-mode
   '(("^#!\\/\\(?:\\w+\\/\\)*\\(\\w+\\)"
      (1 'font-lock-keyword-face prepend))
     ("\\(\\\\\\)\\(&\\)\\([[:alnum:]_:]+\\)"
      (1 'font-lock-builtin-face)
      (2 'font-lock-type-face)
      (3 'font-lock-function-name-face))
     ("\\(\\$\\)\\([[:digit:]_`]\\)[^[:alnum:]_:]"
      (1 'font-lock-type-face prepend)
      (2 'font-lock-builtin-face prepend))
     ("\\(?:^\\|[^[:alnum:]_:\\\\]\\)\\([$@%]+\\)\\([[:alnum:]_:]+\\)"
      (1 'font-lock-type-face append)
      (2 'font-lock-variable-name-face append))))
  (font-lock-remove-keywords
   'cperl-mode
   '(("\\(\\([$@%]+\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)[ \t]*\\([[{]\\)" 1
      (if (= (- (match-end 2) (match-beginning 2)) 1)
          (if (eq (char-after (match-beginning 3)) ?{)
              'cperl-hash-face
            'cperl-array-face)
        font-lock-variable-name-face)
      t)
     ("\\(\\([@%]\\|\\$#\\)[a-zA-Z_:][a-zA-Z0-9_:]*\\)" 1
      (if (eq (char-after (match-beginning 2)) ?%)
          'cperl-hash-face
        'cperl-array-face)
      nil)
     ("\\(@\\|\\$#\\)\\(\\$+\\([a-zA-Z_:][a-zA-Z0-9_:]*\\|[^ \t\n]\\)\\)"
      (1 'cperl-array-face)
      (2 font-lock-variable-name-face))
     ("\\(%\\)\\(\\$+\\([a-zA-Z_:][a-zA-Z0-9_:]*\\|[^ \t\n]\\)\\)"
      (1 'cperl-hash-face)
      (2 font-lock-variable-name-face))
     ("\\([$*]{?\\(?:\\sw+\\|::\\)+\\)" 1
      font-lock-variable-name-face))))
#+end_src

** Dot (Graphviz)

Diagrams are cool

#+begin_src emacs-lisp :tangle yes
(use-package graphviz-dot-mode
  :mode "\\.gv\\'\\|\\.dot\\'"
  :commands (graphviz-dot-mode)
  :hook
  ((graphviz-dot-mode-hook . rainbow-delimiters-mode)
   (graphviz-dot-mode-hook . aggressive-indent-mode))
  :general
  (:states '(normal visual)
   :keymaps 'graphviz-dot-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m f" #'graphviz-dot-indent-graph
   "m p" #'graphviz-dot-preview)
  :custom
  (graphviz-dot-indent-width 4))
#+end_src

** Bison/Flex/Yacc

For lexer shenanigans

#+begin_src emacs-lisp :tangle yes
(use-package bison
  :straight (:type built-in)
  :commands bison-mode
  :load-path (lambda () (expand-file-name "bison-mode" vendor-user-dir))
  :mode
  (("\\.y\\'" . bison-mode)
   ;; ("\\.l\\'" . flex-mode)
   ;; ("\\.jison\\'" . jison-mode)
   )
  :hook
  (bison-mode-hook . rainbow-delimiters-mode)
  ;; :custom
  ;; (bison-all-electricity-off t)
  ;; (bison-rule-separator-column 0)
  ;; (bison-rule-enumeration-column 0)
  ;; (bison-decl-type-column 0)
  ;; (bison-decl-token-column 0)
  )
#+end_src

** Markdown

Ugh another mode that insists in putting bigger fonts everywhere...

#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode "\\.md\\'"
  :commands (markdown-mode gfm-mode)
  :preface
  (defconst markdown-electric-pairs '((?_ . ?_) (?* . ?*) (?` . ?`)))
  :hook
  ((markdown-mode-hook . auto-fill-mode)
   (markdown-mode-hook . hes-mode)
   (markdown-mode-hook . eldoc-mode)
   (markdown-mode-hook . (lambda () (whitespace-toggle-options 'lines-tail))))
  :custom
  (markdown-hr-display-char ?-)
  (markdown-hide-markup nil)
  :custom-face
  (markdown-line-break-face ((t (:inherit unspecified :underline unspecified))))
  (markdown-header-face ((t (:height 1.0))))
  :config
  (setq-mode-local markdown-mode electric-pair-pairs (append electric-pair-pairs
                                                             markdown-electric-pairs))
  (dolist (num (number-sequence 1 6))
    (custom-set-faces `(,(intern (format "markdown-header-face-%d" num)) ((t (:height 1.0))))))
  (font-lock-remove-keywords
   'markdown-mode
   `((,markdown-regex-line-break
      1 'markdown-line-break-face prepend))))
#+end_src

** PKGBUILD

The shell scripts responsible for AUR package's configuration. This
package offers additional features and commands on top of just being a
=shell-script-mode= wrap.

#+begin_src emacs-lisp :tangle yes
(use-package pkgbuild-mode
  :mode "PKGBUILD\\'"
  :commands (pkgbuild-mode))
#+end_src

No hooks are needed as this mode derives from =shell-script-mode=.

** JavaScript

So I can write a decent Tree Sitter grammar.

#+begin_src emacs-lisp :tangle yes
(use-package js
  :straight (:type built-in)
  :commands (js-mode)
  :hook
  ((js-mode-hook . tree-sitter-mode)
   (js-mode-hook . rainbow-delimiters-mode)
   (js-mode-hook . aggressive-indent-mode)))
#+end_src

** Typescript

Here we'll not be using =js-mode=! Instead, we'll be using
=typescript-mode= with Tree Sitter atop it!

#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :mode
  (("\\.ts\\'"  . typescript-mode)
   ("\\.tsx\\'" . typescript-mode))
  :hook
  (typescript-mode-hook . (lambda () (run-hooks 'js-mode-hook))))
#+end_src

** Clojure

Fucking finally

#+begin_src emacs-lisp :tangle yes
(use-package clojure-mode
  :mode
  (("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode)
   ("\\.cljc\\'" . clojurec-mode)
   ("\\.cljs\\'" . clojurescript-mode))
  :hook
  ((clojure-mode-hook . (lambda () (run-hooks 'lisp-mode-hook)))
   (clojure-mode-hook . eglot-ensure))
  :config
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (OPTIONS 2)
    (PATCH 2)
    (rfn 2)
    (let-routes 1)
    (context 2)))
#+end_src

also configure CIDER

#+begin_src emacs-lisp :tangle yes
(use-package cider
  :after clojure-mode
  :general
  (:states '(normal visual)
   :keymaps 'clojure-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m i" #'cider-jack-in))
#+end_src

and =clj-refactor=

#+begin_src emacs-lisp :tangle yes
(use-package clj-refactor
  :after clojure-mode
  :hook
  ((clj-refactor-mode-hook . yas-minor-mode)
   (clojure-mode-hook . clj-refactor-mode)))
#+end_src

** Racket

Yes! I've came full circle and now I love Lisp/Scheme, what the heck.

#+begin_src emacs-lisp :tangle yes
(use-package racket-mode
  :mode "\\.rkt\\'"
  :hook
  ((racket-mode-hook . (lambda () (run-hooks 'lisp-mode-hook)))
   (racket-mode-hook . racket-xp-mode)
   (racket-repl-mode-hook . (lambda () (run-hooks 'lisp-mode-hook)))
   (racket-repl-mode-hook . evil-emacs-state))
  :general
  (:states '(normal visual)
   :keymaps 'racket-mode-map
   :prefix hcps/leader-key
   :non-normal-prefix hcps/alt-leader-key
   "m x" #'racket-run-and-switch-to-repl
   "m l" #'racket-insert-lambda)
  :custom
  (racket-memory-limit 4096)
  (racket-show-functions '(racket-show-echo-area))
  :custom-face
  (racket-selfeval-face ((t (:inherit font-lock-constant-face :foreground unspecified)))))
#+end_src

** YAML

Yet Another Markup Language

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :mode "\\.yaml\\'")
#+end_src

** GGO

=gengetopt= files!

#+begin_src emacs-lisp :tangle yes
(use-package ggo-mode
  :straight
  (ggo-mode
   :type git
   :host github
   :repo "mkjunker/ggo-mode")
  :mode "\\.ggo\\'"
  :hook
  (ggo-mode-hook . (lambda () (run-hooks 'prog-mode-hook))))
#+end_src

** Git-related files

Like configuration files, only, I don't know, different?

#+begin_src emacs-lisp :tangle yes
(use-package git-modes
  :mode
  (("/\\.gitconfig\\'"      . gitconfig-mode)
   ("/\\.git/config\\'"     . gitconfig-mode)
   ("/modules/.*/config\\'" . gitconfig-mode)
   ("/git/config\\'"        . gitconfig-mode)
   ("/\\.gitmodules\\'"     . gitconfig-mode)
   ("/etc/gitconfig\\'"     . gitconfig-mode)
   ("/\\.gitignore\\'"      . gitignore-mode)
   ("/info/exclude\\'"      . gitignore-mode)
   ("/git/ignore\\'"        . gitignore-mode)
   ("/\\.gitattributes\\'"  . gitattributes-mode)
   ("/info/attributes\\'"   . gitattributes-mode)
   ("/git/attributes\\'"    . gitattributes-mode)))
#+end_src

* Local variables

# Local Variables:
# mode: org
# eval: (add-hook 'after-save-hook #'hcps/async-byte-compile-org-config nil t)
# End:
