# -*- mode: org -*-
#+TITLE: My Emacs configuration file
#+AUTHOR: Henrique Silva
#+email: hcpsilva@inf.ufrgs.br
#+INFOJS_OPT:

These configurations represent my preferred version of Emacs, one that uses
=evil= everywhere it can and one that tries to be as minimalist as +I want+
possible.

Cool Emacs configs from cool people:

- [[https://github.com/caisah/emacs.dz][Lots of cool people]]
- [[https://github.com/hrs/dotfiles][hrs]] (he likes org-mode and evil)
- [[https://app-learninglab.inria.fr/gitlab/learning-lab/mooc-rr-ressources/blob/master/module2/ressources/rr_org/init.org][Konrad's and Arnaud's]]

* Table of contents                                                   :TOC_3:
- [[#introduction][Introduction]]
  - [[#use-package][=use-package=]]
    - [[#ensure][:ensure]]
    - [[#after][:after]]
    - [[#defer][:defer]]
    - [[#demand][:demand]]
    - [[#init][:init]]
    - [[#config][:config]]
- [[#what-packages-you-can-find-here][What packages you can find here]]
- [[#the-editor][The editor]]
  - [[#definitions-and-preferences][Definitions and preferences]]
    - [[#gui-elements][GUI elements]]
    - [[#font][Font]]
    - [[#text][Text]]
    - [[#mode-line][Mode-line]]
    - [[#line-numbering-and-scrolling][Line numbering and scrolling]]
    - [[#randoms][Randoms]]
  - [[#extensions][Extensions]]
    - [[#package-loading][Package loading]]
    - [[#file-management][File management]]
    - [[#environment-variables][Environment variables]]
    - [[#find-and-replace][Find and replace]]
    - [[#mode-line-1][Mode line]]
    - [[#remote-editing][Remote editing]]
    - [[#completion][Completion]]
    - [[#keybindings][Keybindings]]
    - [[#buffers-and-windows][Buffers and windows]]
    - [[#templates-and-snippets][Templates and snippets]]
    - [[#folding][Folding]]
    - [[#syntax-checking][Syntax Checking]]
    - [[#project-management][Project management]]
    - [[#regions-and-pointers][Regions and pointers]]
    - [[#indentation][Indentation]]
    - [[#utilities][Utilities]]
  - [[#theme][Theme]]
- [[#languages][Languages]]
  - [[#org][Org]]
  - [[#cc][C/C++]]
  - [[#r][R]]
  - [[#shell][Shell]]
  - [[#makefile][Makefile]]
  - [[#plantuml][PlantUML]]
  - [[#lisp][Lisp]]
- [[#personal][Personal]]
  - [[#functions][Functions]]
    - [[#date][Date]]
  - [[#keybindings-1][Keybindings]]

* Introduction

First of all, welcome to my configuration file for Emacs. I built it from almost
the ground up, picking up configs from several sources, some of which I've cited
in the beginning of this file.

As I'd like very much that this file be used as a source of inspiration for
others, I wrote it in an =.org= file, using all of =org-mode='s black magic
powers of tangling source blocks to intertwine both source =.el= and prose.

Also, I've used in almost all sections of this document a package called
=use-package= in order to organize all the additional packages that I use to get
a better Emacs experience. So, I'll teach you to read a =use-package= statement!
That way you can understand what's happening beneath all sugar syntax.

** =use-package=

Briefly, this package wraps your configuration for a given package in a neat
little statement, which can include several useful categorizations and
sub-tools.

Here are all little keywords you can use to organize your configs:

*** :ensure

The =:ensure= keyword tells to =use-package= that this package should be
installed in the system. Without it, =use-package= will tell you that the given
package isn't installed and won't proceed.

I define a flag to tell =use-package= to activate this keyword by default,
because I want all packages that I use installed in the system! Still, I can
turn off this behaviour if I set the keyword to =false=.

#+BEGIN_SRC emacs-lisp
(use-package foo
  :ensure t)      ; I need this package installed!

(use-package foo
  :ensure f)      ; I don't NEED the package installed
#+END_SRC

You can also use this keyword to tell that your package need another installed
before it loads!

#+BEGIN_SRC emacs-lisp
  (use-package foo
    :ensure bar)
#+END_SRC

*** :after

The =:after= keyword sets a relation of dependency between the loading of two
packages. In other words, you can tell =use-package= that a given package should
only be loaded if that other package is already loaded.

#+BEGIN_SRC emacs-lisp
(use-package foo)

(use-package bar
  :after foo)

(use-package moo
  :after (foo bar))    ; Supports mmultiple dependencies!
#+END_SRC

*** :defer

The =:defer= keyword tells =use-package= that it can defer the loading of your
package until its absolutely needed. Its behaviour is the opposite of the
keyword =:demand=.

#+BEGIN_SRC emacs-lisp
(use-package foo
  :defer t)
#+END_SRC

*** :demand

The =:demand= keyword says to =use-package= that this package must not be
lazy-loaded, and should be loaded right away as Emacs loads.

#+BEGIN_SRC emacs-lisp
(use-package foo
  :demand)
#+END_SRC

*** :init

The =:init= keyword can tell =use-package= to execute said commands *BEFORE* the
package is loaded. In reality, said execution will happen as soon as the
=use-package= statement is processed on the Emacs loading process.

#+BEGIN_SRC emacs-lisp
(use-package foo
  :init
  (setq bar t))
#+END_SRC

*** :config

The =:config= keyword, much like the =:init= keyword, tells =use-package= to
execute commands. The difference is that commands defined with this keyword will
only execute *AFTER* the package is loaded. There is an important difference here,
as =use-package= uses what's called /lazy loading/, i.e. only load the package
when you actually need it.

#+BEGIN_SRC emacs-lisp
(use-package foo
  :config
  (foo-init))
#+END_SRC

* What packages you can find here

You can find the following packages in this configuration file:

#+BEGIN_SRC emacs-lisp :exports results
(shell-command
 "grep '\<use-package .*$' < config.org |
  awk '{print \"- \"$2}' |
  tr -d ')' |
  sed '1,10d' |
  sort > package-list.txt")
(shell-command-to-string "cat package-list.txt")
#+END_SRC

#+RESULTS:
#+begin_example
- aggressive-indent
- anzu
- auto-compile
- bash-completion
- bind-key
- clang-format
- cmake-ide
- company
- counsel
- counsel-projectile
- counsel-tramp
- cpputils-cmake
- dumb-jump
- engine-mode
- ess
- evil
- evil-collection
- evil-leader
- evil-matchit
- evil-mc
- evil-nerd-commenter
- evil-org
- evil-org-agenda
- evil-surround
- evil-visualstar
- exec-path-from-shell
- expand-region
- flycheck
- flycheck-pos-tip
- gruvbox-theme
- helpful
- hydra
- irony
- ivy
- midnight
- minions
- neotree
- no-littering
- org
- pdf-tools
- perspective
- projectile
- ranger
- rtags
- smart-mode-line
- toc-org
- tramp
- use-package-ensure-system-package
- vimish-fold
- windmove
- yasnippet
#+end_example

But anyway, enough chit-chat, lets start with the configurations!

* The editor

Everything related to Emacs as the editor and platform.

** Definitions and preferences

Defaults that are better if defined /other/ way.

*** GUI elements

Almost every GUI element of Emacs is useless and a waste of screen space.

#+BEGIN_SRC emacs-lisp :tangle yes
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(defun hcps/disable-scroll-bars (frame)
  (modify-frame-parameters frame
                           '((vertical-scroll-bars . nil)
                             (horizontal-scroll-bars . nil))))
(add-hook 'after-make-frame-functions 'hcps/disable-scroll-bars)

(setq-default inhibit-startup-screen t
              initial-scratch-message ""
              initial-major-mode 'org-mode)
#+END_SRC

*** Font

I use the =Source Code Pro= font in every editor I can set that on. Here's their
[[https://github.com/adobe-fonts/source-code-pro][GitHub]].

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Source Code Pro-12")))
#+END_SRC

*** Text

Here's every other setting relating to text editing I can't categorize any
further.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fill-column 80
              indent-tabs-mode nil
              tab-width 4
              line-spacing 0
              require-final-newline t
              x-stretch-cursor t
              cursor-in-non-selected-windows t)

(blink-cursor-mode 0)
#+END_SRC

Also, =auto-fill-mode= is very useful to justify paragraphs automatically while
writing.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'tex-mode-hook 'turn-on-auto-fill)
#+END_SRC

*** Mode-line

Here's everything related to the mode-line.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-time-format "%H:%M "
              display-time-default-load-average nil)

(display-time-mode 1)
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

*** Line numbering and scrolling

I like the vim style of relative numbering of lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-line-numbers-type 'relative
              display-line-numbers-width-start 4)

(global-display-line-numbers-mode)
#+END_SRC

And I also like the vim style of scrolling better.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default auto-window-vscroll nil
              scroll-step 1
              scroll-conservatively most-positive-fixnum
              scroll-margin 10)
#+END_SRC

Highlighting the current line is also very useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-hl-line-mode 1)
#+END_SRC

*** Randoms

Random configs and definitions that don't have a clear category.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default ad-redefinition-action 'accept       ; Silence warnings for redefinition
              confirm-kill-emacs 'yes-or-no-p      ; Confirm before exiting Emacs
              select-enable-clipboard t            ; Merge system's and Emacs' clipboard
              uniquify-buffer-name-style 'forward  ; Uniquify buffer names
              window-combination-resize t          ; Resize windows proportionally
              ring-bell-function 'ignore)          ; No bell ring

; Replace yes/no prompts with y/n
(fset 'yes-or-no-p 'y-or-n-p)

; Set Emacs to call the garbage collector on focus-out
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Extensions

These are Emacs-behaviour related! In other words, these extend the capabilities
of Emacs as an editor, and do NOT add support to other languages or etc.

I still need to add:

- [X] ranger
- [X] neotree
- [X] smart-mode-line
- [X] helpful
- [X] gruvbox
- [X] minions
- [X] dumb-jump
- [X] smex
- [X] ivy and counsel
- [X] counsel-tramp
- [X] tramp
- [X] autofill
- [X] engine-mode
- [X] no-littering
- [X] perspective
- [X] evil-mc
- [X] evil-collection
- [X] evil-nerd-commenter
- [X] evil-matchit
- [X] evil-leader
- [X] pdf-tools
- [X] flycheck-pos-tip
- [X] exec-path-from-shell
- [X] anzu

Also, =prelude= packages that I like and still need to add:

- [ ] smartparens
- [ ] which-key
- [ ] projectile
- [ ] magit and additionals
- [ ] flyspell (with aspell)
- [ ] undo-tree
- [ ] compile
- [ ] whitespace
- [ ] beacon
- [ ] switch-window
- [ ] rainbow-delimiters
- [ ] browse-kill-ring
- [ ] uniquify
- [ ] recentf
- [ ] supersave
- [ ] eval-expr

*** Package loading

I use =use-package= to load my packages and to organize them neatly in this org
file. I plan to gradually rip everything I want from =prelude= and put it here
eventually, using =use-package=.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (not (package-installed-p 'use-package))
  (package-install 'use-package))

(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

In order to demand that certain system packages are installed, I use the helper
package called =use-package-ensure-system-package=. Installing it I can use the
=:ensure-system-package= keywords and demand that certain packages are installed
in the system before proceeding (useful to LaTeX, for example)!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package use-package-ensure-system-package)
#+END_SRC

As we'll use the =:bind= and variants in our =use-package= statements, we'll
have to demand the =bind-key= package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package bind-key)
#+END_SRC

Having that said, I too use =auto-compile= to always compile packages and to
have their newest version.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-compile
  :disabled
  :demand
  :init
  (setq load-prefer-newer t)
  :config
  (auto-compile-on-load-mode))
#+END_SRC

To add facilitate my keybinding issues, I also use =general.el=. It adds some
very welcome keywords to =use-package=, in which I'll use extensively throughout
this file.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package general
  :demand)
#+END_SRC

*** File management

I use =ranger.el= to use a file explorer like =ranger= inside Emacs instead of
the default =dired=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ranger
  :custom
  (ranger-cleanup-on-disable t)
  (ranger-preview-file t)
  (ranger-dont-show-binary t)
  (ranger-max-preview-size 10)
  :config
  (ranger-override-dired-mode t))
#+END_SRC

Also, I like to use =neotree.el= to navigate my project files, which is a clone
from =neotree= from vim.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package neotree
  :general
  ("<f8>" 'neotree-toggle))
#+END_SRC

*** Environment variables

To ensure that Emacs uses the same path and environment as =shell= uses, I use
=exec-path-from-shell=. That way commands that work on the =shell= will
certainly work on Emacs!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if
  (memq window-system '(mac ns))
  :custom
  (exec-path-from-shell-arguments '("-l"))
  :config
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-env "SSH_AGENT_PID")
  (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+END_SRC

*** Find and replace

Besides the =ISearch= from Emacs itself or the search function from =evil=, I
also like to use =anzu=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package anzu
  :custom
  (anzu-cons-mode-line nil)
  :config
  (global-anzu-mode 1))
#+END_SRC

I use only the =anzu-replace-at-cursor-thing=, which is a very useful to replace
multiple occurrences of a word fast.

*** Mode line

I use =smart-mode-line= as it is very minimalist and informative (and it looks
very pretty on =gruvbox=)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smart-mode-line
  :demand
  :config
  (sml/setup))
#+END_SRC

Also, =minions= is useful to not show those pesky minor-modes all the time. No
one wanna see what minor modes are active ALL of the time, right?

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minions
  :after smart-mode-line
  :custom
  (minions-mode-line-lighter "...")
  (minions-mode-line-delimiters '("" . ""))
  :config
  (add-to-list 'minions-whitelist '(projectile-mode . t))
  (minions-mode 1))
#+END_SRC

*** Remote editing

=tramp=, which is included by default in Emacs, is very useful when it comes to
editing remote files and to editing as super-user.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tramp
  :demand
  :custom
  (tramp-default-method "ssh"))
#+END_SRC

*** Completion

This section comprises of both text completion and fuzzy command and path
completion.

**** Path and command

=ivy= is like =ido= but better, I guess. It does fuzzy matching of searches to
open files and such. =flx= is required here in order to have fuzzy matching and
whatnot.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :ensure flx
  :demand
  :preface
  (defun hcps/ivy-open-current-typed-path ()
    (interactive)
    (when ivy--directory
      (let* ((dir ivy--directory)
             (text-typed ivy-text)
             (path (concat dir text-typed)))
        (delete-minibuffer-contents)
        (ivy--done path))))
  :custom
  (ivy-count-format "(%d/%d) ")
  (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
  :general
  ("C-x b" 'ivy-switch-buffer)
  (:keymaps 'ivy-minibuffer-map
   "RET" 'ivy-alt-done
   "C-f" 'hcps/ivy-open-current-typed-path)
  :config
  (ivy-mode 1))
#+END_SRC

=counsel= uses =ivy= to find files and commands. =smex= is required here to
make sure that =counsel-M-x= has decent candidate sorting.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel
  :ensure smex
  :after ivy
  :demand
  :general
  ("M-x" 'counsel-M-x)
  ("C-x C-f" 'counsel-find-file)
  ("C-x r b" 'counsel-bookmark))
#+END_SRC

As you may know, in Emacs we use =tramp= to edit files remotely using =ssh= and
to edit local files as =root=. With the package =counsel-tramp= we have an
=counsel=-powered interface to use that mechanism!

This package looks up your hosts defined in =~/.ssh/config= to generate a list
with possible =ssh= connections, along with =sudo= possibilities (including
=localhost=!).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-tramp
  :after counsel
  :general
  ("C-c C-f" 'counsel-tramp))
#+END_SRC

**** Text

I use =company= as my completion framework. In the words of Dmitry Gutov:

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :general
  (:keymaps 'company-active-map
   "TAB" 'company-complete-selection
   "<right>" 'company-complete-common)
  :custom
  (company-idle-delay .2)
  (company-minimum-prefix-length 1)
  (company-require-match nil)
  (company-tooltip-align-annotations t)
  :config
  (add-to-list 'company-backends 'company-cmake)
  (global-company-mode 1))
#+END_SRC

*** Keybindings

These packages change keybindings and the default editing modes of Emacs.

**** Evil

=evil=, or /Extensible vi Layer/, is a minor mode that changes Emacs text
editing keybindings to match the modal edit modes of vi and vim. Yes, you can
have the best of both worlds!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :demand
  :init
  (defconst hcps/leader-key "SPC")
  :general
  (:states '(normal visual)
   :prefix hcps/leader-key
   ""  nil
   "f" 'counsel-find-file
   "b" 'ivy-switch-buffer
   "k" 'kill-this-buffer
   "K" 'kill-buffer
   "r" 'counsel-recentf
   "R" 'anzu-replace-at-cursor-thing
   "t" 'counsel-tramp
   "s" 'save-buffer
   "d" 'ranger
   "p" 'counsel-projectile-switch-project
   "w" 'delete-window
   "g" 'magit-status
   "o" 'ace-window
   "B" 'counsel-bookmark
   "y" 'counsel-yank-pop)
  :custom
  (evil-want-keybinding nil)
  (evil-emacs-state-cursor  '("red" box))
  (evil-normal-state-cursor '("gray" box))
  (evil-visual-state-cursor '("gray" hollow))
  (evil-insert-state-cursor '("gray" bar))
  (evil-motion-state-cursor '("gray" box))
  (evil-mode-line-format 'before)
  :config
  (evil-mode 1))
#+END_SRC

Also I use =evil-surround=, which is a port of =surround= from vim and allow you
to quickly delete or change surrounding ="= and ='= from words or paragraphs or
whatever, as it integrates with vim's verb way of expressing actions.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+END_SRC

=evil-org= adds a lot of useful keybindings to =org-mode=. I'm still not aware
of how much this adds or how similar they are to =prelude='s keys to org on
=evil=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :disabled
  :after (org evil)
  :hook
  ((org-mode . evil-org-mode)
   (evil-org-mode . (lambda () (evil-org-set-key-theme)))))
#+END_SRC

Following the previous package, =evil-org-agenda= sets up cool =evil= keys to
=org-agenda=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org-agenda
  :after evil-org
  :config
  (evil-org-agenda-set-keys))
#+END_SRC

=evil-visualstar= enables searching visual selections with the =*= key.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-visualstar
  :after evil)
#+END_SRC

The package =evil-collection= adds a bunch of cool =evil= keybindings to other
popular packages.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+END_SRC

=evil-mc= implements the =multiple-cursors= functionality to =evil-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-mc
  :after evil
  :general
  (:states 'visual
   "A" 'evil-mc-make-cursor-in-visual-selection-end
   "I" 'evil-mc-make-cursor-in-visual-selection-beg)
  :config
  (global-evil-mc-mode 1))
#+END_SRC

=evil-matchit= allows you to jump between tags automatically!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-matchit
  :after evil
  :custom
  (evilmi-may-jump-by-percentage nil)
  :config
  (global-evil-matchit-mode 1))
#+END_SRC

=evil-nerd-commenter= is a port of =nerd-commenter= from =vim= and it helps you
to be extremely efficient while commenting lines and text selections.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-nerd-commenter
  :after evil
  :config
  (evilnc-default-hotkeys nil t))
#+END_SRC

**** Hydra

=hydra= is a package that allows keybindings to be activated under the pressing
of a specific combination of keys. These will then be active as long as only
them are being pressed, as on the moment a key which isn't part of the hydra is
pressed the hydra is killed and the keybindings deactivated.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :general
  ("C-c e" 'hydra-eyebrowse/body)
  ("C-c f" 'hydra-flycheck/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

***** Eyebrowse

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-eyebrowse (:color blue)
   "
 ^
 ^Eyebrowse^         ^Do^                ^Switch^
 ^─────────^─────────^──^────────────────^──────^────────────
 _q_ quit            _c_ create          _<_ previous
 ^^                  _k_ kill            _>_ next
 ^^                  _r_ rename          _e_ last
 ^^                  ^^                  _s_ switch
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" eyebrowse-prev-window-config :color red)
   (">" eyebrowse-next-window-config :color red)
   ("c" eyebrowse-create-window-config)
   ("e" eyebrowse-last-window-config)
   ("k" eyebrowse-close-window-config :color red)
   ("r" eyebrowse-rename-window-config)
   ("s" eyebrowse-switch-to-window-config))
 #+END_SRC

***** Flycheck

 #+BEGIN_SRC emacs-lisp
 (defhydra hydra-flycheck (:color pink)
   "
 ^
 ^Flycheck^          ^Errors^            ^Checker^
 ^────────^──────────^──────^────────────^───────^───────────
 _q_ quit            _<_ previous        _?_ describe
 _m_ manual          _>_ next            _d_ disable
 _v_ verify setup    _f_ check           _s_ select
 ^^                  _l_ list            ^^
 ^^                  ^^                  ^^
 "
   ("q" nil)
   ("<" flycheck-previous-error)
   (">" flycheck-next-error)
   ("?" flycheck-describe-checker :color blue)
   ("d" flycheck-disable-checker :color blue)
   ("f" flycheck-buffer)
   ("l" flycheck-list-errors :color blue)
   ("m" flycheck-manual :color blue)
   ("s" flycheck-select-checker :color blue)
   ("v" flycheck-verify-setup :color blue))
 #+END_SRC

*** Buffers and windows

- *TODO*: make a hydra to change buffers like tabs (=h= goes to previous buffer,
  =l= to the next)

=windmove= is a package that creates commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :general
  ("C-M-<left>" 'windmove-left)
  ("C-M-<right>" 'windmove-right)
  ("C-M-<up>" 'windmove-up)
  ("C-M-<down>" 'windmove-down))
#+END_SRC

Originally, =midnight= is used to /run something at midnight/. I use its feature
that kills old buffers.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :custom
  (clean-buffer-list-delay-general 0.5)
  (clean-buffer-list-delay-special (* 1 3600))
  (clean-buffer-list-kill-buffer-names
   (nconc clean-buffer-list-kill-buffer-names "*IBuffer*" "*Finder*")))
#+END_SRC

Also, I use perspective to maintain multiple workspaces open with different
buffers in each.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package perspective
  :config
  (persp-mode))
#+END_SRC

*** Templates and snippets

I use =yasnippet= to handle my snippet needs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet
  :general
  (:keymaps 'yas-minor-mode-map
   "TAB" 'yas-expand)
  (:states 'insert
   "TAB" 'yas-expand)
  :custom
  (yas-snippet-dirs '("~/.emacs.d/snippets"))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (tex-mode . yas-minor-mode)
   (python-mode . yas-minor-mode))
  :config
  (yas-reload-all))
#+END_SRC

*** Folding

Enables vim-like folding of regions.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :general
  (:keymaps 'vimish-fold-folded-keymap
   "C-<tab>" 'vimish-fold-unfold)
  (:keymaps 'vimish-fold-unfolded-keymap
   "C-<tab>" 'vimish-fold-refold)
  :custom
  (vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory))
  (vimish-fold-header-width 79)
  :config
  (vimish-fold-global-mode 1))
#+END_SRC

*** Syntax Checking

=Flycheck= provides a reliable source to syntax checking in emacs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :demand
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay .3)
  :config
  (global-flycheck-mode))
#+END_SRC

=flycheck-pos-tip= shows the =flycheck= tip in a popup under the cursor.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-pos-tip
  :after flycheck
  :config
  (flycheck-pos-tip-mode))
#+END_SRC

*** Project management

For project management in Emacs, there's no better choice than =projectile=,
which is widely loved by the community.

It supports project-wide commands and actions, like killing all project buffers
or searching the whole project and replacing something.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :custom
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action 'neotree-projectile-action)
  :general
  ("s-p" '(:keymap projectile-command-map :package projectile))
  :config
  (projectile-global-mode))
#+END_SRC

And, as a further integration of =ivy= and =projectile=, there is a package that
makes actions such as =switch-project= to use =counsel='s completion and
ordering of results.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel-projectile
  :after (projectile counsel)
  :config
  (counsel-projectile-mode))
#+END_SRC

*** Regions and pointers

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :general
  ("C-+" 'er/contract-region)
  ("C-=" 'er/expand-region))
#+END_SRC

*** Indentation

I use =aggressive-indent= to keep my code indented as I type.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((emacs-lisp-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (c-mode-common-hook . aggressive-indent-mode))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

*** Utilities

Random utilities that don't fit anywhere else.

**** =helpful=

=helpful= is a package that is overall an improvement over the default =help=
windows.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful
  :general
  ("C-h f" 'helpful-callable)
  ("C-h v" 'helpful-variable)
  ("C-h k" 'helpful-key))
#+END_SRC

**** =dumb-jump=

=dumb-jump= is a package that allows you to jump to definition with minimal
setup (i.e. no TAG or RTAGS or etc.).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :general
  ("M-g o" 'dumb-jump-go-other-window)
  ("M-g j" 'dumb-jump-go))
#+END_SRC

**** =engine-mode=

=engine-mode= is a minor mode that allow you to easily make queries to the web
without leaving Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package engine-mode
  :config
  (defengine google
    "https://www.google.com/search?q="
    :keybinding "g")
  (engine-mode t))
#+END_SRC

**** =no-littering=

=no-littering= is a package that helps to maintain your =.emacs.d/= clean.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package no-littering
  :demand)
#+END_SRC

**** =pdf-tools=

=pdf-tools= is what should be the default =pdf-mode= for Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pdf-tools
  :config
  (pdf-loader-install))
#+END_SRC

** Theme

Here I define the theme that I use, which is =gruvbox=, as it provides nice
support for a lot of packages and is very pleasant for the eyes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme
  :demand
  :config
  (load-theme 'gruvbox-dark-medium t))
#+END_SRC

* Languages

Here I'll store any package load and configurations related to languages.

I still need to add packages relating to these languages:

- [X] Org
- [X] C/C++
- [ ] Python
- [ ] Scala
- [ ] LaTeX (use-package-ensure-system-package texlive-most)
- [X] R
- [X] Shell
- [X] Makefile
- [ ] Dot (using Graphviz)
- [ ] Lisp (duh)
- [X] PlantUML

** Org

=org-mode= is probably *the* killer mode and one of the main reasons as to why
anyone should try Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :mode (("\\.org$" . org-mode))
  :hook
  (org-mode . org-indent-mode)
  :custom
  (org-return-follows-link t)
  (org-highlight-latex-and-related '(latex script entities))
  (org-hide-leading-stars t)
  (org-support-shift-select nil)
  (org-directory "~/org/")
  (org-cycle-emulate-tab nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-src-fontify-natively t)
  :general
  (:states '(normal visual)
   :keymaps 'org-mode-map
   "gk" 'outline-up-heading
   "gj" 'outline-next-visible-heading
   "t" 'org-todo ; mark a TODO item as DONE
   "TAB" 'outline-toggle-children
   "<backtab>" 'org-global-cycle
   "RET" 'org-open-at-point
   "$" 'org-end-of-line ; smarter behaviour on headlines etc.
   "0" 'org-beginning-of-line ; ditto
   "-" 'org-ctrl-c-minus ; change bullet style
   "<" 'org-metaleft ; out-dent
   ">" 'org-metaright)
  (:states '(normal visual)
   :keymaps 'org-mode-map
   :prefix hcps/leader-key
   "c" 'org-cycle
   "e" 'org-export-dispatch
   "q" 'org-set-tags-command
   "a" 'org-attach
   "i" 'org-toggle-inline-images))
#+END_SRC

=org-journal= is a powerful tool to journal your day.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-journal
  :after org
  :custom
  (org-journal-dir (format-time-string "~/OneDrive/Documentos/.journal/%Y"))
  (org-journal-file-format "%Y%m%d")
  (org-journal-date-format "%e %b %Y (%A)")
  (org-journal-time-format "")
  :general
  ("C-c t" 'org-journal-new-entry))
#+END_SRC

=org-toc= is an useful way to automatically maintain an updated table of
contents of your =.org= file.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package toc-org
  :after org
  :hook
  (org-mode . toc-org-mode))
#+END_SRC

** C/C++

Here I set some defaults I appreciate for cc-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun c-mode-defaults ()
  (setq c-default-style "linux"
        c-basic-offset 4)
  (c-set-offset 'substatement-open 0))

(setq c-mode-defaults-hook 'c-mode-defaults)

;; this will affect all modes derived from cc-mode, like
;; java-mode, php-mode, etc
(add-hook 'c-mode-common-hook (lambda () (run-hooks 'c-mode-defaults-hook)))
#+END_SRC

In a sea of C and C++ packages for Emacs, I must make a mention for =irony=.
This package makes your low-level programming life way easier.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package irony
  :ensure company-irony
  :ensure company-irony-c-headers
  :ensure flycheck-irony
  :preface
  (defun hcps/irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))
  :hook
  ((c++-mode-hook . irony-mode)
   (c-mode-hook . irony-mode)
   (objc-mode-hook . irony-mode)
   (flycheck-mode-hook . flycheck-irony)
   (irony-mode-hook . irony-cdb-autosetup-compile-options)
   (irony-mode-hook . hcps/irony-mode-hook))
  :init
  (add-to-list 'company-backends '(company-irony company-irony-c-headers)))
#+END_SRC

Also, =rtags= is a project that aims to set up tags for C and C++ projects so
other tools can use them.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rtags
  :ensure company-rtags
  :hook
  (irony-mode-hook . rtags-start-process-unless-running)
  :custom
  (rtags-display-result-backend 'ivy)
  (rtags-completions-enabled t)
  :config
  (add-to-list 'company-backends 'company-rtags)
  (rtags-enable-standard-keybindings))
#+END_SRC

A very useful package for C and C++ is =cmake-ide=. In CMake projects it really
shines, as it uses CMake to get completion and syntax highlighting after
compilations.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cmake-ide
  :after (irony rtags)
  :config
  (cmake-ide-setup))
#+END_SRC

Also, the package =cpputils-cmake= sets up syntax highlighting to a bunch of
useful packages. It goes pretty well with =cmake-ide=.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cpputils-cmake
  :hook
  (c-mode-common-hook . (lambda ()
                          (if (derived-mode-p 'c-mode 'c++-mode)
                              (cppcm-reload-all)))))
#+END_SRC

In the department of code formatting, =clang-format= is a lovely tool that can
really be of great use while editing C and C++ code.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clang-format
  :ensure-system-package clang
  :preface
  (defun cc-format-on-save-hook ()
    (when c-buffer-is-cc-mode
      (clang-format-buffer)))
  :general
  (:keymaps 'c-mode-base-map
   "C-M-<tab>" 'clang-format-buffer)
  (:states '(normal visual)
   :keymaps 'c-mode-base-map
   :prefix hcps/leader-key
   "c" 'clang-format-region
   "C" 'clang-format-buffer)
  :hook
  (before-save-hook . #'cc-format-on-save-hook)
  :custom
  (clang-format-style "webkit"))
#+END_SRC

** R

For R you pretty much /need/ the =ess= package, i.e. /Emacs Speaks Statistics/.
It provides you with everything you need from R.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ess
  :config
  (require 'ess-r-mode))
#+END_SRC

** Shell

For =shell= completion I use =bash-complete=, which auto completes several
=bash= functions.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package bash-completion
  :hook
  (shell-dynamic-complete-funtions . bash-completion-dynamic-complete))
#+END_SRC

** Makefile

In Makefile files we have a special case: it /needs/ tabulators to work. So,
we'll set that up.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun makefile-mode-defaults ()
  (whitespace-toggle-options '(tabs))
  (setq indent-tabs-mode t ))

(setq makefile-mode-hook 'makefile-mode-defaults)

(add-hook 'makefile-mode-hook (lambda () (run-hooks 'makefile-mode-hook)))
#+END_SRC

** PlantUML

/PlantUML/ is a graph language that describes loads of different diagram types,
mainly focusing on /UML/, of course.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package plantuml-mode
  :mode "\\.plantuml\\'"
  :interpreter "plantuml")
#+END_SRC

** Lisp

Fix for the annoying keyword default indentation:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
,* `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
,* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
,* a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+END_SRC

And the necessary hook:

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook
          (lambda () (setq-local lisp-indent-function #'fuco1/lisp-indent-function)))
#+END_SRC

* Personal

Stuff that isn't either a package nor a language nor downloadable: stuff you
coded yourself.

To-do:

- [ ] Increase/decrease font size
- [ ] Input date on command (and as a new heading in =org-mode=)

** Functions

Some very useful functions I got from other people or that I coded myself.

*** Date

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun hcps/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun hcps/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun hcps/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun hcps/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun hcps/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun hcps/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

** Keybindings

Here I'll define some of my personal keybindings.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x k") 'kill-this-buffer)
(global-set-key (kbd "C-c x") 'hcps/date-iso)
#+END_SRC
